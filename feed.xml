<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Harttle Land</title>
		<description>欢迎访问 Harttle 的个人主页，这里记录了 harttle 关于计算机技术的文章、个人信息与相册，以及有用的资源分享和下载。</description>
		<link>http://harttle.github.io</link>
		<atom:link href="http://harttle.github.io/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Modern Operating Systems</title>
				<description>&lt;h1&gt;Introduction&lt;/h1&gt;
&lt;h2&gt;What is OS&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;extendes machines&lt;/strong&gt; : providing programmers(and programs) a clean abstract set of resources instead of the messy hardware&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;resource manager&lt;/strong&gt; : managing hardware resources&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;History of OS&lt;/h2&gt;
&lt;p&gt;The first digital computer was designed by Charles Babbage. Ada Lovelace was the first programmer(hired by Babbage).&lt;/p&gt;
&lt;h3&gt;1st Generation Vacuum Tubes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The first functioning digital computer, by John Atanasoff and Clifford Berry, Iowa State University.&lt;/li&gt;
&lt;li&gt;Z3, Konrad Zuse, Berlin.&lt;/li&gt;
&lt;li&gt;Colossus, a group at Bletchey Park, England&lt;/li&gt;
&lt;li&gt;Mark I, Howard Aiken, Harvard&lt;/li&gt;
&lt;li&gt;ENIAC, William Mauchley and J. Presper Eckert, University of Pennsylvania&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;

&lt;h3&gt;2nd Generation Transistors and Batch System&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;batch system&lt;/strong&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Programmers bring cards to IBM 1401&lt;/li&gt;
&lt;li&gt;1401 read batch of jobs onto tape&lt;/li&gt;
&lt;li&gt;Operator carries input tape to IBM 7094&lt;/li&gt;
&lt;li&gt;7094 does computing&lt;/li&gt;
&lt;li&gt;Operator carries output tape to 1401&lt;/li&gt;
&lt;li&gt;1401 prints output&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3rd Generation ICs and Multiprogramming&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IBM System/360&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;A series of software-compatible machines differed only in price and performance.&lt;/p&gt;
&lt;p&gt;360 was the first major computer line to use &lt;strong&gt;ICs(Integrated Circuits)&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OS/360&lt;/strong&gt; had to work on all models, the result was an enormous and complex OS, each release fixed some bugs and introduced new ones.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;multiprogramming&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Partition memory into several pieces, with a different job in each partition. While one job was waiting for I/O, another job could be using the CPU.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spooling&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Simultaneous Peripheral Operation On Line, OS read jobs from cards onto the disk as soon as they were brought to the computer room, whenever a running job finished, the operating system could load a new job from the disk and run it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;timesharing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Proveding quick response time. The 1st general-purpose timesharing system, **CTSS(Compatible Time Sharing System) was developed at MIT.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MULTICS(MULTiplexed Information and Computing Service)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Developed by MIT, Bell Labs, and General Electric, MULTICS supports handreds of uses on a machine only slightly powerful than an Intel 386-based PC.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;minicomputer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DEC PDP-1(1961) and other PDPs(all incompatible)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNIX&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Developed by Ken Thompson(based on PDP-7  minicomputer). There are 2 major versions: &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System V&lt;/strong&gt;(from AT&amp;amp;T) and &lt;strong&gt;BSD&lt;/strong&gt;(Berkeley Software Distribution)&lt;/p&gt;
&lt;p&gt;1987, &lt;strong&gt;MINIX&lt;/strong&gt; was released for educational purposes.&lt;/p&gt;
&lt;h3&gt;4th Generation Personal Computers&lt;/h3&gt;
&lt;p&gt;With the development of &lt;strong&gt;LSI&lt;/strong&gt;(Large Scale Integration) circuits, &lt;strong&gt;microcomputers&lt;/strong&gt; appears.&lt;/p&gt;
&lt;p&gt; Kildall developed &lt;strong&gt;CP/M&lt;/strong&gt;(Control Program for Microcomputers, disk-based OS), which later supports 8080, Zilog Z80, and other CPU chips.&lt;/p&gt;
&lt;p&gt;Bill Gates offered &lt;strong&gt;DOS&lt;/strong&gt;(Disk Operating System, which renamed to MS-DOS later) to IBM.&lt;/p&gt;
&lt;p&gt;Engelbart invented the &lt;strong&gt;GUI&lt;/strong&gt;(Graphical User Interface), which was adopted by Xerox PARC.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apple&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Steve Jobs visited PARC and embarked on building an Apple with a GUI.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Microsoft released Windows 95, Windows 98(with 16-bit Intel CPU), Windows NT(New Technology, 32-bit), Windows Me(Millennium edition), Windows 2000(1999,renamed from Windows NT5), and Windows XP(2001).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UNIX&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;FreeBSD, originating from BSD project at Berkeley. X Window System(X11), MIT.&lt;/p&gt;
&lt;h2&gt;OS ZOO&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Mainframe OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Oriented toward process many jobs at once, most of which need prodigious amounts of I/O.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Server OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Serve multiple users at once over a network and allow the users to share hardware and software resources.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mutiprocessor OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Special features for communication, connectivity, and consistency.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Personal Computer OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provide good surport to a single user.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Handheld Computer OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PDA&lt;/strong&gt;(Personal Digital Assistant) and mobiles.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Embedded OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Donot accept user-installed software.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sensor Node OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tiny computers that communicate with each other and with a base station using wireless communication.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Real-Time OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hard real-time&lt;/strong&gt; the action absolutely must occur at a certain moment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;soft real-time&lt;/strong&gt; missing an occasional deadline is acceptable and does not cause any permanent damage.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Smart Card OS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Some are Java-oriented. The ROM holds an interpreter for the JVM.&lt;br&gt;Resource management and protection.&lt;/p&gt;
&lt;h2&gt;OS Structure&lt;/h2&gt;
&lt;h3&gt;Monolithic Systems&lt;/h3&gt;
&lt;p&gt;Basic sturctures&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A main program that invokes requested service procedure.&lt;/li&gt;
&lt;li&gt;A set of service procedures that carry out the system calls.&lt;/li&gt;
&lt;li&gt;A set of utility procedures that help the service procedures.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Layered Systems&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;THE&lt;/strong&gt; system built by E. W. Dijkstra.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;layer&lt;/th&gt;
&lt;th style=&quot;text-align:left&quot;&gt;function&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;5&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;The operator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;4&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;User programs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;3&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;I/O management&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;2&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Operator-process communication&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Memory and drum management&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;0&lt;/td&gt;
&lt;td style=&quot;text-align:left&quot;&gt;Processor allocation and multiprogramming&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;MULTICS&lt;/strong&gt; was described as having a series of concentric rings, with the inner ones being more privileged than the outer ones.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The advantage is that it can be easily extended to structure user subsystems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Microkernels&lt;/h3&gt;
&lt;p&gt;Achieve high reliability by spilitting the OS into small, well-defined modules, only one of which(the microkernel) runs in kernel mode.&lt;/p&gt;
&lt;p&gt;An idea related to having a minimal kernal is to put the &lt;strong&gt;mechanism&lt;/strong&gt; for doing something in the kernel but not &lt;strong&gt;policy&lt;/strong&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A few of better-known microkernels: Integrity, K42, Symbian, and MINIX 3.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Client-Server Model&lt;/h3&gt;
&lt;p&gt;A slight variantion of the microkernel idea is to distinguish 2 classes of processes, the &lt;strong&gt;servers&lt;/strong&gt;(providing services), and the &lt;strong&gt;clients&lt;/strong&gt;(use these services).&lt;/p&gt;
&lt;h3&gt;Virtual Machines&lt;/h3&gt;
&lt;h4&gt;Type 1 hypervisor&lt;/h4&gt;
&lt;p&gt;Also known as &lt;strong&gt;virtual machine monitor&lt;/strong&gt;, runs upon th e hardware.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CP/CMS&lt;/strong&gt; , later renamed VM/370 is a timesharing system provedes &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;multiprogramming &lt;/li&gt;
&lt;li&gt;extended machine with a more convenient interface than the bare hardware&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;CMS&lt;/strong&gt; (Conversational Monitor System), a single-user, interactive processing OS.&lt;/p&gt;
&lt;h4&gt;Type 2 hypervisor&lt;/h4&gt;
&lt;p&gt;Runs upon the Host OS, like other applications.&lt;/p&gt;
&lt;h3&gt;Exokernels&lt;/h3&gt;
&lt;p&gt;Rather than cloning the actual machine, another strategy is pratitioning it, giving each user a subset of the resources.&lt;/p&gt;
&lt;p&gt;At the bottom layer, running in kernel mode, is a program called the &lt;strong&gt;exokernal&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Processes and Threads&lt;/h1&gt;
&lt;h2&gt;Processes&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;pseudoparallelism&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The illusion of parallelism while CPU is switching from process to process quickly.&lt;/p&gt;
&lt;h3&gt;The Process Model&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;process&lt;/strong&gt; is an instance of an executing program, is the activity of a program.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If a program is running twice, it counts as two processes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Process Creation&lt;/h3&gt;
&lt;p&gt;When processes are created&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;System init&lt;/li&gt;
&lt;li&gt;Process creation system call by a running process&lt;/li&gt;
&lt;li&gt;A user request to create a new process.&lt;/li&gt;
&lt;li&gt;Init of a batch job.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;fork&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In Unix, this call creates an exact clone of the calling process. &lt;code&gt;execve&lt;/code&gt; is another syscall used to change its memory image and run a new program.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This separation allows the child to manipulate its file descriptors after &lt;code&gt;fork&lt;/code&gt; but before the &lt;code&gt;execve&lt;/code&gt; in order to accomplish redirections.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;CreateProcess&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;In Windows, this call handles both process creation and loading with 10 parameters.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;#39;s possible for a newly created process to share resources such as open files.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Process Termination&lt;/h3&gt;
&lt;p&gt;When processes terminate&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Normal exit (voluntary)&lt;/li&gt;
&lt;li&gt;Error exit (voluntary)&lt;/li&gt;
&lt;li&gt;Fatal error (involuntary)&lt;/li&gt;
&lt;li&gt;Killed by another process (involuntary)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Voluntary termination: &lt;code&gt;exit&lt;/code&gt; in UNIX and &lt;code&gt;ExitProcess&lt;/code&gt; in Windows. Kill someother process: &lt;code&gt;kill&lt;/code&gt; in UNIX and &lt;code&gt;TerminateProcess&lt;/code&gt; in Windows.&lt;/p&gt;
&lt;h3&gt;Process Hierarchies&lt;/h3&gt;
&lt;p&gt;In UNIX, a process and all its children and further descendants form a process group. User signals are sends to all members in the group.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt; is the first process created in boottime. Thus all processes in the whole system belong to a single tree with &lt;code&gt;init&lt;/code&gt; as the root.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Windows has no concept of process hierarchy, despite that a handle(a special token used to control the child) is returnd when creating a new process.&lt;/p&gt;
&lt;h3&gt;Process States&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Running (actually using the CPU)&lt;/li&gt;
&lt;li&gt;Ready (runnable; temporariy stopped to let another process run)&lt;/li&gt;
&lt;li&gt;Blocked (unable to run util some external event happens)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Implementation of Processes&lt;/h3&gt;
&lt;p&gt;The OS maintains a &lt;strong&gt;process table&lt;/strong&gt; , with one entry ( &lt;strong&gt;process control block&lt;/strong&gt; ) per process. Each entry contains program counter, stack pointer, memory allocation, status of open files, scheduling information registers, and everything need to save when swapped out.&lt;/p&gt;
&lt;p&gt;Interrupt routine&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hardware stacks program counter, etc&lt;/li&gt;
&lt;li&gt;Hardware loads new program counter from interrupt vector&lt;/li&gt;
&lt;li&gt;Assembly language procedure saves registers.&lt;/li&gt;
&lt;li&gt;Assembly language procudure sets up new stack.&lt;/li&gt;
&lt;li&gt;C interrupt service runs (typically reads and buffers input).&lt;/li&gt;
&lt;li&gt;Scheduler decides which process is to run next.&lt;/li&gt;
&lt;li&gt;C procedure returns to the assembly code.&lt;/li&gt;
&lt;li&gt;Assembly language procedure starts up new current processes.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Modeling Multiprogramming&lt;/h3&gt;
&lt;p&gt;Suppose p is the fraction of I/O time for a process. n is current count of processes. Then&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(CPU~utilization = 1 - p^n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where n is called the &lt;strong&gt;degree of multiprogramming&lt;/strong&gt; .&lt;/p&gt;
&lt;h2&gt;Threads&lt;/h2&gt;
&lt;h3&gt;Thread Usage&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Multiple activities going on at once with the ability to share an address space&lt;/li&gt;
&lt;li&gt;Lighter weight than processes, easy to create and destroy.&lt;/li&gt;
&lt;li&gt;Overlap activities with substantial I/O to speeding up the application.&lt;/li&gt;
&lt;li&gt;Useful on systems with multiple CPUs.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Three ways to construct a server&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Thread. Parallelism, blocking system calls.&lt;/li&gt;
&lt;li&gt;Single-threaded process. No parallelism, blocking system calls.&lt;/li&gt;
&lt;li&gt;Finite-state machine. Parallelism, nonblocking system calles, use interrupts to simulate thread.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Classical Thread Model&lt;/h3&gt;
&lt;p&gt;Processes are used to group resources together; threads are the entities scheduled for execution on the CPU. There are no protection betwwen threads because (1) it&amp;#39;s impossible, and (2) it should not be nessessary.&lt;/p&gt;
&lt;p&gt;While threads share one memory space, it takes fewer space to maintain a thread, including Program Counter, Registers, Stack and State.&lt;/p&gt;
&lt;h3&gt;POSIX Threads&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Pthread_create&lt;/code&gt;: create a new thread.&lt;br&gt;&lt;code&gt;Pthread_exit&lt;/code&gt;: terminate the calling thread.&lt;br&gt;&lt;code&gt;Pthread_join&lt;/code&gt;: wait for a specific thread to exit.&lt;br&gt;&lt;code&gt;Pthread_yield&lt;/code&gt;: release the CPU.&lt;br&gt;&lt;code&gt;Pthread_attr_init&lt;/code&gt;: create and initialize a thread&amp;#39;s attribute structure.&lt;br&gt;&lt;code&gt;Pthread_attr_destroy&lt;/code&gt;: remove a thread&amp;#39;s attribute structure.&lt;/p&gt;
&lt;h3&gt;Implementing Threads in User Space&lt;/h3&gt;
&lt;p&gt;Advantages&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;useful on an OS that doesn&amp;#39;t support threads&lt;/li&gt;
&lt;li&gt;switching is faster than trapping to the kernal&lt;/li&gt;
&lt;li&gt;allow process have its own scheduling algorithm&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Problems&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Implementation of blocking sys-calls. &lt;/p&gt;
&lt;p&gt; These calles intended to block the process (all threads in it) since the kernal know nothing about threads. This problem could be solved by adding &lt;strong&gt;wrappers&lt;/strong&gt; to all blocking sys-calls.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Page faults.&lt;/p&gt;
&lt;p&gt; The same as above.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;A running thread never voluntarily gives up the CPU since no clock interrupts in user space.&lt;/li&gt;
&lt;li&gt;Substantial sys-calles are needed generally in threads. It&amp;#39;s hardly any more work for the kernel to switch threads.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Implementing Threads in the Kernel&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Due to the relatively greater cost of creating and destroying threads in the kernel, some systems take an environmentally correct approach and recycle their threads.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Problems&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;When a multithreades process forks&lt;/li&gt;
&lt;li&gt;Signals sent to a multithread process&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Hybrid Implementations&lt;/h3&gt;
&lt;p&gt;Programmers can determine how many kernel threads to use and how many user-level threads to multiplex on each one.&lt;/p&gt;
&lt;h3&gt;Scheduler Activations&lt;/h3&gt;
&lt;p&gt;The kernel notifies the process&amp;#39; run-time system to switch thread, thus avoiding unnecessary transitions between user and kernel space.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This implementation violates the structure inherent in any layered system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Pop-Up Threads&lt;/h3&gt;
&lt;p&gt;On arrival of a message, the system creates a new thread to handle it. Since a pop-up thread has no history, it&amp;#39;s quicker to create than swap.&lt;/p&gt;
&lt;h3&gt;Making Single-Threaded Code Multithread&lt;/h3&gt;
&lt;p&gt;Problems should be solved&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;global variables&lt;/p&gt;
&lt;p&gt; Private global variables. A new library to create, set, read these variables is needed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;many library procedures are not reentrant&lt;/p&gt;
&lt;p&gt; A jacket for each of these procedures is needed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;signals&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stack management&lt;/p&gt;
&lt;p&gt; overflows could not be awared.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Interprocess Communication&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;race conditions&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Two or more processes are reading or writing some shared data and the final result depends on who runs precisely when.&lt;/p&gt;
&lt;h3&gt;Critical Regions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;mutual exclusion&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Prohibit more than one process from reading and writing the shared data at the same time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;critical region&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Also called &lt;strong&gt;critical section&lt;/strong&gt; , the part of the program where the shared memory is accessed.&lt;/p&gt;
&lt;p&gt;Conditions to a good solution&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;No two processes may be simultaneously inside their critical regions&lt;/li&gt;
&lt;li&gt;No assumptions may be made about speeds or the number of CPUs&lt;/li&gt;
&lt;li&gt;No process running outside its critical region may block other processes&lt;/li&gt;
&lt;li&gt;No process should have to wait forever to enter its critical region&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Mutual Exclusion with Busy Waiting&lt;/h3&gt;
&lt;h4&gt;Disable Interrupts&lt;/h4&gt;
&lt;p&gt;Problems&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It&amp;#39;s unwise to give user processes the power to turn off interrupts.&lt;/li&gt;
&lt;li&gt;It&amp;#39;s convenient for the kernel itself to disable interrupts for a few instructions, when race conditions could occur.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Lock Variables&lt;/h4&gt;
&lt;p&gt;This would not take place without atom operations.&lt;/p&gt;
&lt;h4&gt;Strict Alternation&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//Process 1&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(TRUE){
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (turn != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);
    critical_region();
    turn = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
    noncritical_region();
}

&lt;span class=&quot;hljs-comment&quot;&gt;//Process 2&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(TRUE){
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(turn != &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
    critical_region();
    turn = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
    noncritical_regino();
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Problem: neither of them could run twice in a row, which violates condition 3.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Continuously testing a variable until some value apperas is called &lt;strong&gt;busy waiting&lt;/strong&gt; , a lock that uses busy waiting is called a &lt;strong&gt;spin lock&lt;/strong&gt; .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Peterson&amp;#39;s Solution&lt;/h4&gt;
&lt;p&gt;Busy waiting lock variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;#define FALSE 0&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#define TRUE 1&lt;/span&gt;
&lt;span class=&quot;hljs-preprocessor&quot;&gt;#define N 2&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; turn;
&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; interested[N];

&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; enter_region(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; process)
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; other = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - process;
    interested[process] = TRUE;
    turn = process;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (turn == process &amp;amp;&amp;amp; interested[other] == TRUE);
}

&lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; leave_region(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; process)
{
    interested[process] = FALSE;
}&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;TSL Instruction&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;TSL RX, &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;LOCK&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Test and lock lock instruction reads the content of the memory word &lt;code&gt;lock&lt;/code&gt; into register &lt;code&gt;RX&lt;/code&gt; and then stores a nonzero value at the memory address &lt;code&gt;lock&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&amp;#39;s guaranteed by the hardware that the read and set operations are indivisible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;enter_region:&lt;/span&gt;
    TSL REGISTER, LOCK
    JNE REGISTER, &lt;span class=&quot;hljs-comment&quot;&gt;#0, enter_region&lt;/span&gt;
    RET     &#39;return

&lt;span class=&quot;hljs-title&quot;&gt;leave_region:&lt;/span&gt;
    MOVE LOCK, &lt;span class=&quot;hljs-comment&quot;&gt;#0&lt;/span&gt;
    RET&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An alternative instruction to &lt;code&gt;TSL&lt;/code&gt; is &lt;code&gt;XCHG&lt;/code&gt;. The implementations are similiar.&lt;/p&gt;
&lt;h3&gt;Sleep and Wakeup&lt;/h3&gt;
&lt;p&gt;Problems in busy waiting:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;wasting CPU time&lt;/li&gt;
&lt;li&gt;process with higer priority will keep busy waiting while lower priority process never run&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;The Product-Consumer Problem&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;Producer loop:
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; count == N:
        sleep
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
        produce one
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; count == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:
        wakeup consumer

Consumer loop:
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; count == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:
        sleep
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
        consume one
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; count == N-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        wakeup producer&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Since &lt;code&gt;count&lt;/code&gt; is unconstrained, race condition could occur. When consumer is about to sleep, wakeup signal from producer is lost, causing both of them sleeping.&lt;/p&gt;
&lt;h4&gt;Semaphores&lt;/h4&gt;
&lt;p&gt;Semaphores are used to buffer signals, keep them from losing. Value 0 indicating that no wakeups were saved; positive value if some wakeups were pending.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;down&lt;/code&gt;(Proberen, try in Dutch) operation: checking the value and cosume one or sleep to wait one.&lt;br&gt;&lt;code&gt;up&lt;/code&gt;(Verhogen, raise in Dutch) operation: produce one, if someone&amp;#39;s waiting, wake him.&lt;/p&gt;
&lt;h3&gt;Mutexes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;mutex&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;A kind of semaphore, a variable that can be in 1 of 2 states: unlocked or locked, used when the semaphore&amp;#39;s ability to count is not needed.&lt;/p&gt;
&lt;h3&gt;Monitors&lt;/h3&gt;
&lt;p&gt;When several mutexes are refered to, deadlock could occur by a subtle error. &lt;strong&gt;Monitors&lt;/strong&gt; are provided by some programming languages to manage a group of mutual exclusive threads. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Only one of the threads in this group would run in a certain time. It&amp;#39;s up to the compiler to arrange mutexes to accomplish the monitor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Message Passing&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;message passing&lt;/strong&gt; is used for information exchange between machines. This method of interprocess communication uses 2 primitives, &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Approaches:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;mailbox&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt; A mailbox is a place to buffer a certian number of messages.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;rendezvous&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; No buffering, either of each primitive is blocked until the other occurs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Barriers&lt;/h3&gt;
&lt;p&gt;With multiple processes, a &lt;strong&gt;barrier&lt;/strong&gt; can be placed at the end of each phase. When a process reaches the barrier, it&amp;#39;s blocked until all processes have reached the barrier.&lt;/p&gt;
&lt;h2&gt;Scheduling&lt;/h2&gt;
&lt;h3&gt;Introduction to Scheduling&lt;/h3&gt;
&lt;h4&gt;Personal Computer&lt;/h4&gt;
&lt;p&gt;Scheduling is simpler in personal computers because (1) there is only one active process, (2) CPU is more faster than I/O.&lt;/p&gt;
&lt;h4&gt;Process Behavior&lt;/h4&gt;
&lt;p&gt;Compute-bound: long CPU bursts and thus infrequent I/O waits.&lt;br&gt;I/O-bound: short CPU bursts and thus frequent I/O waits.&lt;/p&gt;
&lt;h4&gt;When to Schedule&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;A new process is created&lt;/li&gt;
&lt;li&gt;A process exits&lt;/li&gt;
&lt;li&gt;A process blocks on I/O&lt;/li&gt;
&lt;li&gt;I/O interrupt occurs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Types of schedule algorithm&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;nonpreemptive&lt;/strong&gt; scheduling algorithm: picks a process to run until it blocks, exit, or voluntarily release the CPU.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;preemptive&lt;/strong&gt; scheduling algorithm: picks a process and lets it run for a maximum of some fixed time.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Goals of Scheduling Algorithms&lt;/h4&gt;
&lt;p&gt;All systems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fainess - giving each process a fair share of the CPU&lt;/li&gt;
&lt;li&gt;Policy enforcement - seeing that stated policy is carried out&lt;/li&gt;
&lt;li&gt;Balance - keeping all parts of the system busy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Batch systems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Throughput - maximize jobs per hour&lt;/li&gt;
&lt;li&gt;Turnaround tiem - minimize time between submission and termination&lt;/li&gt;
&lt;li&gt;CPU utilization - keep the CPU busy all the time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Interactive systems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Response time - respond to requests quickly&lt;/li&gt;
&lt;li&gt;Propertionality - meets user&amp;#39;s expectations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Real-time systems&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Meeting deadlines - avoid losing data&lt;/li&gt;
&lt;li&gt;Predictability - avoid quality degradation in multimedia systems&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Scheduling in Batch Systems&lt;/h3&gt;
&lt;h4&gt;First-Come First-Served&lt;/h4&gt;
&lt;h4&gt;Shortest Job First&lt;/h4&gt;
&lt;p&gt;Reduce the mean turnaround time.&lt;/p&gt;
&lt;h4&gt;Shortest Remaining Time Next&lt;/h4&gt;
&lt;p&gt;When new process enterd, its executime is compared with the remaining time of current process.&lt;/p&gt;
&lt;h3&gt;Scheduling in Interactive Systems&lt;/h3&gt;
&lt;h4&gt;Round-Robin Scheduling&lt;/h4&gt;
&lt;p&gt;Each process is assigned a time interval, called its &lt;strong&gt;quantum&lt;/strong&gt; , during which it is allowed to run. The CPU switches when the process blocks, of course.&lt;/p&gt;
&lt;p&gt;Setting the quantum too short causes too many process switches and lowers the CPU efficiency, but setting it too long may cause poor response to short interactive requests. A quantum arount 20-50 msec is often a resnable compromise.&lt;/p&gt;
&lt;h4&gt;Priority Scheduling&lt;/h4&gt;
&lt;p&gt;Each process is assigned a priority, and the runable process with the highest priority is allowed to run. The priority of the running process decreases at each clock tick.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A simple algorithm for giving a good service to I/O bound processes is to set the priority to 1/f, where f is the fraction of the last quantum that a process used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Multiple Queues&lt;/h4&gt;
&lt;p&gt;Set up priority classes, a group of processes sorted by priority in each class. &lt;/p&gt;
&lt;p&gt;Whenever a process used up all the quanta allocted to it, it was moved down one class, saving the CPU for short, interactive processes.&lt;/p&gt;
&lt;p&gt;Whenever a carriage return was typed at a terminal, the process belonging to that terminal was moved to the highest priority class. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This prevents a process that needed to run for a long time when it first started but became interactive later, from being punished forever.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Shorted Process Next&lt;/h4&gt;
&lt;p&gt;To a certain extent, it would be nice if this algorithm used in batch systems could be used for interactive processes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;aging&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Estimating running time as &lt;span class=&quot;mathjax&quot;&gt;\(t = aT_0 + (1-a)T_1\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;Guaranteed Scheduling&lt;/h4&gt;
&lt;p&gt;Make real promises to the users about performance ahd then live up to those promises.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Compute the ratio of actual CPU time consumed to CPU time entitled.&lt;/li&gt;
&lt;li&gt;Run the process with the lowest ratio until its ratio is no longer the lowest.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Lottery Scheduling&lt;/h4&gt;
&lt;p&gt;Give processes lottery tickets for various system resources. Whenever a scheduling decision has to be made, a lottery ticket is chosen at random, and the process holding that ticket gets the resource.&lt;/p&gt;
&lt;p&gt;Advantages&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;lottery scheduling is highly responsive, the process have more lottery tickets is more likely to get the turn.&lt;/li&gt;
&lt;li&gt;processes can exchange lottery tickets, the server and the client for example.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Fair-Share Scheduling&lt;/h4&gt;
&lt;p&gt;Each user is allocated some fraction of the CPU and the scheduler picks processes in such a way to enforce it.&lt;/p&gt;
&lt;p&gt;For example, user 1 created process A B C D, while user 2 only created process E, the scheduling sequence should be:&lt;/p&gt;
&lt;p&gt;A E B E C E ...&lt;/p&gt;
&lt;p&gt;If user 1 is entitled to twice as much CPU time as user 2, the sequence should be:&lt;/p&gt;
&lt;p&gt;A B E C D E ...&lt;/p&gt;
&lt;h3&gt;Scheduling in Real-Time Systems&lt;/h3&gt;
&lt;p&gt;The events that a real-time system may have to respond to can be categorized as &lt;strong&gt;periodic&lt;/strong&gt; (occurring at regular intevals) or &lt;strong&gt;aperiodic&lt;/strong&gt; (occurring unpredictably).&lt;/p&gt;
&lt;p&gt;Depending on how much time each event requires for processing, it may not even be possible to handle them all. A real-time system that meets this requirement is said to be &lt;strong&gt;schedulable&lt;/strong&gt; .&lt;/p&gt;
&lt;h3&gt;Policy versus Mechanism&lt;/h3&gt;
&lt;p&gt;Separate the scheduling mechanism from the scheduling policy to alow more flexible scheduling. What this means is that the scheduling algorithm is parameterized in some way.&lt;/p&gt;
&lt;h3&gt;Thread Scheduling&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/thread-scheduling.png&quot; alt=&quot;thread-scheduling&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kernel-level thread doesn&amp;#39;t block the entire process when blocking sys-calls are made, unlike user-level thread.&lt;/li&gt;
&lt;li&gt;Since the kernel knows that switching from a thread in process A to a thread in process B is more expensive than running a second thread in process A, it can take this into account when making a decision.&lt;/li&gt;
&lt;li&gt;User-level threads can employ an application-specific thread scheduler.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Memory Management&lt;/h1&gt;
&lt;h2&gt;No Memory Abstraction&lt;/h2&gt;
&lt;p&gt;Running multiple programs by &lt;strong&gt;static relocation&lt;/strong&gt;: Modify the second program on the fly as it loaded it into memory.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The lack of memory abstraction is still common in embedded and smart card systems.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;A Memory Abstraction: Address Spaces&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Address space&lt;/strong&gt; is the set of addresses that a process can use to address memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic relocation&lt;/strong&gt; uses base and limit registers to map each process&amp;#39; address space onto a different part of physical memory in a simple way.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The disadvantage of relocation using base and limit registers is the need to perform an addition and comparison on every memory reference.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Swapping&lt;/strong&gt; is used to deal with memory overload, bringing in each process in its entirety, running for a while, then putting it back on the disk.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When swapping creates multiple holes in memory, it&amp;#39;s possible to combine them all into one big one, which is called &lt;strong&gt;memory compaction&lt;/strong&gt;.&lt;br&gt;Free memory can be recorded as bitmaps or linked lists.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Virtual Memory&lt;/h2&gt;
&lt;p&gt;Processes use program generated addresses, called &lt;strong&gt;virtual address&lt;/strong&gt;. They go to an &lt;strong&gt;MMU(Memory Management Unit)&lt;/strong&gt; that maps the virtual addresses onto the physical addresses when a memory access occurs.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;virtual memory&lt;/strong&gt; allows programs to run even when they are only partially in main memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Page Tables&lt;/h3&gt;
&lt;p&gt;The virtual address space is divided into fixed-size units called &lt;strong&gt;pages&lt;/strong&gt;. The corresponding units in the physical memory are called &lt;strong&gt;page frames&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The virtual address is split into a virtual page number and an offset. The virtual page number is used as and index into the page table to find the entry for that page. Each &lt;strong&gt;page table entry(PTE)&lt;/strong&gt; consists a Caching disabled bit, Referenced bit, Modified bit, Present/absent bit and page frame number.&lt;/p&gt;
&lt;h3&gt;TLB&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;TLB(Translation Lookaside Buffers)&lt;/strong&gt; is used to speed up paging. It&amp;#39;s usually inside the MMU and consists of a small number of entries. Each entry contains information about one page, including the virtual page number, a bit that is set when the page is modified, the protection code, and the physical page frame in which the page is locted.&lt;/p&gt;
&lt;h3&gt;Page Tables for Large Memories&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;multilevel page table&lt;/strong&gt; avoids keeping all the page tables in memory all the time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Inverted page table&lt;/strong&gt; is a solution for 64-bit computers. There is one entry per page frame in real memory, rather than one entry per page of virtual address space.&lt;/p&gt;
&lt;h3&gt;Page Replacement Algorithms&lt;/h3&gt;
&lt;h4&gt;The optimal page replacement algorithm&lt;/h4&gt;
&lt;p&gt;Each page can be labeled with the number of instructions that will be executed before that page is first referenced. And the page with the highest label should be removed.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The only problem with this algorithm is that it&amp;#39;s unrealizable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;The Not Recently Used Page Replacement Algorithm&lt;/h3&gt;
&lt;h3&gt;The First-in, First-out Page Replacement Algorithm&lt;/h3&gt;
&lt;h3&gt;The Second-Chance Page Repcacement Algoritm&lt;/h3&gt;
&lt;h3&gt;The Clock Page Replacement Algorithm&lt;/h3&gt;
&lt;h3&gt;The Least Recently Used Page Replacement Algorithm&lt;/h3&gt;
&lt;h3&gt;The Working Set Page Replacement Algorithm&lt;/h3&gt;
&lt;p&gt;Keep track of each process&amp;#39; working set and make sure that it is in memory before letting the process run, which is called &lt;strong&gt;prepaging&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;File System&lt;/h1&gt;
&lt;h2&gt;Files&lt;/h2&gt;
&lt;h3&gt;File structure&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Byte sequence&lt;/li&gt;
&lt;li&gt;Record sequence&lt;/li&gt;
&lt;li&gt;Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;File Types&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Regular files&lt;/li&gt;
&lt;li&gt;Directories&lt;/li&gt;
&lt;li&gt;Character special files&lt;/li&gt;
&lt;li&gt;Block special files&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;File operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Create&lt;/li&gt;
&lt;li&gt;Delete&lt;/li&gt;
&lt;li&gt;Open&lt;/li&gt;
&lt;li&gt;Close&lt;/li&gt;
&lt;li&gt;Read&lt;/li&gt;
&lt;li&gt;Write&lt;/li&gt;
&lt;li&gt;Append&lt;/li&gt;
&lt;li&gt;Seek&lt;/li&gt;
&lt;li&gt;Get attributes&lt;/li&gt;
&lt;li&gt;Set attributes&lt;/li&gt;
&lt;li&gt;Rename&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Directories&lt;/h2&gt;
&lt;p&gt;Forms of directory system:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Single-Level Directory Systems&lt;/li&gt;
&lt;li&gt;Hierarchical Directory Systems&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Path names&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Absolute path name&lt;/strong&gt;: Consists the path from the root directory to the file.&lt;br&gt;&lt;strong&gt;Relative path name&lt;/strong&gt;: This is used in conjunction with the concept of the &lt;em&gt;working deirectory&lt;/em&gt;(&lt;em&gt;current directory&lt;/em&gt;)&lt;/p&gt;
&lt;h3&gt;Directory operations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Create&lt;/li&gt;
&lt;li&gt;Delete&lt;/li&gt;
&lt;li&gt;Opendir&lt;/li&gt;
&lt;li&gt;Closedir&lt;/li&gt;
&lt;li&gt;Readdir&lt;/li&gt;
&lt;li&gt;Rename&lt;/li&gt;
&lt;li&gt;Link&lt;/li&gt;
&lt;li&gt;Unlink&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;File system implementation&lt;/h2&gt;
&lt;h3&gt;File System Layout&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MBR(Master Boot Record)&lt;/strong&gt; is the first sector(sector 0) of the disk, which contains the partition table(one is marked as active). &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Superblock&lt;/strong&gt; is contained by every partition, which lays after the boot block and contains all the key parameters about the filesystem.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MBR is loaded and executed by BIOS. The MBR program locate the active prtition, read in its first block(&lt;strong&gt;boot block&lt;/strong&gt;), and execute it. The the program in the boot block load the OS contained in that partition.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/4-9.png&quot; alt=&quot;file system layout&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Implementing Files&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Contiguous Allocation&lt;/li&gt;
&lt;li&gt;Linked List Allocation&lt;/li&gt;
&lt;li&gt;Linked List Allocation Using a Table(File Allocation Table) in Memory&lt;/li&gt;
&lt;li&gt;I-nodes&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Implementing Directories&lt;/h3&gt;
&lt;p&gt;Longer, variable-length file names supporting. There are 3 implementations below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Set a limit on file name length.&lt;/li&gt;
&lt;li&gt;Each entry contains a fixed portion, followed by the actual file name.&lt;/li&gt;
&lt;li&gt;Make the directory entries all fixed length and keep the file names together in a heap at the end of the directory.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Shared Files&lt;/h3&gt;
&lt;p&gt;2 solutions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Disk blocks are not listed in directories, but in a little data structure associated with the file itself.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Symbolic linking&lt;/strong&gt; The new link file just contains the path of the file to which it is linked.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Log-Structured File Systems&lt;/h3&gt;
&lt;p&gt;All pending writes are bufferd in memory, and collected into a single segment and written to the disk as a single contiguous segment at the end of the log.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An i-node map is maintained to make it possible to find i-nodes.&lt;br&gt;LFS has a cleaner thread that spends its time scanning the log circularly to compact it. (Removing overwitten blocks)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Journaling File System&lt;/h3&gt;
&lt;p&gt;Keeps a log of what the file system is going to do before it does it, so that if the system crashes before it can do its planned work, upon rebooting the system can look in the log to see what was going on at hte time of the crash and finish the job.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Only after the log entry has been written, do the various operations begin. After the operations complete successfully, the log entry is erased.&lt;br&gt;The logged operations must be &lt;strong&gt;idempotent&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Virtual File System&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;VFS&lt;/strong&gt; tries to integrate multiple file systems into an orderly structure.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In fact, the origina motivation for Sun to build the VFS was to support remote file systems using the &lt;strong&gt;NFS(Network File System)&lt;/strong&gt; protocol.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;File System Management and Optimization&lt;/h2&gt;
&lt;h3&gt;Disk Space Management&lt;/h3&gt;
&lt;h4&gt;Block Size&lt;/h4&gt;
&lt;p&gt;If the allocatoin unit is too large, we waste space; if it&amp;#39;s too small, we waste time.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The disk operation time is the sum of the seek, rotational delay, and transfer time. While the first 2 of them dominated the access time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Keeping Track of Free Blocks&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Linked list.&lt;/li&gt;
&lt;li&gt;bitmap.&lt;/li&gt;
&lt;li&gt;Keep track of runs of blocks(rather than single blocks).&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;File System Backups&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Incremental dump&lt;/li&gt;
&lt;li&gt;physical dump&lt;/li&gt;
&lt;li&gt;logical dump&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;File System Consistency&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Block consistency. Count how many times each block is present in a file; how often each block is present in the free list.&lt;/li&gt;
&lt;li&gt;File consistency. Count for that file&amp;#39;s usage count(hard links, directories).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;File System Performance&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Caching. Hash the device and disk address and look up the result in a hash table.&lt;/li&gt;
&lt;li&gt;Block Read Ahead. Only works for files that are being read sequentially.&lt;/li&gt;
&lt;li&gt;Reducing Disk Arm Motion. I-node allocation.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Input/Output&lt;/h1&gt;
&lt;h2&gt;Principles of I/O Hardware&lt;/h2&gt;
&lt;h3&gt;Devices &amp;amp; Controllers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;block devices&lt;/strong&gt; stores information in fixed-size blocks, each one with its own address.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;character devices&lt;/strong&gt; delivers or accepts a stream of characters, without regard to any block structure.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;device controller/adapter&lt;/strong&gt; takes the form of a chip on the parentboard or a printed circuit card that can be inserted into a (PCI) expansion slot.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Memory-Mapped I/O&lt;/h3&gt;
&lt;p&gt;Each control register is assigned a unique memory address to which no memory is assigned.&lt;/p&gt;
&lt;p&gt;Pros:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if special I/O instructions are needed to read/write the device control registers, access to them requires nothing more than standard C code, otherwise needs the use of addembly code.&lt;/li&gt;
&lt;li&gt;with memory-mapped I/O, no special protection mechanism is needed to keep user processes from performing I/O.&lt;/li&gt;
&lt;li&gt;With memory-mapped I/O, every instruction that can reference memory can also reference control registers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;most computers nowadays have some form of caching of memory words. Caching a device control register would be disastrous.&lt;/li&gt;
&lt;li&gt;If there is only one address space, then all memory modules and all I/O devices must examine all memory references to see which ones to respond to.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Direct Memory Access(DMA)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Direct memory access (DMA)&lt;/strong&gt; is a feature of modern computers that allows certain hardware subsystems within the computer to access system memory independently of the CPU.&lt;/p&gt;
&lt;p&gt;Bus mode thus DMA controller mode:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cycle stealing&lt;/strong&gt; the device controller sneaks in and steals an occasional bus cycle from the CPU once in a while(when CPU doesn&amp;#39;t want the bus).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;burst mode&lt;/strong&gt; the DMA controller tells the device to acquire the bus, issue a series of transfers, then release the bus.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Interrupts Revisited&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;interrupt vector&lt;/strong&gt; is used to save program counters for a table of the corresponding interrupt service procedure.&lt;/li&gt;
&lt;li&gt;Most CPUs save the context on the stack when interrupt happens.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Precise interrupt&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The PC is saved in a known place.&lt;/li&gt;
&lt;li&gt;All instructions before the one pointed to by the PC have fully executed.&lt;/li&gt;
&lt;li&gt;No instruction beyond the one pointed to by the PC has been executed.&lt;/li&gt;
&lt;li&gt;The execution state of the instruction pointed to by the PC is known.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;An interrupt doesn&amp;#39;t meet these requirements is called an &lt;strong&gt;imprecise interrupt&lt;/strong&gt;.&lt;/p&gt;
&lt;h2&gt;Principles of I/O Software&lt;/h2&gt;
&lt;h3&gt;Goals of I/O Software&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Device independece&lt;/strong&gt; programs can access any I/O device without having to specify the device in advance.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;uniform naming&lt;/strong&gt; thus a path name in UNIX systems.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;error handling&lt;/strong&gt; try to correct the error or told upper layers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;synchronous&lt;/strong&gt; or &lt;strong&gt;asynchronous&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buffering&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;I/O Software Layers&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;User-level I/O software&lt;/li&gt;
&lt;li&gt;Device-independent operating system software&lt;/li&gt;
&lt;li&gt;Device drivers&lt;/li&gt;
&lt;li&gt;Interrupt handlers&lt;/li&gt;
&lt;li&gt;Hardware&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Device-Independent I/O Softwares&lt;/h3&gt;
&lt;h4&gt;Uniform Interfacing for Device Drivers&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The interface between the device drivers and the rest of the operating system.&lt;/li&gt;
&lt;li&gt;How I/O devices are named.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;in Unix a device name such as &lt;code&gt;/dev/disk0/&lt;/code&gt;, uniquely specifies the i-node for a special file. This i-node contains &lt;strong&gt;major device number&lt;/strong&gt; to locate the appropriate driver, and the &lt;strong&gt;minor device number&lt;/strong&gt; which is passed as a parameter to the driver and specifies the read/write unit.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Buffering&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;double buffering&lt;/strong&gt; is used to store another buffer when the first buffer is being brought out and characters are keeping arriving.&lt;br&gt;&lt;strong&gt;circular buffer&lt;/strong&gt; is another widely used form of buffering.&lt;/p&gt;
&lt;h1&gt;Deadlocks&lt;/h1&gt;
&lt;h2&gt;Resources&lt;/h2&gt;
&lt;p&gt;A &lt;strong&gt;preemptable resource&lt;/strong&gt; is one that can be taken away from the process owning it with no ill effects.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;nonpreemptable resource&lt;/strong&gt; is one that cannot be taken away from its current owner without causing the computation to fail.&lt;/p&gt;
&lt;p&gt;Resource Acquisition&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Request the resource.&lt;/li&gt;
&lt;li&gt;Use the resource.&lt;/li&gt;
&lt;li&gt;Release the resource.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;A possible implementation:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;down&lt;/code&gt; on the semaphore to aquire the resource.&lt;/li&gt;
&lt;li&gt;using the resource.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;up&lt;/code&gt; on the semaphore to release the resource.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Introduction to Deadlocks&lt;/h2&gt;
&lt;p&gt;A set of processes is &lt;strong&gt;deadlocked&lt;/strong&gt; if each process in the set is waiting for an event that only another process in the set can cause.&lt;/p&gt;
&lt;p&gt;Conditions for Resource Deadlocks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mutual exclusion condition.&lt;/li&gt;
&lt;li&gt;Hold and wait condition.&lt;/li&gt;
&lt;li&gt;No preemption condition.&lt;/li&gt;
&lt;li&gt;Circular wait condition.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Strategies used for dealing with deadlocks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Just ignore the problem.&lt;/li&gt;
&lt;li&gt;Detection and recovery.&lt;/li&gt;
&lt;li&gt;Dynamic avoidance by careful resource allocation.&lt;/li&gt;
&lt;li&gt;Prevention, by structurally negating one of the four required conditions.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;The Ostrich Algorithm&lt;/h2&gt;
&lt;p&gt;Just ignore the problem when the deadlock isn&amp;#39;t that often, that serious.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Few current systems will detect the deadlock between CD-ROM and printer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Deadlock Detection and Recovery&lt;/h2&gt;
&lt;h3&gt;Deadlock Detection with One Resource of Each Type&lt;/h3&gt;
&lt;p&gt;For such a system, we can construct a resource graph of the resources and processes. If this graph contains cycles, a deadlock exists.&lt;/p&gt;
&lt;h3&gt;Deadlock Detection with Multiple Resources of Each Type&lt;/h3&gt;
&lt;p&gt;E is the &lt;strong&gt;existing resource vector&lt;/strong&gt;, which gives the total nmber of instances of each resource in existence.&lt;/p&gt;
&lt;p&gt;A is the &lt;strong&gt;available resource vector&lt;/strong&gt;, which gives the number of instances of resource that are currently available.&lt;/p&gt;
&lt;p&gt;C is the &lt;strong&gt;current allocation matrix&lt;/strong&gt;, the i-th row of C tells how many instances of each resource class &lt;span class=&quot;mathjax&quot;&gt;\(P_i\)&lt;/span&gt; currently holds.&lt;/p&gt;
&lt;p&gt;R is the &lt;strong&gt;request matrix&lt;/strong&gt;, holds the number of instances of resource that processes want.&lt;/p&gt;
&lt;p&gt;The following algorithm will mark all processes that are not deadlocked.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Look for an unmarked process, &lt;span class=&quot;mathjax&quot;&gt;\(P_i\)&lt;/span&gt;, for which the i-th wor of R is less than or equal than A.&lt;/li&gt;
&lt;li&gt;If such a process is found, add the i-th row of C to A, mark the process, and go back to step 1.&lt;/li&gt;
&lt;li&gt;If no such process exists, the algorithm terminates.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Recovery from Deadlock&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Recovery from Preemption&lt;/li&gt;
&lt;li&gt;Recovery through Rollback, which requires processes periodically &lt;strong&gt;checkpointed&lt;/strong&gt;(memory image and resource state).&lt;/li&gt;
&lt;li&gt;Recovery through Killing Processes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Deadlock Avoidance&lt;/h2&gt;
&lt;h3&gt;Resource Trajectories&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/6-8.gif&quot; alt=&quot;trajectories&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Safe and Unsafe States&lt;/h3&gt;
&lt;p&gt;A state is said to be &lt;strong&gt;safe&lt;/strong&gt; if there is some scheduling order in which every process can run to completion even if all of them suddenly request their maximum number of resources immediately.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It worth nothing that an unsafe state is not a deadlocked state. The system can run for a while and one process can even complete. The difference between a safe state and an unsafe state is that from a safe state the system can &lt;strong&gt;guarantee&lt;/strong&gt; that all processes will finish; from an unsafe state, no such guarantee can be given.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;The Banker&amp;#39;s Algorithm for a Single Resource&lt;/h3&gt;
&lt;p&gt;This Algorithm considers each request as it occurs, and sees if granting it leads to a safe state. If it does, the request is granted; otherwise, it is postponed until later.&lt;/p&gt;
&lt;h3&gt;The Banker&amp;#39;s Algorithm for Multiple Resources&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Look for a row, R, whose unmet resource needs are all smaller than or equal to A. If no such row exists, the system will eventually deadlock since no process can run to completion.&lt;/li&gt;
&lt;li&gt;Assume the process of the row chosen requests all the resources it needs and finishes. Mark that process as terminated and add all its resources to the A vector.&lt;/li&gt;
&lt;li&gt;Repeat steps 1 and 2 until either all processes are marked terminated or no process is left whose resource needs can be met.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Deadlock Prevention&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Condition&lt;/th&gt;
&lt;th&gt;Approach&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mutual exclusion&lt;/td&gt;
&lt;td&gt;Spool everything&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Hold and wait&lt;/td&gt;
&lt;td&gt;Request all resources initially&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;No preemption&lt;/td&gt;
&lt;td&gt;Take resources away&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Circular wait&lt;/td&gt;
&lt;td&gt;Order resources numerically&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Other Issues&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;two-phase locking&lt;/strong&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;In the first phase, the process tries to lock all the records it needs, one at a time. &lt;/li&gt;
&lt;li&gt;If it succeds, it begins the second phase, performing its updates and releasing the locks.&lt;/li&gt;
&lt;li&gt;If during the first phase, some record is already locked, the process just release all its locks and starts the first phase all over.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;conmunication deadlocks&lt;/strong&gt;, unlike resource deadlocks, these are caused by communication errors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;livelock&lt;/strong&gt;, polling(busy waiting) processes uses up its CPU quantum without making progress but also without blocking.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Starvation&lt;/strong&gt;, some policy is needed to make a decision about who gets which resource when. This policy may lead to some processes never getting service even though they are not deadlocked.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Starvation can be avoided by using a first-come, first-served, resource allocation policy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Case Study: Linux&lt;/h1&gt;
&lt;h2&gt;History of Unix and Linux&lt;/h2&gt;
&lt;h3&gt;MULTICS &amp;amp; UNICS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Researchers at M.I.T. joined forces with Bell Labs and Generic Electric and began designing a second-generation system, &lt;strong&gt;MULTICS(Multiplexed Information and Computing Service)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;One of the Bell Labs researchers, Ken Thompson wrote a stripped-down MULTICS on a PDP-7 minicomputer. The system is called &lt;strong&gt;UNICS(UNiplexed Information and Computing Service)&lt;/strong&gt; jokingly by Brian Kernighan, Bell Labs.&lt;/li&gt;
&lt;li&gt;Thompson tied to rewite UNIX with B language of his own design and failed. Ritchie then designed a successor to B, called C. Working together, they rewrote UNIX in C.&lt;/li&gt;
&lt;li&gt;Steve Johnson of Bell Labs designed and implemented the &lt;strong&gt;portable C compiler&lt;/strong&gt;, which could be retargeted to produce code for any resonable machine with a only a moderate amount of effort.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Standard UNIX&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AT&amp;amp;T released its first commercial UNIX: System III, then System V.&lt;/li&gt;
&lt;li&gt;Aided by U.S. Dept. of Defense, Berkeley released an improved PDP-11 called &lt;strong&gt;1BSD(First Berkeley Software Distribution)&lt;/strong&gt;, which supported virtual memory, TCP/IP, vi, csh, etc.&lt;/li&gt;
&lt;li&gt;IEEE came up with &lt;strong&gt;POSIX(Portable Operating System of UNIXish)&lt;/strong&gt;, witch reconcile the two flavors of UNIX.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;MINIX &amp;amp; Linux&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Tanenbaum wrote a Unix-like MINIX based on a microkernel design.&lt;/li&gt;
&lt;li&gt;In 1991, Linus Torvalds wrote another UNIX, named &lt;strong&gt;Linux&lt;/strong&gt;, according to MINIX.&lt;/li&gt;
&lt;li&gt;Linux comes with GPL Lisence devised by Richard Stallman. GNOME, KDE were written for Linux.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Linux Goals&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Be simple, elegant, and consistent. (Wildcards, cmd abbrs, etc.)&lt;/li&gt;
&lt;li&gt;Power and flexibility. (every program just do one thing and do it well)&lt;/li&gt;
&lt;li&gt;No redundancy.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Processes in Linux&lt;/h2&gt;
&lt;h3&gt;Concepts&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;One &lt;strong&gt;PID(Process Identifier)&lt;/strong&gt; per process, and one &lt;strong&gt;TID(Task Identifier)&lt;/strong&gt; per thread.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Child process&lt;/strong&gt; and &lt;strong&gt;parent process&lt;/strong&gt; have their own memory images respectively, and share open files.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pipes&lt;/strong&gt;(which can be filled and then process blocked) and &lt;strong&gt;signal&lt;/strong&gt;(&lt;code&gt;kill&lt;/code&gt; cmd, for example) are used for inter-process communication.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;System Calls&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt; will create an exact duplicate of the original process(file descriptors, registers, and everything else), and applys the copy on write mechanism.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec&lt;/code&gt; will cause its entire core image to be replaced by the file named in its 1st parameter.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait&lt;/code&gt; is used to collect information and clean the zombie process left by the terminated child process.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pause&lt;/code&gt; tells Linux to suspend the process until signal arrives.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Thread&lt;/h3&gt;
&lt;p&gt;Kernel thread is supported by Linux using &lt;code&gt;clone&lt;/code&gt; system call.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When a thread was created, the original thread and the new one shared everything but their registers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3 classes of threads for scheduling purposes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Real-time FIFO.&lt;/li&gt;
&lt;li&gt;Real-time round robin.&lt;/li&gt;
&lt;li&gt;Timesharing.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Booting&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;BIOS performs initial device discovery and initialization.&lt;/li&gt;
&lt;li&gt;MBR is read into a fixed location and executed, which loads a standalone &lt;strong&gt;boot&lt;/strong&gt; program like &lt;strong&gt;GRUB(GRand Unified Bootloader)&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boot&lt;/code&gt; reads in the OS kernel and jumps to it.&lt;/li&gt;
&lt;li&gt;Process 0 checks devices, program the clock, mount the root FS, and create &lt;code&gt;init&lt;/code&gt;(process 1), and page daemon(process 2).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt; execs &lt;code&gt;/etc/rc/*&lt;/code&gt;, finally opens tty and print &lt;code&gt;login:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Memory Management in Linux&lt;/h2&gt;
&lt;h3&gt;Concepts&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;text segement&lt;/strong&gt; lays in the lowest in virtual address space. It&amp;#39;s readonly thus can be shared physically.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;data segement&lt;/strong&gt; lays upside of text segment and contains 2 parts: initialized data and uninitialized data(called &lt;strong&gt;BSS(block Started by Symbol)&lt;/strong&gt;, which can grow and shrink by system call &lt;code&gt;brk&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stacks&lt;/strong&gt; starts at the top limit of virtual address. For a 32bit x86 platform, it would be 0xC0000000.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memory-mapped files&lt;/strong&gt; are often used for shared libraries.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Text segment is read-only. Self-modifying programs went out of style in 1950s because they they were too difficult to understand and debug.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The existence of uninitialized data is actually just an optimization to make binary programs smaller.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Implementation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Each linux process on a 32-bit machine typically gets 3GB of virtual address space for itself, with the remaining 1GB reserved for its page tables and other kerel data.&lt;/li&gt;
&lt;li&gt;The 1GB kernel memory typically resides in low physical memory but it&amp;#39;s mapped in the top of each process virtual address space.&lt;/li&gt;
&lt;li&gt;Linux uses 4-level paging scheme&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;buddy algorithm&lt;/strong&gt; and &lt;strong&gt;slab allocator&lt;/strong&gt; is used for memeory allocation for normal objects and kernel caches respectively.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Input/Output in Linux&lt;/h2&gt;
&lt;p&gt;File systems under the VFS includes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Regular file(with I/O scheduler and Block device driver)&lt;/li&gt;
&lt;li&gt;Block special file(with I/O scheduler and Block device driver)&lt;/li&gt;
&lt;li&gt;Char special file(with Optional line discipline and Char device driver)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Network socket(with Protocol drivers and Network device driver)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I/O Scheduler is used to reorder or bundle r/w requests to block devices.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Line disciplines are used to render the local line editing before submit by Carriage Return.&lt;/li&gt;
&lt;li&gt;Linux treat drivers as &lt;strong&gt;loadable modules&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Linux File System&lt;/h2&gt;
&lt;h3&gt;Concepts&lt;/h3&gt;
&lt;p&gt;History of Linux FS:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The initial FS is MINIX 1 FS.&lt;/li&gt;
&lt;li&gt;ext FS allowed 255 chars of filename and 2GB filesize, but slower.&lt;/li&gt;
&lt;li&gt;ext2 allowed long filename, larger filesize, and provided better performance.&lt;/li&gt;
&lt;li&gt;ext3 is a follow-on of ext2 with journaling.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Linux allows directory and file locking(byte range) with semaphore, including &lt;strong&gt;shared locks&lt;/strong&gt; and &lt;strong&gt;exclusive locks&lt;/strong&gt;.&lt;/p&gt;
&lt;h3&gt;Implementation&lt;/h3&gt;
&lt;p&gt;4 main structures of VFS:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;superblock&lt;/strong&gt; contains critical information about the layout of the file system.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;i-nodes&lt;/strong&gt; each describe exactly one file.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dentry&lt;/strong&gt; represents a directory entry.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;file&lt;/strong&gt; is an in-memory representation of an open file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/10-31.bmp&quot; alt=&quot;ext2 layout&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;With 1kb block, this design limits a block group to 8192 blocks(in practice) and 8192 inodes(not real restriction).&lt;/li&gt;
&lt;li&gt;Ext2 attempts to collocate ordinary files in the same block group as the parent directory, and data files in the same block as the original file i-node.&lt;/li&gt;
&lt;li&gt;Ext2 also preallocates a number(8) of additional blocks for that file to minimize the file fragmentation due to future write operations.&lt;/li&gt;
&lt;li&gt;inode contains addresses of first 12 disk blocks, single indirect, double indirect, and triple indirect when needed.&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Wed, 10 Sep 2014 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/%E8%AF%BB%E4%B9%A6/modern-os.html</link>
				<guid isPermaLink="true">http://harttle.github.io/%E8%AF%BB%E4%B9%A6/modern-os.html</guid>
			</item>
		
			<item>
				<title>Makefile 手册</title>
				<description>&lt;p&gt;在软件开发中，make是一个工具程序（Utility software），经由读取叫做“makefile”的文件，自动化建构软件。&lt;/p&gt;
&lt;p&gt;它是一种转化文件形式的工具，转换的目标称为“target”；与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。它的依赖关系检查系统非常简单，主要根据依赖文件的修改时间进行判断。大多数情况下，它被用来编译源代码，生成结果代码，然后把结果代码连接起来生成可执行文件或者库文件。它使用叫做“makefile”的文件来确定一个target文件的依赖关系，然后把生成这个target的相关命令传给shell去执行。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://scc.qibebt.cas.cn/docs/linux/base/%B8%FA%CE%D2%D2%BB%C6%F0%D0%B4Makefile-%B3%C2%F0%A9.pdf&quot;&gt;中文Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;


&lt;h1&gt;基本知识&lt;/h1&gt;
&lt;h2&gt;编译&lt;/h2&gt;
&lt;p&gt;对于C语言，产生可执行程序包括这样的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;预处理源文件（&lt;code&gt;.c&lt;/code&gt;）&lt;ul&gt;
&lt;li&gt;替换预处理命令（如 &lt;code&gt;#define&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;展开头文件（&lt;code&gt;.h&lt;/code&gt;，包括静态链接库的头文件）到引用的源文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;依次编译处理过的源文件，然后进行汇编，生成对应的目标文件（&lt;code&gt;.o&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;链接（静态链接）目标文件和静态链接库（静态链接库的源文件生成的目标文件，&lt;code&gt;.a&lt;/code&gt;），生成可执行的二进制文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;gcc&lt;/code&gt; 不会自动链接到静态链接库（&lt;code&gt;libstdio.so&lt;/code&gt;除外），需要以参数的形式指定。&lt;code&gt;g++&lt;/code&gt; 会自动解析并进行链接。动态链接库（&lt;code&gt;.so&lt;/code&gt;）则是运行时由操作系统解析的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;示例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;target: require1 require2
    shell command&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 命令会寻找当前目录下的 makefile，寻找其中的第一条规则，然后执行 &lt;code&gt;shell command&lt;/code&gt; 来生成 &lt;code&gt;target&lt;/code&gt;。如果发现 &lt;code&gt;requireN&lt;/code&gt; 同时也依赖于其他项，则会自动调用其对应的 &lt;code&gt;shell command&lt;/code&gt; 并生成它。另外，在整个过程中，&lt;code&gt;make&lt;/code&gt; 会比较 &lt;code&gt;target&lt;/code&gt; 与 &lt;code&gt;requireN&lt;/code&gt; 的时间戳，以判断是否需要重新生成。&lt;/p&gt;
&lt;h2&gt;变量&lt;/h2&gt;
&lt;p&gt;变量的定义与引用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# 递归扩展变量，在调用时展开&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;objects1&lt;/span&gt; = a.o b.o

&lt;span class=&quot;hljs-comment&quot;&gt;# 简单扩展变量，在赋值时展开&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;objects2&lt;/span&gt; = &lt;span class=&quot;hljs-variable&quot;&gt;$(objects)&lt;/span&gt; c.o

main.o: $(objects)
    gcc -o main.o $(objects2)&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果要在makefile中真实的 &lt;code&gt;$&lt;/code&gt;，需要用 &lt;code&gt;$$&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意变量赋值时不能使用通配符。但是在规则中，通配符是可以使用的：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  print: *.c
      some command&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自动化变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt;&lt;br&gt;  表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，&lt;code&gt;$@&lt;/code&gt;就是匹配于目标中模式定义的集合。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$%&lt;/code&gt;&lt;br&gt;  仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是&lt;code&gt;foo.a (bar.o)&lt;/code&gt;，那么，&lt;code&gt;$%&lt;/code&gt;就是&lt;code&gt;bar.o&lt;/code&gt;，&lt;code&gt;$@&lt;/code&gt;就是&lt;code&gt;foo.a&lt;/code&gt;。如果目标不是函数库文件（Unix 下是&lt;code&gt;.a&lt;/code&gt;，Windows 下是&lt;code&gt;.lib&lt;/code&gt;），那么，其值为空。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt;&lt;br&gt;  依赖目标中的第一个目标名字。如果依赖目标是以模式（即&lt;code&gt;%&lt;/code&gt;）定义的，那么&lt;code&gt;$&amp;lt;&lt;/code&gt;将 是符合模式的一系列的文件集。注意，其是一个一个取出来的。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt;&lt;br&gt;  所有比目标新的依赖目标的集合。以空格分隔。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$^&lt;/code&gt;&lt;br&gt;  所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量 会去除重复的依赖目标，只保留一份。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$+&lt;/code&gt;&lt;br&gt;  这个变量很像&amp;quot;$^&amp;quot;，也是所有依赖目标的集合。只是它不去除重复的依赖目标。 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt;&lt;br&gt;  这个变量表示目标模式中&lt;code&gt;%&lt;/code&gt;及其之前的部分。如果目标是&lt;code&gt;dir/a.foo.b&lt;/code&gt;，并且目标的模式是&lt;code&gt;a.%.b&lt;/code&gt;，那么，&lt;code&gt;$*&lt;/code&gt;的值就是&lt;code&gt;dir/a.foo&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;隐含规则&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 会通过隐含规则自动推导依赖关系，可以帮助我们简化 &lt;code&gt;makefile&lt;/code&gt;。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;foo : foo.o bar.o 
    cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并没有指明如何生成 &lt;code&gt;.o&lt;/code&gt; 文件，这时 &lt;code&gt;make&lt;/code&gt; 会生成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;foo.o : foo.c 
    cc –c foo.c $(CFLAGS) 

bar.o : bar.c 
    cc –c bar.c $(CFLAGS)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;隐含规则中的编译器与上一级依赖中的相同，因此产生 &lt;code&gt;foo&lt;/code&gt; 的规则中，&lt;code&gt;cc&lt;/code&gt; 命令是不可省略的。&lt;/p&gt;
&lt;h2&gt;使用函数&lt;/h2&gt;
&lt;p&gt;可以使用 &lt;code&gt;make&lt;/code&gt; 内建函数来完成某些功能。语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;$(&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-constant&quot;&gt;sources&lt;/span&gt; := &lt;span class=&quot;hljs-variable&quot;&gt;$(shell ls *.c)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 中的函数包括：字符串处理，文件名操作，流程控制，call函数，origin函数，shell函数。&lt;/p&gt;
&lt;h1&gt;进阶技巧&lt;/h1&gt;
&lt;h2&gt;伪目标&lt;/h2&gt;
&lt;p&gt;伪目标不是一个文件，而只是一个标签，使得依赖关系的书写更加灵活。&lt;code&gt;.PHONY&lt;/code&gt; 用来声明伪目标（但不是必须的），这时可以避免 make 去检查同名的文件。例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-phony&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;.PHONY&lt;/span&gt;: clean &lt;/span&gt;

&lt;span class=&quot;hljs-title&quot;&gt;clean: &lt;/span&gt;
    rm *.o temp&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;多目标&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;bigoutput littleoutput : text.g 
    generate text.g -$(subst output,,$@) &amp;gt; $@

&lt;span class=&quot;hljs-comment&quot;&gt;# 等价于：&lt;/span&gt;

bigoutput : text.g 
    generate text.g -big &amp;gt; bigoutput 
littleoutput : text.g 
    generate text.g -little &amp;gt; littleoutput&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;静态模式&lt;/h2&gt;
&lt;p&gt;静态模式可以更加容易地定义多目标的规则，语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&amp;lt;targets ...&amp;gt;: &amp;lt;target-pattern&amp;gt;: &amp;lt;prereq-patterns ...&amp;gt; 
    &amp;lt;commands&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如，下面的makefile将对所有的 &lt;code&gt;.o&lt;/code&gt; 文件分别生成一条依赖关系。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-constant&quot;&gt;objects&lt;/span&gt; = foo.o bar.o 

all: $(objects) 
$(objects): %.o: %.c 
    $(CC) -c $(CFLAGS) $&amp;lt; -o $@&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;总控 makefile&lt;/h2&gt;
&lt;p&gt;在makefile中，可以执行子文件夹的makefile：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;subsystem: &lt;/span&gt;
    $(MAKE) -C subdir&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的&lt;code&gt;$(MAKE)&lt;/code&gt;是为了方便维护make的参数。总控makefile的变量可以传递到下级：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;export variable = value

&lt;span class=&quot;hljs-comment&quot;&gt;# or use the following&lt;/span&gt;
&lt;span class=&quot;hljs-constant&quot;&gt;variable&lt;/span&gt; = value 
export variable&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;自动生成依赖&lt;/h2&gt;
&lt;p&gt;对于每个 &lt;code&gt;.c&lt;/code&gt; 文件，我们一般会需要如下的依赖关系：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;main.o : main.c defs.h&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然而，有时候存在大量的 &lt;code&gt;.c&lt;/code&gt; 文件，我们需要得到每个 &lt;code&gt;.c&lt;/code&gt; 对应的 &lt;code&gt;.h&lt;/code&gt;。借助于 &lt;code&gt;gcc&lt;/code&gt;，可以自动探测这些依赖：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-constant&quot;&gt;sources&lt;/span&gt; = main.c stack.c maze.c

-include $(sources:.c=.d)

%.d: %.c
    @set -e; rm -f $@; \
    $(CC) -MM $(CPPFLAGS) $&amp;lt; &amp;gt; $@.$$$$; \
    sed &#39;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#39; &amp;lt; $@.$$$$ &amp;gt; $@; \
    rm -f $@.$$$$&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上的makefile定义了 &lt;code&gt;.c&lt;/code&gt; 的列表变量，然后载入对应的 &lt;code&gt;.d&lt;/code&gt; 文件，这时会有文件不存在的警告产生，此时 make 会采用下面的模式生成 &lt;code&gt;.d&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置shell，发生错误立即退出&lt;/li&gt;
&lt;li&gt;得到依赖关系（如 &lt;code&gt;main.o main.c defs.h&lt;/code&gt;），存为 &lt;code&gt;.d.XXXX&lt;/code&gt;（&lt;code&gt;XXXX&lt;/code&gt;为当前进程号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed&lt;/code&gt; 替换（例如将 &lt;code&gt;main.o : main.c defs.h&lt;/code&gt; 转成 &lt;code&gt;main.o main.d : main.c defs.h&lt;/code&gt;），使得 &lt;code&gt;.d&lt;/code&gt; 也能得到更新。&lt;/li&gt;
&lt;li&gt;删除临时文件&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Wed, 01 Jan 2014 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/linux/makefile.html</link>
				<guid isPermaLink="true">http://harttle.github.io/linux/makefile.html</guid>
			</item>
		
			<item>
				<title>Computer Organization and Design</title>
				<description>&lt;h1&gt;Abstractions&lt;/h1&gt;
&lt;h2&gt;Concepts&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Moore&amp;#39;s law&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Over the history of computing hardware, the number of transistors on integrated circuits doubles approximately every two years.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Compiler&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A program that translates high-level language statements into assembly language statements.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Assembler&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A program that translates a symbolic version of instructions into the binary version.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;High-level programming langrage&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A portable language that is composed of words and algebraic notation that can be translated by a compiler into assembly language.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Assembly language&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Asymbolic representation of machine instructions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Machine language&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A binary representation of machine instructions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;5 components of a computer&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Input&lt;/li&gt;
&lt;li&gt;Output&lt;/li&gt;
&lt;li&gt;Memory&lt;/li&gt;
&lt;li&gt;Datapath&lt;/li&gt;
&lt;li&gt;Control&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;The last two sometimes combined and called the processor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Instruction set architecture&lt;/strong&gt;&lt;br&gt;One key interface between the levels of abstraction is the instruction set architecture-the interface between the hardware and low-level software.&lt;/p&gt;
&lt;!--more--&gt;

&lt;h2&gt;Performance&lt;/h2&gt;
&lt;h3&gt;Measurement and Limitation&lt;/h3&gt;
&lt;div class=&quot;mathjax&quot;&gt;\[\begin{eqnarray}
CPU~time &amp;=&amp; IC \times CPI \times Clock~cycle~time\\\\
        &amp;=&amp; \frac{IC \times CPI}{Clock~rate}
\end{eqnarray}\]&lt;/div&gt;&lt;div class=&quot;mathjax&quot;&gt;\[Power = Capacitive \times Voltage^2 \times Frequency\]&lt;/div&gt;&lt;h2&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Pitfall&lt;/strong&gt;: Expecting the improvement of one aspect of a computer to increse overall performance by an amount proportional to the size of the improvement.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Amdahl&amp;#39;s law&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;mathjax&quot;&gt;\[ET~after~improvement = \\\\
\frac{ET~affected}{Amount~of~improvement} + ET~unaffected\]&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Pitfall&lt;/strong&gt;: Using a subset of the performance equation as a performance metric.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&quot;mathjax&quot;&gt;\[\begin{eqnarray}
MIPS &amp;=&amp; \frac{IC}{ET \times 10^6} \\\\
    &amp;=&amp; \frac{Clock~rate}{CPI \times 10^6}
\end{eqnarray}\]&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Instruction per program is not considered.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Execution time is the only valid and unimpeachable measure of performance.&lt;/p&gt;
&lt;h1&gt;Instructions&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Common goal of computer designers: to find a language that makes it easy to build the hardware and the compiler while maximizing performance and minimizing cost and power.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Stored-program concept&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;The idea that instructions and data of many types can be stored in memory as numbers, leading to the stored-program computer.&lt;/p&gt;
&lt;h2&gt;Design Principle&lt;/h2&gt;
&lt;p&gt;Each category of MIPS instructions is associates with constructs that appear in programming language:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The arithmetic: assignment statements.&lt;/li&gt;
&lt;li&gt;Data transfer: dealing with data structures like arrays or structures.&lt;/li&gt;
&lt;li&gt;Conditional branches: &lt;em&gt;if&lt;/em&gt; statement.&lt;/li&gt;
&lt;li&gt;Unconditional jumps: procedure call and returns and &lt;em&gt;for&lt;/em&gt;, &lt;em&gt;case/switch&lt;/em&gt; statements.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Simplicity favors regularity&lt;/p&gt;
&lt;p&gt; Requiring every instruction to have exactly three operands, no more and no less, conforms to the philosophy of keeping the hardware simple.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Smaller is faster&lt;/p&gt;
&lt;p&gt; Number of registers is limited in 32. A large number of registerss may increse the clock cycle time simply because it takes electronic signals longer when they must travel farther.&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Big-endian and Small-endian&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; Big-endian: computers use the address of the leftmost byte ( or &amp;quot;big end&amp;quot; ) as the word address.&lt;br&gt; Small-endian: otherwise.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MIPS is in the big-endian camp.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Make the common case fast&lt;/p&gt;
&lt;p&gt; Avoid the load instruction when arithmetic instruction&amp;#39;s one operand is a constant.&lt;/p&gt;
&lt;p&gt; Example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; addi    &lt;span class=&quot;hljs-variable&quot;&gt;$s3&lt;/span&gt;,    &lt;span class=&quot;hljs-variable&quot;&gt;$s3&lt;/span&gt;,    &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;

 &lt;span class=&quot;hljs-comment&quot;&gt;# instead of&lt;/span&gt;
 lw      &lt;span class=&quot;hljs-variable&quot;&gt;$t0&lt;/span&gt;,    AddrConst4(&lt;span class=&quot;hljs-variable&quot;&gt;$s1&lt;/span&gt;)
 add     &lt;span class=&quot;hljs-variable&quot;&gt;$s3&lt;/span&gt;,    &lt;span class=&quot;hljs-variable&quot;&gt;$s3&lt;/span&gt;,    &lt;span class=&quot;hljs-variable&quot;&gt;$t0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;strong&gt;One&amp;#39;s complement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; A notation that represents the most negative value by 10...000 and the most positive value by 01...11, leaving an equal number of negatives and positives but ending up with two 0s. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The term is also used to mean the inversion of every bit.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;strong&gt;two&amp;#39;s complement&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;mathjax&quot;&gt;\(-x = \bar{x}+1\)&lt;/span&gt;, leading 0s mean positive, and leading 1s mean negative.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Two&amp;#39;s complement gets its name from the rule that the unsigned sum of an n-bit number and its negative is &lt;span class=&quot;mathjax&quot;&gt;\(2^n\)&lt;/span&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Good design demands good compromises&lt;/p&gt;
&lt;p&gt; The compromise chosen by the MIPS designers is to keep &lt;strong&gt;all instructions the same length&lt;/strong&gt; , thereby requiring different kinds of instruction formats for different kinds of instructions.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R-type: op-6bits, rs-5bits, rt-5bits, rd-5bits, shamt-5bits, funct-6bits.&lt;/li&gt;
&lt;li&gt;I-type: op-6bits, rs-5bits, rt-5bits, const or addr-16bits&lt;/li&gt;
&lt;li&gt;&lt;p&gt;J-type: op-6bits, addr-26bits&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The simplicity of the &amp;quot;equipment&amp;quot;&lt;/strong&gt; : MIPS doesn&amp;#39;t include branch on less than (&lt;code&gt;blt&lt;/code&gt; is a pseudo-instruction) because it&amp;#39;s too complicated; either it would stretch the clock cycle time or it would take extra clock cycles per instruction. Two faster instructions (&lt;code&gt;slt&lt;/code&gt; and &lt;code&gt;beq&lt;/code&gt;) are more usefull.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Register usage&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spilling registers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The process of putting less commonly used variables (or those needed later) into memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dada-transfer instruction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A command that moves data between memory and registers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sign extension&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Copy the sign repeatedly to fill the rest of the bits in the left.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Alignment restriction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MIPS tries to keep the stack aligned to word addresses, allowing the program to always use &lt;code&gt;lw&lt;/code&gt; and &lt;code&gt;sw&lt;/code&gt; to access the stack.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C string variable or an array of bytes will pack 4 bytes per word, and a Java variable or array of shorts packs 2 halfwords per word.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Stack spilling&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$sp&lt;/code&gt; is a stack pointer, which is adjusted by one word for each register that is saved or restored.&lt;/p&gt;
&lt;h3&gt;Procedure call&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;preserved by caller  &lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$t0-$t9&lt;/code&gt;: ten temporary registers, &lt;code&gt;$a0-$a3&lt;/code&gt;: four argument registers, &lt;code&gt;$v0-v1&lt;/code&gt;: two return registers&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Not preserved by the calee on a procedure call. The caller will push them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;preserved by callee  &lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$s0-$s7&lt;/code&gt;: eight saved registers, &lt;code&gt;$ra&lt;/code&gt;: return address, &lt;code&gt;$sp&lt;/code&gt;: the stack pointer and stack above &lt;code&gt;$sp&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Must be preserved on a procedure call. If used, the callee saves and restores them.  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Iteration can significantly improve performance by removing the overhead associated with procedure calls.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Data allocate&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/mips-mem.gif&quot; alt=&quot;mips-mem&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$gp&lt;/code&gt;: the global pointer that is reserved to point to the static area.  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;$fp&lt;/code&gt;: A value denoting the location of the saved registers and local variables for a given procedure.&lt;/p&gt;
&lt;p&gt;The frame point is convenient because all references to variables in the stack within a procedure will have the same offset.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;more than 4 paras: the trailing params are stored at &lt;code&gt;$fp+1&lt;/code&gt;, &lt;code&gt;$fp+2&lt;/code&gt;, etc.&lt;br&gt;Pointers vs Arrays: we calculate address (index multiply 4) in array addressing, while add 4 directly in pointer addressing.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Reserved registers&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;$zero&lt;/code&gt; always equals 0.&lt;br&gt;&lt;code&gt;$at&lt;/code&gt; is reserved by the assembler to handle large constants in immediate instructions and addresses in load/store instructions.&lt;br&gt;&lt;code&gt;$k0, $k1&lt;/code&gt; reserved for the operating system to handle exception procedure. They&amp;#39;re used to retain the address of instruction that causes the exception (which can be get from EPC register), when exception procedure exits and restores all registers before the exception. Thus the program can jump back to the normal procedure.&lt;/p&gt;
&lt;h2&gt;Addressing Mode&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Basic block&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Basic block is a sequence of instructions without branches, except possibly at the end , and without branch targets or branch labels, except possibly at the begining.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;One of the first early phases of compilation is breaking the program into basic blocks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Branch instruction&lt;/h3&gt;
&lt;p&gt;Branch instructions use 16-bit field address, which means no program will larger than &lt;span class=&quot;mathjax&quot;&gt;\(2^{16}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;While the destination of branch instructions is likely to be close to the branch. If we use &lt;strong&gt;PC-relative addressing&lt;/strong&gt; , the sum will allow the program to be as large as &lt;span class=&quot;mathjax&quot;&gt;\(2^{32}\)&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;As the same time, the &lt;code&gt;L1&lt;/code&gt; in &lt;code&gt;beq    $s0,    $s1,    L1&lt;/code&gt; could be bigger than &lt;span class=&quot;mathjax&quot;&gt;\(2^{16}\)&lt;/span&gt;, MIPS will break it into 2 instructions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;    bne     &lt;span class=&quot;hljs-variable&quot;&gt;$s0&lt;/span&gt;,    &lt;span class=&quot;hljs-variable&quot;&gt;$s1&lt;/span&gt;,    L2
    j       L1
L2:&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3&gt;Jump instruction&lt;/h3&gt;
&lt;p&gt;Jump instructions use 26-bit field adress, MIPS stretch the distance by having it refer to the number of &lt;em&gt;words&lt;/em&gt; to the next instruction instead of number of &lt;em&gt;bytes&lt;/em&gt;. The address now becomes 28-bit, MIPS will add the first 4-bit of PC automatically to get a 32-bit address(&lt;strong&gt;pseudodirect addressing&lt;/strong&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The loader and linker must be careful to avoid placing a program across an address boundary of 256MB, which is &lt;span class=&quot;mathjax&quot;&gt;\(2^{28}\)&lt;/span&gt; bit. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Immediate addressing: &lt;code&gt;addi $rs,  rt,   imm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Register addresing: &lt;code&gt;jr   $ra&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Base addressing: &lt;code&gt;lw $rt, addr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PC-relative addressing: &lt;code&gt;bne  $s0,    $s1,    Label&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Pseudodirect addressing: &lt;code&gt;j   Label&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Parallelism and Synchronization&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Data Race&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Two memory accesses form a data race if they are from different threads to ssame location, at least one is a write, and they occur one after another.&lt;/p&gt;
&lt;p&gt;One typical operation for building synchronization operations is the &lt;em&gt;atomic exchange&lt;/em&gt; or &lt;em&gt;atomic swap&lt;/em&gt;, while the challenge lies in that it requires both a memory read and a write in a single, uninterruptible instruction.&lt;/p&gt;
&lt;p&gt;MIPS contains a pair of instructions called a &lt;code&gt;load linked&lt;/code&gt; and &lt;code&gt;store conditional&lt;/code&gt;. These are used in sequence: if the content of the memory specified by &lt;code&gt;load linked&lt;/code&gt; is changed before the &lt;code&gt;store conditional&lt;/code&gt;, then the store fails.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Although it was presented for multi-processor sync, atomic exchange is also useful for the OS in dealing with multiple processes in a single processor. To ensure nothing interferes in a single processor, the &lt;code&gt;store conditional&lt;/code&gt; also fails if the processor does a context switch between the two instructions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Store conditional will fail after either another attempted store or any exception, in particular, only register-register instructions can safely be permited between the two instructions; otherwise, it is possible to create deadlock situations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Translating &amp;amp; Starting&lt;/h2&gt;
&lt;h3&gt;Compiler&lt;/h3&gt;
&lt;p&gt;The compiler transforms the C program to &lt;em&gt;assembly language program&lt;/em&gt;, a symbolic form of what the machine understands.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Assembly Language&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A symbolic language that can be translated into binary machine language.&lt;/p&gt;
&lt;h3&gt;Assembler&lt;/h3&gt;
&lt;p&gt;Assembler translate the &lt;em&gt;assembly language program&lt;/em&gt; into machine language program, called object file.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pseudoinstructions give MIPS a richer set of assembly language instructions than those implemented by the hardware. The only cost is reserving one register, &lt;code&gt;$at&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Linker&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Linker&lt;/strong&gt;, also called &lt;em&gt;link editor&lt;/em&gt;, is a systems program that combines independenty assembled machine language programs and resolves all undefined labels into an executable file. There are 3 steps for the linker:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Place code and data modules symbolically in memory.&lt;/li&gt;
&lt;li&gt;Determine the addresses of data and instrucion labels.&lt;/li&gt;
&lt;li&gt;Patch both the internal and external references.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Linker allows compiling and assembling each procedure independently, particulaly library routines, avoiding processing the whole program every time a small routine changes.&lt;br&gt;Typically, the &lt;em&gt;executable file&lt;/em&gt; has the same format as an object file, except that it contains no unresolved references.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Loader&lt;/h3&gt;
&lt;p&gt;A systems program that places an object program in main memory so that it is ready to execute.&lt;/p&gt;
&lt;h3&gt;Dynamically linked libraries&lt;/h3&gt;
&lt;p&gt;The static libraries has a few cons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The library routines become part of the exe file. The program need re-compiled when library updated.&lt;/li&gt;
&lt;li&gt;It loads all libs that are called anywhere in the exe, even not called.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lazy procedure linkage of DLLs:&lt;/p&gt;
&lt;p&gt;The first time the lib is called, the program calls the dummy entry and follows the indirect jump. It points to code that puts a number in a register to identify the desired lib and jumps to the dynamic linker/loader. The linker/loader finds the lib, remap it, and chages the address in the indirect jump location to the lib.&lt;/p&gt;
&lt;h3&gt;Starging a Java Program&lt;/h3&gt;
&lt;p&gt;Rather than compile to the assemly language of a target computer, Java is compiled first to the instructions that are easy tointerpret: the &lt;em&gt;Java bytecode&lt;/em&gt; instruction set. A interpreter called &lt;em&gt;Java Virtual Machine&lt;/em&gt; can execute Java bytecodes.&lt;/p&gt;
&lt;p&gt;Pro: portability; Con: lower performance. &lt;em&gt;Just In Time compilers (JIT)&lt;/em&gt; typically find the &amp;quot;hot&amp;quot; methods and compile them into native instruction set, and is saved for next run.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Typically, the unoptimized C program is faster than the interpreted Java code. Using the JIT compiler makes Java faster than the unoptimized C and slightly slower than highest optimized C code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Fallacy: More powerful instructions mean higher performance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Complex instructions consume more time.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fallacy: Write in assembly language to obtain the highest performance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This battle between compilers and assembly language coders is one situation in which humans are losing ground. Today&amp;#39;s C compilers generally ignore register hints made by programmers.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fallacy: The importance of commercial binary compatibility means successful instruction set don&amp;#39;t change.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While backwards binary compatibility is sacrosanct, the x86 architecture has grown dramatically.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fallacy: Forgetting that sequential word addresses in machines with byte addressing do not differ by one.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The address of next word can be found by incrementing the address in a register by the size of word, not one.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pitfall: Using a pointer to an automatic variable outside its defining procedure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The memory that contains the an array that is local to that procedure will be reused as soon as the procedure returns.&lt;/p&gt;
&lt;h1&gt;Arithmetic for Computers&lt;/h1&gt;
&lt;h2&gt;Addition and Subtraction&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Add (&lt;code&gt;add&lt;/code&gt;), and immediate (&lt;code&gt;addi&lt;/code&gt;), and subtract (&lt;code&gt;sub&lt;/code&gt;) cause exceptions on overflow.&lt;br&gt; MIPS detects overflow with an &lt;em&gt;exception&lt;/em&gt; (or &lt;em&gt;interrupt&lt;/em&gt; ),  which is an unscheduled procedure call. The address of current instruction is saved and the computer jumps to predefined address to invoke the appropriate routine for that exception.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MIPS uses &lt;em&gt;exception program counter&lt;/em&gt; (EPC) to contain the address of the instruction that causes the exception. The instruction &lt;em&gt;move from system control&lt;/em&gt; (&lt;code&gt;mfc0&lt;/code&gt;) is used to copy EPC into a general-purpose register.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add unsigned (&lt;code&gt;addu&lt;/code&gt;), add immediate unsigned (&lt;code&gt;addiu&lt;/code&gt;), and subtract unsigned (&lt;code&gt;subu&lt;/code&gt;) do not cause exceptions on overflow.&lt;br&gt; Programmers can trap overflow anyway: when overflow occurs, the sign bit of the result is not properly set. Compairing with sign bits of operands, the sign bit of the result can be determined. &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;SIMD (single instruction, multiple data): By partitioning the carry chains within a 64-bit adder, a processor could perform simultaneous operations on a short vecters of eight 8-bit operands, four 16-bit operands, etc. Vectors and 8-bit data often appears in multimedia routine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Multiplication&lt;/h2&gt;
&lt;p&gt;multiplicand * multiplier = product&lt;/p&gt;
&lt;h3&gt;Sequential Version of the Multiplication&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/multi1.png&quot; alt=&quot;sequential-multiply&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/multi-illu.png&quot; alt=&quot;sequential-multiply-illu&quot;&gt;&lt;/p&gt;
&lt;p&gt;Refined version:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Init: put multiplier to the left 32-bit of the product register.&lt;/li&gt;
&lt;li&gt;Cycle: &lt;ol&gt;
&lt;li&gt;if the last bit of product register is 1, add the left 32-bit with the multiplicand&lt;/li&gt;
&lt;li&gt;shift right the product register&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Final: the product register contains the 64-bit product&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/multi2.png&quot; alt=&quot;refined&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Faster Multiplication&lt;/h3&gt;
&lt;p&gt;A way to organize these 32 addtions is in a parallel tree:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/multi3.png&quot; alt=&quot;parallel&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Multiply in MIPS&lt;/h3&gt;
&lt;p&gt;The registers &lt;code&gt;Hi&lt;/code&gt; and &lt;code&gt;Lo&lt;/code&gt; contains the 64-bit product. Call &lt;code&gt;mflo&lt;/code&gt; to fetch the 32-bit product, &lt;code&gt;mfhi&lt;/code&gt; can be used to get &lt;code&gt;Hi&lt;/code&gt; to test for overflow.&lt;/p&gt;
&lt;h2&gt;Division&lt;/h2&gt;
&lt;p&gt;Dividend = Quotient * Divisor + Remainder&lt;/p&gt;
&lt;h3&gt;Division Algorithm&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/divide1.png&quot; alt=&quot;divide&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/divide-illu.png&quot; alt=&quot;divide-illu&quot;&gt;&lt;/p&gt;
&lt;p&gt;Improved version:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Init: put the dividend in the right 32-bit of remainder register.&lt;/li&gt;
&lt;li&gt;Cycle: &lt;ol&gt;
&lt;li&gt;subtract the left 32-bit of remainder by the divisor&lt;/li&gt;
&lt;li&gt;shift left the remaider register&lt;/li&gt;
&lt;li&gt;set the last bit as new quotient bit&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Final: the left 32-bit contains the remainder, right 32-bit contains the quotient.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/divide2.png&quot; alt=&quot;divede-improved&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Faster Division&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SRT division&lt;/strong&gt;: try to guess several quotient bits per step, using a table lookup based on the upper bits of the dividend and remainder. The key is guessing the value to subtract.&lt;/p&gt;
&lt;h3&gt;Divide in MIPS&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Hi&lt;/code&gt; contains the remainder, and &lt;code&gt;Lo&lt;/code&gt; contains the quotient after the divide instruction complete.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MIPS divide instructions ignore overflow. MIPS software must check the divisor to discover division by 0 as well as overflow.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Floating Point&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;scientific notation&lt;/strong&gt; A notation that renders numbers with a single digit to the left of the decimal point.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;normalized&lt;/strong&gt; A number in floating-point notation that has no leading 0s.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fraction&lt;/strong&gt; The value, generally between 0 and 1, placed in the fraction field.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;exponent&lt;/strong&gt; In the numerical representation system of floating-point arithmetic, the value that is placed in the exponent field.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;overflow&lt;/em&gt; the exponent is too large to be represented in the exponent field.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;floating point&lt;/strong&gt; Computer arithmetic that represents numbers in which the binary point is not fixed.&lt;/p&gt;
&lt;p&gt;In general, floating-point numbers are of the form: &lt;span class=&quot;mathjax&quot;&gt;\((-1)^S \times F \times 2^E\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MIPS float: sign(1 bit) + exponent(8 bit) + fraction(23 bit)&lt;br&gt;MIPS double: s(1 bit) + exponent(11 bit) + fraction(52 bit)&lt;/p&gt;
&lt;p&gt;IEEE 754 uses a bias of 127 for single precesion, and makes the leading 1 implicit. Since 0 has no leading 1, it&amp;#39;s given the reserved exponent 0 so that hardware won&amp;#39;t attach a leading 1.&lt;/p&gt;
&lt;p&gt;Thus 00...00 represents 0; the representation of the rest are in the following form:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\((-1)^S \times (1 + Fraction)\times 2^(Exponent - Bias)\)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The exponent is located left and the bias is for comparison convenience.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;The Processor&lt;/h1&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;A abstract view of the implementation of the MIPS subset showing the major functional units and the major connections between them:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/mips-abs.png&quot; alt=&quot;abstract-view&quot;&gt;&lt;/p&gt;
&lt;p&gt;The basic implementation of the MIPS subset, including the necessary multiplexors and control lines:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/mips-basic.png&quot; alt=&quot;mips-basic&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;asserted&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The signal is logically high or true.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;deasserted&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The signal is logically low or false.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Clocking methodology&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The approach used to determine when data is valid and stable relative to the clock.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Edge-triggered clocking&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A clocking scheme in which all state changes occur on a clock edge.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;control signal&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A signal used for multiplexor selection or for directing the operation of a functional unit; contrasts with a &lt;em&gt;data signal&lt;/em&gt; , which contains information that is operated on by a funcional unit. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The state element is changed only when the write control signal is asserted and a clock edge occurs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;A Simple Implementation Scheme&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;ALUOp&lt;/em&gt; indicates whether the operation to be performed should be add for loas and stores, substract for beq, or determined by the operation encoded in the funct field.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Multiple levels of decoding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The main control unit generates the ALUOp bits, which then are used as input to the ALU control that generates the actual signals to control the ALU unit.&lt;/p&gt;
&lt;p&gt;The datapath with all necessary multiplexors and all control lines identified:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/mips-all.png&quot; alt=&quot;mips-all&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Single-cycle implementation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Also called single clock cycle implementation. An implementation in which an instruction is executed in one clock cycle.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The clock cycle is determined by the longest possible path in the processor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;An Overview of Pipelining&lt;/h2&gt;
&lt;p&gt;Assuming ideal conditions:&lt;/p&gt;
&lt;p&gt;Time between instructions(pipelined) = Time between instructions(nonpipelined) / Number of pipe states&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pipelining improves performance by increasing instruction throughput, as opposed to decreasing the execution time of an individual instruction, also called latency.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Structual Hazards&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When a planned instruction cannot execute in the proper clock cycle because the hardware does not support the combination of instructions that are set to execute.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data Hazards&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Data Hazards occure when the pipeline must be stalled because one step must wait for another to complete.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Control Hazards&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Arising from the need to make a decision based on the results of one instruction while others are executing.&lt;/p&gt;
&lt;h2&gt;Pipelined Datapath and Control&lt;/h2&gt;
&lt;p&gt;The datapath is separated into 5 pieces:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IF: Instruction fetch&lt;/li&gt;
&lt;li&gt;ID: Instruction decode and register file read&lt;/li&gt;
&lt;li&gt;EX: Execution or address calculation&lt;/li&gt;
&lt;li&gt;MEM: Data memory access&lt;/li&gt;
&lt;li&gt;WB: Write back&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can divede the control lines into 5 groups according to the pipeline state&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IF: Signals to read instruction memory and write PC are always asserted, nothing to control.&lt;/li&gt;
&lt;li&gt;ID: As in the previous state, the same thing happens at every clock cycle, no optional control lines to set.&lt;/li&gt;
&lt;li&gt;EX: The signals to be set are RegDst, ALUOp, and ALUSrc. The signals select the Result register, the ALU operation, and either Read data 2 or a sign-extended immediate for the ALU.&lt;/li&gt;
&lt;li&gt;MEM: The control lines set are: Branch, MemRead, and MemWrite. These signals are set by the branch equal, load, and store instructions.&lt;/li&gt;
&lt;li&gt;WB: MemtoReg, which decides between sending the ALU result or the memory value to the register file; Reg Write, which writes the chosen value.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Multiple-clock-cycle pipeline diagram&lt;/strong&gt; gives overviews of pipelining situations:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/multiple-clock-cycle-pipeline.png&quot; alt=&quot;multiple-clock-cycle-pipeline&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Single-clock-cycle diagram&lt;/strong&gt; represents a vertical slice through a set of multiple-clock-cycle diagrams, showing the usage of the datapath by each of the instructions in the pipeline at the designated clock cycle.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/single-clock-cycle-pipeline.png&quot; alt=&quot;single-clock-cycle-pipeline&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Data Hazards&lt;/h2&gt;
&lt;h3&gt;Forwarding&lt;/h3&gt;
&lt;p&gt;When the result required by the current instruction is computed during EX stage of the previous instruction( or previous previous instruction), forwarding is used. See the two pairs of hazard conditions:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EX/MEM.RegisterRd = ID/EX.RegisterRs&lt;/li&gt;
&lt;li&gt;EX/MEM.RegisterRd = ID/EX.RegisterRt&lt;/li&gt;
&lt;li&gt;MEM/WB.RegisterRd = ID/EX.RegisterRs&lt;/li&gt;
&lt;li&gt;MEM/WB.RegisterRd = ID/EX.RegisterRt&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The &lt;em&gt;forwarding unit&lt;/em&gt; is used to forward new values from EX/MEM and MEM/WB pipeline-register to ID/EX pipeline-register when the conditions above occured.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that the values in EX/MEM is newer than MEM/WB, we will forward MEM/WB only when EX/MEM needn&amp;#39;t to be forwarded.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Stalls&lt;/h3&gt;
&lt;p&gt;When the result required by the current instruction is computed during MEM stage of the previous instruction, we must stall the pipeline.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;hazard detection unit&lt;/em&gt; operates during the ID stage, checking for load instructions and insert the stall between the load and its use. The single condition is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;if( ID/EX&lt;span class=&quot;hljs-preprocessor&quot;&gt;.MemRead&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; 
    ((ID/EX&lt;span class=&quot;hljs-preprocessor&quot;&gt;.RegisterRt&lt;/span&gt; = IF/ID&lt;span class=&quot;hljs-preprocessor&quot;&gt;.RegisterRs&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt;
     (ID/EX&lt;span class=&quot;hljs-preprocessor&quot;&gt;.RegisterRt&lt;/span&gt; = IF/ID&lt;span class=&quot;hljs-preprocessor&quot;&gt;.RegisterRt&lt;/span&gt;)))
        stall the pipeline&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By identifying the hazard in the ID stage, we can insert a bubble into the pipeline by changing the EX, MEM and WB control fields of the ID/EX pipeline registeer to 0.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Actually, only the signals RegWrite and MemWrite need be 0, while the other control signals can be don&amp;#39;t cares.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/pipe-control.png&quot; alt=&quot;pipe-control&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Control Hazards&lt;/h2&gt;
&lt;p&gt;Discarding instructions means we must be able to flush instructions in the IF, ID, and EX stages of the pipeline.&lt;/p&gt;
&lt;p&gt;Moving the branch decision up requires 2 actions to occur earlier: computing the branch target address and evaluating the branch decision.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic branch prediction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Prediction of branches at runtime using runtime information.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dynamic prediction buffer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Also called &lt;em&gt;branch history table&lt;/em&gt; , a small memory that is indexed by the lower portion of the branch instruction and that contains one or more bits indicating whether the branch was recently taken or not.&lt;/p&gt;
&lt;p&gt;The simple &lt;em&gt;1-bit prediction&lt;/em&gt; scheme has a performance shortcoming: even if a branch is almost always taken, we can predict incorrectly twice, rather than once, when it is not taken.&lt;/p&gt;
&lt;p&gt;In a &lt;em&gt;2-bit scheme*&lt;/em&gt;, a prediction must be wrong twice before it is changed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;branch delay slot&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The slot directly after a delayed branch instruction, which in the MIPS architecture is filled by an instruction that does not affect the branch.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The delayed branch is a simple solution to control hazards in a 5-stage pipeline. With longer pipelines, superscalar execution, and dymnamic branch prediction, it&amp;#39;s now redundant.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;branch target buffer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A structure that caches the destination PC or destination instruction for a branch. It&amp;#39;s usually organized as a cache with tags, making it more costly than a simple prediction buffer.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;correlating predictor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A branch predictor that combines local behavior of a particular branch and global information about the behavior of some recent number of executed branches.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tournament branch predictor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A branch predictor with multiple predictions for each branch and a selection mechanism that chooses which predictor to enable for a given branch.&lt;/p&gt;
&lt;h2&gt;Exceptions&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;exception&lt;/em&gt; refer to unexpected change internal, while &lt;em&gt;interrupt&lt;/em&gt; refer to that external.&lt;/p&gt;
&lt;p&gt;MIPS save the address of the offending instruction in the &lt;em&gt;exception program counter (EPC)&lt;/em&gt; , and the &lt;em&gt;Cause register&lt;/em&gt; holds a field that indicates the reason for the exception.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vectored interrupt&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An interrupt for which the address to which control is transferrd is determined by the cause of the exception.&lt;/p&gt;
&lt;p&gt;Exception Procedure&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We must flush the instructions follow the offending instruction from the pipeline.&lt;/li&gt;
&lt;li&gt;Use the EX.Flush signal to prevent the instruction in the EX stage from writing its result in the WB stage.&lt;/li&gt;
&lt;li&gt;Save the address of the offending instruction in the EPC.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Imprecise interrupt&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Also called &lt;em&gt;imprecise exception&lt;/em&gt; , Interrupts or exceptions in pipelined computers that are not associated with the exact instruction that was the cause of the interrupt or exception.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Precise interrupt&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Also called &lt;em&gt;precise exception&lt;/em&gt; , An interrupt or exception that is always associated with the correct instruction in pipelined computers.&lt;/p&gt;
&lt;h2&gt;Parallelism&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Instruction-level parallelism (ILP)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The parallelism among instructions.&lt;/p&gt;
&lt;h2&gt;Multiple issue&lt;/h2&gt;
&lt;p&gt;A scheme whereby multiple instructions are launched in one clock cycle.&lt;/p&gt;
&lt;h3&gt;static multiple issue&lt;/h3&gt;
&lt;p&gt;An approach to implementing a multiple-issue processor where many decisions are made by the compiler before execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;issue slots&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The positions from which instructions could issue in a given block cycle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Very Long Instruction Word (VLIW)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A style of instruction set architecture that launches many operations that are defined to be independent in a single wide instruction, typically with many separate opcode fields.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A simple 2-issue MIPS processor: one of the instructions can be an integer ALU operation or branch and the other can be a load or store.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;Dynamic multiple issue&lt;/h4&gt;
&lt;p&gt;An approach to implementing a multiple-issue processor where many decisions are made during executino by the processor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;superscalar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An advanced pipelining technique that enables the processor to execute more than one instruction per clock cycle by selecting them during execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dynamic pipeline scheduling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hardware support for reordering the order of instruction execution so as to avoid stalls.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/dps.png&quot; alt=&quot;dps&quot;&gt;&lt;/p&gt;
&lt;p&gt;register renaming:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;when a instruction issues, it&amp;#39;s copied to a reservation station for the appropriate functional unit.&lt;/li&gt;
&lt;li&gt;If an operand is not in the register file or reorder buffer, it must be waiting to be preduced by a functional unit.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;speculation&lt;/h3&gt;
&lt;p&gt;An approach whereby the compiler or processor guesses the outcome of an instruction to remove it as a dependence in executing other instructions.&lt;/p&gt;
&lt;p&gt;In the case of speculation in software, the compiler usually inserts additional instructions that check the accuracy of the speculation and provide a fix-up routine to use when speculation is incorrect.&lt;/p&gt;
&lt;p&gt;In hardware speculation, the processor usually buffers the speculative results until it knows they are no longer speculative.&lt;/p&gt;
&lt;h1&gt;Exploiting Memory Hierarchy&lt;/h1&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Principle of locality&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Temporal locality&lt;/strong&gt; : If a data location is referenced then it will tend to be referenced again soon.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;spatial locality&lt;/strong&gt; : If a data location is referenced, data locations with nearby addresses will tend to be referenced soon.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Memory hierarchy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A structrue that uses multiple levels of memories; as the distance from the processor increases, the size of the memories and the access time both increase.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The main memory is implemented from DRAM, levels closer to the processor use SRAM, the largest and slowest level is usually magnetic disk.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;The Basics of Caches&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;direct mapped cache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A cache structure in which each memory location is mapped to exactly one location in the cache.&lt;/p&gt;
&lt;p&gt;Cache index = (Block address) modulo (Number of blocks in the cache)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;valid bit&lt;/strong&gt; is used to indicate whether an entry contains a valid address. &lt;strong&gt;Tag&lt;/strong&gt; contains the address information required to identify whether the associated block in the hierarchy corresponds to a requested word.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Accessing a Cache&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/direct-mapped-cache.png&quot; alt=&quot;direct-mapped-cache&quot;&gt;&lt;/p&gt;
&lt;p&gt;Larger blocks exploit spatial locality to lower miss rate, while miss rate may go up eventually if the block size becomes a significant fraction to the cache size, because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of blocks can be held by the cache will become small, a great deal of competition occurs.&lt;/li&gt;
&lt;li&gt;The cost of miss increases.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;early restart&lt;/strong&gt; : Uppon miss, resume execution as soon as the requested word of the block is returned, rather than wait for the entire block.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Handling Misses&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Cache Miss&lt;/strong&gt; : A request for data from the cache that cannot be filled because the data is not present in the cache.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Out-of-order processors can allow execution of instructions while waiting for a cache miss, In-order-processors stall on a cache miss.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Handling Writes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Write Through&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Always write the data in to both the memory and the cache.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Write Buffer&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;A queue that holds data while the data is waiting to be written to memory. It&amp;#39;s used for fewer memory access and higher performance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Write Back&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When write occurs, the new value is written only in the cache, the modified block is written to the lower level of the hierarchy when it&amp;#39;s replaced.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Split Cache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A scheme in which a level of the memory hierarchy is composed of two independent caches that operate in parallel with each other, with one handling instructions and one handling data.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A combined cache with a total size equal to the sum of the two split caches will usually have a better hit rate.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Measuring and Improving Cache Performance&lt;/h2&gt;
&lt;p&gt;Memory-stall clock cycles = Insturctions / Program &lt;em&gt; Misses / Instruction &lt;/em&gt; Miss penalty&lt;/p&gt;
&lt;p&gt;AMAT(Average Memory Access Time) = Time for a hit + Miss rate * Miss penalty&lt;/p&gt;
&lt;h3&gt;Reducing Cache Misses by More Flexible Placement of Blocks&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;fully associative&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A cache structure in which a block can be placed in any location in the cache.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set associative&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A cache that has a fixed number of locations where each block can be placed.&lt;/p&gt;
&lt;p&gt;Set index = (Block nubmer) modulo (Number of sets in the cache)&lt;/p&gt;
&lt;p&gt;Increasing degree of associativity:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;usually decreases the miss rate&lt;/li&gt;
&lt;li&gt;a potential increase in the hit time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;least recently used(LRU)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A replacement scheme in which the block replaced is the one that has been unused for the longest time.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/set-associative.png&quot; alt=&quot;set-associative&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Reducing Miss Penalty Using Multilevel Caches&lt;/h3&gt;
&lt;p&gt;The design for a primary and secondary cache are significantly different:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The primary cache focus on minimizing hit time to yield a shorter clock cycle or fewer pipeline stages.&lt;/li&gt;
&lt;li&gt;The secondary cache focus on miss rate to reduce the penalty of long memory acess time.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Global Miss Rate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The fraction of references that miss in all relatives that miss in all levels of a multilevel cache.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Local Miss Rate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The fraction of references to one level of a cache that miss; used in multilevel hierarchies.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Performance in out-of-order processors&lt;br&gt;Memory-stall cycles / Instruction = Misses / Instruction * (Total miss latency - Overlapped miss latency)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;autotuning&lt;/strong&gt; : Considering block size and number of caches, some numerical libraries parameterize their algorithms and then search the parameter space at runtime to find the best combination for a particular computer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Virtual Memory&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;virtual Memory&lt;/strong&gt; implements the translation of a program&amp;#39;s address space to physical addresses. &lt;/p&gt;
&lt;p&gt;Major motivations&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Allow efficient and safe sharing of memory among multiple programs&lt;/li&gt;
&lt;li&gt;Rmove the programming burdens of a small, limited amount of main memory&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;A virtual memory is called a page, and a virtual memory miss is called a page fault.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Address translation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Also called address mapping, the process by which a virtual address is mapped to an address used to access memory.&lt;/p&gt;
&lt;p&gt;Several decisions in designing virtual memory systems&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pages should be large enough to amortize the high access time&lt;/li&gt;
&lt;li&gt;Organizations that reduce the page fault are attractive: fully associative placement&lt;/li&gt;
&lt;li&gt;Page faults can be handled in software because the overhead will be small compared to the disk access time.&lt;/li&gt;
&lt;li&gt;Write-through will not work since write takes too long. Instead, virtual memory use write-back.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;segmentation&lt;/strong&gt; : A variable-size address mapping scheme in which an address consists of 2 parts: a segment number, which is mapped to a physical address, and a segment offset.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Memory Page&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;page table&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The table contains the virtual to physical address translations in a virtual memory system. The table, which is stored in memory, is typically indexed by the virtual page number; each entry in the table contains the physical page number for that virtual page if the page is currently in memory.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/page-table.png&quot; alt=&quot;page-table&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;reference bit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Also called use bit, which is set whenever a page is accessed. A simple inplementation for LRU(least recently used).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dirty bit&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dirty bit is set when any word in a page is written, which indicates whether the page needs to be written out before it&amp;#39;s memory can be given to another page.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A modified page is often called a dirty page.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Techs used to reduce page table storage:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Keep a limit register that restricts the size of the page table for a given process.&lt;/li&gt;
&lt;li&gt;Divide the page table and let it grow from the highest addr down, and from the lowest addr up. There will be 2 pagetables and 2 separate limits.&lt;/li&gt;
&lt;li&gt;Apply a hashing function to the virtual addr so that the page table need be only the size of the number of physical pages in main memory.&lt;/li&gt;
&lt;li&gt;Multilevel page tables.&lt;/li&gt;
&lt;li&gt;Allow the page tables to be paged, just as memory data.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;TLB&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;translation-lookaside buffer(TLB)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A cache that keeps track of recently used address mappings to try to avoid an access to the page table, which makes addressing translation fast.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The hardware maintains an index that indicates the recommended entry to replace, thich is chosen randomly considering the complexity for hardware.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/tlb.png&quot; alt=&quot;tlb&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/tlb-cache.png&quot; alt=&quot;tlb&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/tlb-write-through.png&quot; alt=&quot;tlb&quot;&gt;&lt;/p&gt;
&lt;h3&gt;Virtual Addressed Cache&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;virtual addressed cache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A cache that is accessed with a virtual address rather than a physical address.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Aliasing&lt;/strong&gt; occurs when there are two virtual addresses for the same page. This ambiguity would allow one program to write the data without the other program being aware that the data had changed.&lt;/p&gt;
&lt;p&gt;A common compromise between physical addressing and virtual addressing is caches that are virtually indexed using just the page offset portion(which is physical address), but use physical tags. There is no alias problem in this case.&lt;/p&gt;
&lt;h3&gt;Implementing Protection with Virtual Memory&lt;/h3&gt;
&lt;p&gt;The hardware must provide at least 3 basic capabilities:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;At least 2 modes to indicate kernel(or supervisor) process, or user(or executive) process.&lt;/li&gt;
&lt;li&gt;A portion of processor state that a user process can read but not write.&lt;/li&gt;
&lt;li&gt;The processor can go from user mode to supervisor mode and vice versa.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Sharing information across processes: the operating system modifies the page table of the accessing process, the write access bit can be used to restrict the sharing to just read.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Context Switch&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Without TLB: change the page table register to the new address.&lt;/li&gt;
&lt;li&gt;With TLB: clear the TLB entries that belong to the older process.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Handling TLB Misses and Page Faults&lt;/h3&gt;
&lt;p&gt;All misses are classified into one of the 3 categories:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Compulsory misses: A block that has never been in the cache.&lt;/li&gt;
&lt;li&gt;Capacity misses: Blocks are replaced and then later retieved.&lt;/li&gt;
&lt;li&gt;Conflick misses: Also called collision misses, these are cache misses that occur in set -associative or direct-mapped caches when multiple blocks compete for the same set.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Upon page fault, the OS complete:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Look up the page table entry to find the location of the referenced disk page.&lt;/li&gt;
&lt;li&gt;Choose a physical page to replace. Write back the page if it&amp;#39;s dirty.&lt;/li&gt;
&lt;li&gt;Read in the physical page.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Since TLB miss is much more frequent, the OS loads the TLB from the page table without examine the entry and restarts the instruction. If the entry is invalid, another exception occurs and the OS recognizes the page fault.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When an exception first occurs, the processor sets a bit that disables all other exceptions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;unmapped&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A portion of the address space that cannot have page faults.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The OS places exception entry point code and the exception stack in unmapped memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;thrashing&lt;/strong&gt; and &lt;strong&gt;wording set&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Continuously swapping pages between memory and disk is called thrashing, the set of popular pages is called working set.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;prefeching&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A tech in which data blocks needed in the future are brought into the cache early by the use of special instructions that specify the address of the block.&lt;/p&gt;
&lt;h2&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Pitfall: Forgeting to account for byte addressing or the cache block size in simulating a cache.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Pitfall: Ignoring memory system behavior when writing programs or then generate code ina a compiler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Pitfall: Using average memory access time to evaluate the memory hierarchy of an out-of-order processor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If the processor continues to execute instructions, and may even sustain more cache misses during a cache miss.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pitfall: Extending an address space by adding segments on top of an unsegmented address space.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This would cause addressing problems.&lt;/p&gt;
&lt;h1&gt;Storage and Other I/O Topics&lt;/h1&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/io-dev.png&quot; alt=&quot;io-dev&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Dependability, Reliability, and Availability&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Dependability&lt;/strong&gt; is the quality of delivered service such that reliance can justifiably be placed on this service.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reliability&lt;/strong&gt; is a measure of the continuous service accomplishment(or, equivalently, of the time to failure) from a reference point.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;mean time to failure(MTTF)&lt;/strong&gt; is a reliability measure. &lt;strong&gt;annual failure rate(AFR)&lt;/strong&gt; is the percentage of devices that would be expected to fail in a year for a given MTTF. Service interruption is measured as mean time to repair(MTTR). Mean time between failures(MTBF) is simply the sum of MTTF and MTTR.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Availability&lt;/strong&gt; is a measure of service accomplishment with respect to the alternation between the two states of accomplishment and interruption.&lt;/p&gt;
&lt;p&gt;Availability = MTTF / MTBF&lt;/p&gt;
&lt;p&gt;3 ways to improve MTTF:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Fault avoidance: preventing fault occurrence by construction.&lt;/li&gt;
&lt;li&gt;Fault tolerance: using redundancy to allow the service to comply with the service specification despite faults occurring, which applies primarily to hardware faults.&lt;/li&gt;
&lt;li&gt;Fault forecasting: predicting the presence and creation of faults, which applies to hardware and software faults, allowing the component to be replaced before it fails.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Disk Storage&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;nonvolatile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Storage device where data retins its value even when power is removed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;track&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One of thousands of concentric circles that makes up the surface of a magnetic disk.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sector&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;One of the segments that make up a track on a magnetic disk; a sector is the smallest amount of information that is read or written on a disk.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Originally, all tracks had the same number of sectors and the same number of bits. With the introduction of &lt;strong&gt;zone bit recording(ZBR)&lt;/strong&gt; , disk drives changed to a varying number of sectors per track. Thus increasing the drive capacity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;cylinder&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cylinder referes to all the tracks under the heads at a given point on all surfaces.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seek time&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The time for the process of positioning a read/write head over the proper track on a disk.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rotational latency&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Also called &lt;strong&gt;rotational delay&lt;/strong&gt; , the time required for the desired sector of a disk to rotate under the read/write head; usually assumed to be half the rotation time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Transfer time&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Transfer time is the time to transfer a block of bits.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Disk controller&lt;/strong&gt; usually handles the detailed control of the disk and the transfer between the disk and the memory. &lt;strong&gt;Controller time&lt;/strong&gt; is the overhead the controller imposes in performing an I/O access.&lt;/p&gt;
&lt;h2&gt;Fash Storage&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;NOR flash&lt;/strong&gt; : storage cell is similiar to a standard NOR gate. Typically used for BIOS memory.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NAND flash&lt;/strong&gt; : offers greater storage density, but memory could only be read and written in blocks as wiring needed for random accesses was removed. Typically used for USB key.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wear leveling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;To cope with bit wearing out, most NAND flash products include a controller to spread the writes by remaapping blocks that have been written many times to less trodden blocks.&lt;/p&gt;
&lt;h2&gt;Connecting Processors, Memory, and I/O Devices&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;processor-memory bus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A bus that connects processor and memory and that is short, generally high speed, and matched to the memory system so as to maximize memory-processor bandwidth.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O bus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;By contrast, I/O bus can be lengthy, can have many types of devices connected to them, and often have a wide range in data bandwidth of the devices connected to them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;backplane bus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A bus that is designed to allow processors, memory, and I/O devices to coexist on a single bus.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I/O buses donot typically interface directly to the memoty but use either a processor-memory or a backplane bus to connect to memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;I/O transaction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A sequence of operations over the interconnect that includes a request and may include a response, either of which may caryy data. A transaction is initiated by a single request and may take many individual bus operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Synchronous bus&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A bus that includes a clock in the control lines and a fixed protocol for communicating that is relative to the clock.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Asynchronous interconnect&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Uses a handshaking protocol for coordinating usage rather than a clock; can accommodate a wide variety of devices of differing speeds.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;handshaking protocol&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A series of steps used to coordinate asynchronous bus transfers in which the sender and receiver proceed to the next step only when both parties agree that the current step has been completed.&lt;/p&gt;
&lt;h3&gt;The I/O Interconnects of the x86 Processors&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;north bridge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The chip for memory controller hub next to the processor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;south bridge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The one connected to north bridge, witch is the I/O controller hub.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/intel-io.png&quot; alt=&quot;intel-io&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Interfacing I/O Devices to the Processor, Memory, and Operating System&lt;/h2&gt;
&lt;h3&gt;Giving commands to I/O devices&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;memory-mapped I/O&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An I/O scheme in which portions of address space are assigned to I/O devices, and reads and writes to those addresses are interpreted as commands to the I/O device.&lt;/p&gt;
&lt;h3&gt;Communicating with the Processor&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;polling&lt;/strong&gt; : The process of periodically checking the status of an I/O device to determine the need to service the device.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interrupt-driven I/O&lt;/strong&gt; : An I/O scheme that employs interrupts to indicate to the processor that an I/O device needs attention.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Transferring the Data between a Device and Memory&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Use the processor to transfer data between a device and memory based on polling.&lt;/li&gt;
&lt;li&gt;Make the transfer of data interrupt friven.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;direct memory access (DMA)&lt;/strong&gt; : Having the device controller transfer data directly to ro from the memory without involving the processor.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;I/O Performance Measures&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;transaction processing&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A type of application that involves handing small short operations(called transactions) that typically require both I/O and computation. Transaction processing applications typically have both response time requirements and throughput performance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O Rate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Performance measure of I/Os per unit time, such as reads per second.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;data rage&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Performance measure of bytes per unit time, such as GB/sec.&lt;/p&gt;
&lt;h2&gt;Designing and I/O System&lt;/h2&gt;
&lt;p&gt;General approaches:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Find the weakest link in the I/O system, which will constrain the design.&lt;/li&gt;
&lt;li&gt;Configure this component to sustain the required bandwidth.&lt;/li&gt;
&lt;li&gt;Determine the requirements for the rest of the system and configure them to support this bandwidth.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Parallelism and I/O: Redundant Arrays of Inexpensive Disks&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;redundant arrays of inexpensive disks (RAID)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An organization of disks that uses an array of small and inexpensive disks so as to increase both performance and reliability.&lt;/p&gt;
&lt;h3&gt;No Redundancy (RAID 0)&lt;/h3&gt;
&lt;p&gt;Simply spreading data over multiple disks, called striping.&lt;/p&gt;
&lt;h3&gt;Mirroring (RAID 1)&lt;/h3&gt;
&lt;p&gt;Writing the identical data to multiple disks to increase data availability.&lt;/p&gt;
&lt;h3&gt;Error Detecting and Correcting Code (RAID 2)&lt;/h3&gt;
&lt;p&gt;RAID 2 borrows an error detection and correction scheme most often used for memories.&lt;/p&gt;
&lt;h3&gt;Bit-Interleaved Parit (RAID 3)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;protection group&lt;/strong&gt; is the group of data disks or blocks that share a common check disk or block. The cost of higher availability can be reduced to 1/n, where n is the number of disks in a protection group.&lt;/p&gt;
&lt;h3&gt;Block-Interleaved Parity (RAID 4)&lt;/h3&gt;
&lt;p&gt;The parity is stored as blocks and associated with a set of data blocks.&lt;/p&gt;
&lt;h3&gt;Distributed Block-Interleaved Parity (RAID 5)&lt;/h3&gt;
&lt;p&gt;To fix the parity-write bottleneck, the parity information can be spread throughout all the disks so that there is no single bottleneck for writes.&lt;/p&gt;
&lt;h3&gt;P+R Redundancy (RAID 6)&lt;/h3&gt;
&lt;p&gt;When a single failure correction is not sufficient, parity can be generalized to have a second calculation over the data and another check disk of information. The second check block allows recovery from a second failure.&lt;/p&gt;
&lt;h2&gt;Fallacies and Pitfalls&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Fallacy: The rated mean time to failure of disks is almost 140 years, so disks practically never fail.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;MTTF is calculated by putting thousands of disks in a room, run them for a few months, and count the number that fail.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;annual failure rate (AFR)&lt;/strong&gt; is a more useful measure.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Fallacy: A GB/sec interconnect can transfer 1 GB of data in 1 second.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Generally cannot use 100% of any computer resource.&lt;/li&gt;
&lt;li&gt;The definition of a GB of storage (&lt;span class=&quot;mathjax&quot;&gt;\(2^30\)&lt;/span&gt;) and a GB persecond of bandwidth (&lt;span class=&quot;mathjax&quot;&gt;\(10^9\)&lt;/span&gt;) donot agree.&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;OSs are the best place to schedule disk accesses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Since the disk knows the actual mapping of the logical addresses onto a physical geometry of sectors, tracks, and surfaes, it can reduce the rotational and seek latencies by rescheduling.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pitfall: Using the peak transfer rate of a portion of the I/O system to make performance projections or performance comparisons.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The peak performance is based on unrealistic assumptions about the system or are unattainble because of other system limitations.&lt;/p&gt;
&lt;h1&gt;Multicores, Multiprocessors, and Clusters&lt;/h1&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;multiprocessor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A computer system with at least two processors. This is in contrast to a &lt;strong&gt;uniprocessor&lt;/strong&gt; , which has one.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;job-level parallelism&lt;/strong&gt; or &lt;strong&gt;process-level parallelism&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Utilizing multiple processors by running independent programs simultaneously.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;parallel processing program&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A single program that runs on multiple processors simultaneously.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cluster&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A set of compters connected over a local area network (LAN) that functions as a single large message-passing multiprocessor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;multicore microprocessor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A microprocessor containing multiple processors (&amp;quot;cores&amp;quot;) in a single integrated circuit.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/para-cate.png&quot; alt=&quot;para-cate&quot;&gt;&lt;/p&gt;
&lt;h2&gt;The Difficulty of Creating Paralel Processing Programs&lt;/h2&gt;
&lt;p&gt;According to &lt;strong&gt;Amdahl&amp;#39;s law&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;Execution time after improvement = Execution time affected by improvement / Amount of improvement + Execution time unaffected.&lt;/p&gt;
&lt;p&gt;Thus,&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(Speed-up = \frac{1}{(1 - Fraction~time~affected) + \frac{Fraction~time~affected}{100}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Strong scaling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Speed-up achieved on a multiprocessor without increasing the size of problem.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Weak scaling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Speed-up achieved on a multiprocessor while increasing the size of the problem proportionally to the increase in the number of processors.&lt;/p&gt;
&lt;h2&gt;Shared Memory Multiprocessors&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;shared memory multiprocessor (SMP)&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;A parallel processor with a single address space, implying implicit communication with loads and stores.&lt;/p&gt;
&lt;p&gt;Single address space multiplrocessors come in two styles:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;uniform memory access (UMA)&lt;/strong&gt; : A multiprocessor in which accesses to main memory take about the same amount of time no matter which processor requets the access and no matter which word is asked.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;nonuniform memory access (NUMA)&lt;/strong&gt; : A type of single address space multiprocessor in which some memory accesses are much faster than others depending on which processor asks for which word.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Data sharing:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;synchronization&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The process of coordinating the behavior of two or more processes, which may be running on different processors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;lock&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A synchronization device that allows access to data to only one processor at a time.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/shared-mem.png&quot; alt=&quot;shared-mem&quot;&gt;&lt;/p&gt;
&lt;h2&gt;Distributed Memory Multiprocessors&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/distri-mem.png&quot; alt=&quot;distri-mem&quot;&gt;&lt;/p&gt;
&lt;p&gt;There were several attempts to build high-performance computers based on high-performance message-passing networks, while they were all too expensive than using LAN.&lt;/p&gt;
&lt;p&gt;A weakness of separate memories for user memory turns into a strength in system availability.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It&amp;#39;s easier to replace a machine without bringing down the system in a cluster than in an SMP.&lt;/li&gt;
&lt;li&gt;It&amp;#39;s easier to expand the system without bringing down the application that runs on top of the cluster.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lower cost, high availability, improved power efficiency, and rapid, incremental expandability make clusters attractive to service providers for the Word Wide Web.&lt;/p&gt;
&lt;h2&gt;Hardware Multithreading&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;hardware multithreading&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Increasing utilization of a processor by switching to annoher thread when one thread is stalled. To permit this, we must duplicate the independent state. For example, each thread would have a separate copy of the register file and the PC.&lt;/p&gt;
&lt;p&gt;There are two main approaches to hardware multithreading.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Fine-grained multithreading&lt;/strong&gt; A version of hardware multithreading that suggests switching between threads after every instruction.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hiding the throughput losses that arise from both short and long stalls; while slows down the execution of the individual threads.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Coarse-grained multithreading&lt;/strong&gt; A version of hardware multithreading that suggests switching between threads onlly after significant events, such as a cache miss.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Relieves the need to have thread switching be essentially free and  is much less likely to slow down the execution of an individual thread; while it&amp;#39;s limited in its ability to overcome throughput losses, especially from shorter stalls, since thread switch requires pipeline be emptied or frozen (pipeline start-up cost).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Simultaneous multithreading (SMT)&lt;/strong&gt; A version of multithreading that lowers the cost of multithreading by utilizing the resources neede for multiple issue, dynamically schedule microarchitecture.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/thread-multi.png&quot; alt=&quot;thread-multi&quot;&gt;&lt;/p&gt;

</description>
				<pubDate>Sat, 30 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/%E8%AF%BB%E4%B9%A6/computer-organization-and-design.html</link>
				<guid isPermaLink="true">http://harttle.github.io/%E8%AF%BB%E4%B9%A6/computer-organization-and-design.html</guid>
			</item>
		
			<item>
				<title>Vim 使用</title>
				<description>&lt;p&gt;Vim是从vi发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。&lt;/p&gt;
&lt;p&gt;文档参见：&lt;a href=&quot;http://vimdoc.sourceforge.net/htmldoc/&quot;&gt;http://vimdoc.sourceforge.net/htmldoc/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文文档：&lt;a href=&quot;http://vimcdoc.sourceforge.net/doc/&quot;&gt;http://vimcdoc.sourceforge.net/doc/&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;基础使用&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/blog/vim-key.png&quot; alt=&quot;vim-key&quot;&gt;&lt;/p&gt;
&lt;p&gt;查看帮助：&lt;code&gt;:help&lt;/code&gt;，&lt;code&gt;&amp;lt;Ctrl&amp;gt;]&lt;/code&gt; 进入标签，&lt;code&gt;&amp;lt;Ctrl&amp;gt;O&lt;/code&gt; 返回。&lt;/p&gt;
&lt;!--more--&gt;

&lt;h1&gt;配置文件&lt;/h1&gt;
&lt;h2&gt;初始化过程&lt;/h2&gt;
&lt;p&gt;正如多数 linux 软件，vim 的配置文件分为系统配置文件 &lt;code&gt;/etc/vimrc&lt;/code&gt;，&lt;code&gt;/usr/share/vim/&lt;/code&gt; 和用户配置文件 &lt;code&gt;~/.vimrc&lt;/code&gt;，&lt;code&gt;~/.vim/&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;vim 的配置文件载入过程为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;/etc/vimrc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$HOME/.vim/&lt;/code&gt;，&lt;code&gt;$HOME/.vimrc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$VIMRUNTIME/.vim&lt;/code&gt;，&lt;code&gt;$VIMRUNTIME/.vimrc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$HOME/.vim/after/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;通过运行 &lt;code&gt;vim -V&lt;/code&gt; 可查看整个初始化过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;示例配置&lt;/h2&gt;
&lt;p&gt;一个示例配置文件如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; .vimrc
&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; See: http://vimdoc.sourceforge.net/htmldoc/options.html for details
&lt;/span&gt;
&lt;span class=&quot;hljs-string&quot;&gt;&quot; For multi-byte character support (CJK support, for example):
&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; set fileencodings=ucs-bom,utf-8,cp936,big5,euc-jp,euc-kr,gb18030,latin1
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; tabstop=&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;       &lt;span class=&quot;hljs-string&quot;&gt;&quot; Number of spaces that a &amp;lt;Tab&amp;gt; in the file counts for.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;shiftwidth&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot; Number of spaces to use for each step of (auto)indent.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; expandtab       &lt;span class=&quot;hljs-string&quot;&gt;&quot; Use the appropriate number of spaces to insert a &amp;lt;Tab&amp;gt;.
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; Spaces are used in indents with the &#39;&amp;gt;&#39; and &#39;&amp;lt;&#39; commands
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; and when &#39;autoindent&#39; is on. To insert a real tab when
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; &#39;expandtab&#39; is on, use CTRL-V &amp;lt;Tab&amp;gt;.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; smarttab        &lt;span class=&quot;hljs-string&quot;&gt;&quot; When on, a &amp;lt;Tab&amp;gt; in front of a line inserts blanks
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; according to &#39;shiftwidth&#39;. &#39;tabstop&#39; is used in other
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; places. A &amp;lt;BS&amp;gt; will delete a &#39;shiftwidth&#39; worth of space
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; at the start of the line.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; showcmd         &lt;span class=&quot;hljs-string&quot;&gt;&quot; Show (partial) command in status line.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;number&lt;/span&gt;          &lt;span class=&quot;hljs-string&quot;&gt;&quot; Show line numbers.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; showmatch       &lt;span class=&quot;hljs-string&quot;&gt;&quot; When a bracket is inserted, briefly jump to the matching
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; one. The jump is only done if the match can be seen on the
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; screen. The time to show the match can be set with
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; &#39;matchtime&#39;.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; hlsearch        &lt;span class=&quot;hljs-string&quot;&gt;&quot; When there is a previous search pattern, highlight all
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; its matches.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; incsearch       &lt;span class=&quot;hljs-string&quot;&gt;&quot; While typing a search command, show immediately where the
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; so far typed pattern matches.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; ignorecase      &lt;span class=&quot;hljs-string&quot;&gt;&quot; Ignore case in search patterns.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; smartcase       &lt;span class=&quot;hljs-string&quot;&gt;&quot; Override the &#39;ignorecase&#39; option if the search pattern
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; contains upper case characters.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; backspace=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;     &lt;span class=&quot;hljs-string&quot;&gt;&quot; Influences the working of &amp;lt;BS&amp;gt;, &amp;lt;Del&amp;gt;, CTRL-W
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; and CTRL-U in Insert mode. This is a list of items,
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; separated by commas. Each item allows a way to backspace
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; over something.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; autoindent      &lt;span class=&quot;hljs-string&quot;&gt;&quot; Copy indent from current line when starting a new line
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; (typing &amp;lt;CR&amp;gt; in Insert mode or when using the &quot;&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot; or &quot;&lt;/span&gt;O&lt;span class=&quot;hljs-string&quot;&gt;&quot;
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; command).
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; textwidth=&lt;span class=&quot;hljs-number&quot;&gt;79&lt;/span&gt;    &lt;span class=&quot;hljs-string&quot;&gt;&quot; Maximum width of text that is being inserted. A longer
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; line will be broken after white space to get this width.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; formatoptions=&lt;span class=&quot;hljs-keyword&quot;&gt;c&lt;/span&gt;,&lt;span class=&quot;hljs-keyword&quot;&gt;q&lt;/span&gt;,&lt;span class=&quot;hljs-keyword&quot;&gt;r&lt;/span&gt;,&lt;span class=&quot;hljs-keyword&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot; This is a sequence of letters which describes how
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; automatic formatting is to be done.
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot;
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; letter    meaning when present in &#39;formatoptions&#39;
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; ------    ---------------------------------------
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; c         Auto-wrap comments using textwidth, inserting
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot;           the current comment leader automatically.
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; q         Allow formatting of comments with &quot;&lt;/span&gt;gq&lt;span class=&quot;hljs-string&quot;&gt;&quot;.
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; r         Automatically insert the current comment leader
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot;           after hitting &amp;lt;Enter&amp;gt; in Insert mode. 
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; t         Auto-wrap text using textwidth (does not apply
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot;           to comments)
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; ruler           &lt;span class=&quot;hljs-string&quot;&gt;&quot; Show the line and column number of the cursor position,
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; separated by a comma.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; background=dark &lt;span class=&quot;hljs-string&quot;&gt;&quot; When set to &quot;&lt;/span&gt;dark&lt;span class=&quot;hljs-string&quot;&gt;&quot;, Vim will try to use colors that look
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; good on a dark background. When set to &quot;&lt;/span&gt;light&lt;span class=&quot;hljs-string&quot;&gt;&quot;, Vim will
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; try to use colors that look good on a light background.
&lt;/span&gt;                    &lt;span class=&quot;hljs-string&quot;&gt;&quot; Any other value is illegal.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;set&lt;/span&gt; mouse=&lt;span class=&quot;hljs-keyword&quot;&gt;a&lt;/span&gt;         &lt;span class=&quot;hljs-string&quot;&gt;&quot; Enable the use of the mouse.
&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;filetype&lt;/span&gt; plugin &lt;span class=&quot;hljs-built_in&quot;&gt;indent&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;syntax&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;进阶技巧&lt;/h1&gt;
&lt;h2&gt;块编辑&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可视&lt;/strong&gt; 模式：&lt;code&gt;v&lt;/code&gt; 可进入visual模式，使用标准快捷键移动光标可选择文本块，之后可输入标准编辑命令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;列编辑&lt;/strong&gt; 模式：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，移动光标将按列进行选中。例如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;删除块注释：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，&lt;code&gt;ikjl&lt;/code&gt; 选中注释列，&lt;code&gt;&amp;lt;N&amp;gt;x&lt;/code&gt; 删除N个字符；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;添加块注释：&lt;code&gt;&amp;lt;Ctrl&amp;gt;v&lt;/code&gt; 进入列编辑模式，&lt;code&gt;ikjl&lt;/code&gt; 选中要注释的行，&lt;code&gt;I&lt;/code&gt; 进入插入模式，输入几个注释字符，&lt;code&gt;&amp;lt;Esc&amp;gt;&lt;/code&gt; 推出列编辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文件识别&lt;/h2&gt;
&lt;p&gt;Vim可针对特定的文件，加载指定插件。以此来实现文件类型的特殊配置以及语法高亮。&lt;/p&gt;
&lt;p&gt;参见：&lt;a href=&quot;http://vimcdoc.sourceforge.net/doc/filetype.html#filetype-plugins&quot;&gt;http://vimcdoc.sourceforge.net/doc/filetype.html#filetype-plugins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;filetype on&lt;/code&gt; 将开启文件识别，Vim 会在载入时做如下工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行&lt;code&gt;$RUNTIMEPATH/filetype.vim&lt;/code&gt;，根据文件名判断类型&lt;/li&gt;
&lt;li&gt;如果需要的话，执行 &lt;code&gt;$RUNTIMEPATH/scripts.vim&lt;/code&gt;，进一步判断文件类型&lt;/li&gt;
&lt;li&gt;设置 Vim 的 &lt;code&gt;filetype&lt;/code&gt; 变量&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;我们也可以通过诸如 &lt;code&gt;:set filetype=c&lt;/code&gt; 的命令来手动设置文件类型&lt;br&gt;如果不使用文件识别，我们可以运行 &lt;code&gt;au BufNewFile,BufRead *.plt  source ~/.vim/after/ftplugin/plt.vim&lt;/code&gt; 来使用 &lt;code&gt;plt.vim&lt;/code&gt; 初始化 &lt;code&gt;*.plt&lt;/code&gt; 文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;更多关于&lt;code&gt;RUNTIMEPATH&lt;/code&gt; ：&lt;a href=&quot;http://vimcdoc.sourceforge.net/doc/options.html#&amp;#39;runtimepath&quot;&gt;http://vimcdoc.sourceforge.net/doc/options.html#&amp;#39;runtimepath&lt;/a&gt;&amp;#39;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;插件加载&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;filetype plugin on&lt;/code&gt; 允许Vim加载文件类型的插件，Vim会在载入时寻找并加载 &lt;code&gt;$RUNTIMEPATH/ftplugin.vim&lt;/code&gt;，该脚本会寻找并加载 &lt;code&gt;$RUNTIMEPATH/ftplugin/&amp;lt;filetype&amp;gt;.vim&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;~/.vim/ftplugin/cpp.vim&lt;/code&gt; 将在 cpp 文件类型被识别后自动载入。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同样，&lt;code&gt;~/.vim/after/ftplugin/cpp.vim&lt;/code&gt; 会在最后被调用，进而覆盖之前的配置。&lt;br&gt;另外，&lt;code&gt;filetype indent on&lt;/code&gt; 允许Vim加载该文件类型的缩进设置。即执行&lt;code&gt;RUNTIMEPATH/indent.vim&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;语法高亮&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;syntax on&lt;/code&gt; 允许 Vim 加载文件类型的语法高亮配置，Vim会在载入时寻找并加载 &lt;code&gt;RUNTIMEPATH/syntax/&amp;lt;filetype&amp;gt;.vim&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;~/.vim/syntax/markdown.vim&lt;/code&gt; 将会对文件类型&lt;code&gt;markdown&lt;/code&gt; 进行语法高亮。&lt;/p&gt;
&lt;h2&gt;键盘映射&lt;/h2&gt;
&lt;p&gt;Vim支持定义键盘映射来完成快捷键的功能，也就是将特定的按键映射为一系列按键与函数的序列。&lt;/p&gt;
&lt;p&gt;例如将 &lt;code&gt;F7&lt;/code&gt; 映射为编译当前java文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;map &amp;lt;F7&amp;gt; &amp;lt;Esc&amp;gt;:!javac %&amp;lt;&amp;lt;CR&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;:&lt;/code&gt; 为进入Ex模式，&lt;code&gt;!&lt;/code&gt; 指定下面的命令在vim外执行，&lt;code&gt;%&lt;/code&gt; 为当前文件名，&lt;code&gt;%&amp;lt;&lt;/code&gt; 为不带扩展名的当前文件名，&lt;code&gt;&amp;lt;CR&amp;gt;&lt;/code&gt; 为回车。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;函数&lt;/h2&gt;
&lt;p&gt;现在我们可以自定义快捷键了，如果希望在键盘映射中执行更复杂的功能，我们需要定义Vim函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数名必须以大写字母开始&lt;/li&gt;
&lt;li&gt;函数可以有返回值：&lt;code&gt;return something&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数可以有范围前缀。定义：&lt;code&gt;function s:Save()&lt;/code&gt;，调用：&lt;code&gt;call s:Save()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是函数调用的例子，按键F8时，进入拷贝模式（取消行号，鼠标进入visual模式）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&quot; key mapping
map &amp;lt;F8&amp;gt; &amp;lt;Esc&amp;gt;:call ToggleCopy()&amp;lt;CR&amp;gt;

&quot; global variable
let g:copymode=0

&quot; function
function ToggleCopy()
    if g:copymode
        set number
        set mouse=a
    else
        set nonumber
        set mouse=v
    endif
    let g:copymode=!g:copymode
endfunction&lt;/code&gt;&lt;/pre&gt;
</description>
				<pubDate>Fri, 08 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/linux/vim-advanced.html</link>
				<guid isPermaLink="true">http://harttle.github.io/linux/vim-advanced.html</guid>
			</item>
		
			<item>
				<title>安装 Arch Linux</title>
				<description>&lt;p&gt;本文介绍如何安装 Arch Linux，一个轻量级、简单的 Linux 发行版。&lt;/p&gt;
&lt;p&gt;相关链接&lt;br&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Beginners&amp;#39;_Guide&quot;&gt;Beginner&amp;#39;s Guide&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/Arch_Linux_Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87&quot;&gt;汉化&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;制作镜像并启动&lt;/h2&gt;
&lt;p&gt;在arch官方或者bjtu下载到镜像（X86和64）是同一镜像。然后刻录安装盘：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;linux:   &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  dd &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;=/path/to/iso of=/dev/sdc  &lt;span class=&quot;hljs-comment&quot;&gt;# 确认 sdc 为你的U盘&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;windows:&lt;ol&gt;
&lt;li&gt;下载 dd4dos&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dd if=/path/to/iso of=&amp;quot;\\.\G:&amp;quot;   # 确认G盘为你的U盘&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，启动不了很正常，和U盘有关。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;连接网络&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无线网络&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  netcfg(wifi-menu连接无线网）
  &lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; /etc/network.d
  cp ./examples/wireless_XXX ./    
  vi wireless_XXX  &lt;span class=&quot;hljs-comment&quot;&gt;#修改参数&lt;/span&gt;
  netcfg wireless_XXX&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;对于内核没有支持的无线网卡，安装ndiswrapper使用windows驱动  &lt;ol&gt;
&lt;li&gt;安装    &lt;code&gt;pacman -S ndiswrapper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加载    &lt;code&gt;ndiswrapper -i winXP_driver.inf(可以从windows目录下或驱动安装包找到)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确认    &lt;code&gt;ndiswrapper -l&lt;/code&gt; &lt;/li&gt;
&lt;li&gt;载入模块    &lt;code&gt;modprobe ndiswrapper&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;若无线网卡的状态指示灯不亮，重新载入网卡    &lt;code&gt;cardctl eject &amp;amp;&amp;amp; cardctl insert&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;iwconfig&lt;/code&gt; 可查看网络设备(wlan0,eth0等)，若没有识别请参照wiki&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!--more--&gt;

&lt;h2&gt;准备硬盘&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;磁盘分区：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; cfdisk /dev/sda &lt;span class=&quot;hljs-comment&quot;&gt;#至少一个主分区。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;格式化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; mkfs.ext4 /dev/sda1，mkswap /dev/sda2（之后可用 lsblk /dev/sda 查看分区）&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;挂载：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; mount /dev/sda1 /mnt，swapon /dev/sda2&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; /etc/pacmand./mirrorlist    &lt;span class=&quot;hljs-comment&quot;&gt;#配置源&lt;/span&gt;
 pacstrap -i /mnt base base-devel    &lt;span class=&quot;hljs-comment&quot;&gt;#安装&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更新静态文件系统信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; genfstab -U -p /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;可能出现的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GPGME error  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No data：error: failed to update core (invalid or corrupted database (PGP signature))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  在 &lt;code&gt;/etc/pacman.conf&lt;/code&gt; 的 &lt;code&gt;[options]&lt;/code&gt; 加入 &lt;code&gt;SigLevel = Never&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用交换文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;# 建立swap文件&lt;/span&gt;
  fallocate &lt;span class=&quot;hljs-operator&quot;&gt;-l&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;512&lt;/span&gt;M /swapfile
  &lt;span class=&quot;hljs-comment&quot;&gt;# 或者&lt;/span&gt;
  dd &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;=/dev/zero of=/swapfile bs=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;M count=&lt;span class=&quot;hljs-number&quot;&gt;512&lt;/span&gt;

  &lt;span class=&quot;hljs-comment&quot;&gt;# 设置swap&lt;/span&gt;
  chmod &lt;span class=&quot;hljs-number&quot;&gt;600&lt;/span&gt; /swapfile
  mkswap /swapfile
  swapon /swapfile

  &lt;span class=&quot;hljs-comment&quot;&gt;# 更新静态文件系统信息 /etc/fstab 中加入：&lt;/span&gt;
  /swapfile none swap defaults &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;配置系统&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进入新系统&lt;/p&gt;
&lt;p&gt; 更换主目录：&lt;code&gt;arch-chroot /mnt&lt;/code&gt;&lt;br&gt; 更新系统：&lt;code&gt;配置/etc/pacman.d/mirrorlist并pacman -Syu&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置区域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置地区：&lt;code&gt;ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置硬件时钟：&lt;code&gt;hwclock --systohc --utc&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;自动同步时间：&lt;code&gt;sudo systemctl enable ntpd（需要ntp）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;fix windows:   &lt;ul&gt;
&lt;li&gt;add a DWORD value with hexadecimal value 1 to the registry:&lt;br&gt;  &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\RealTimeIsUniversal&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;disable time auto sync&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置语言选项：修改 &lt;code&gt;/etc/locale.gen&lt;/code&gt; 并 &lt;code&gt;locale-gen&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置语言：&lt;code&gt;echo LANG=en_US.UTF-8 &amp;gt; /etc/locale.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置主机：&lt;code&gt;echo myhostname &amp;gt; /etc/hostname&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置网络&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装netcfg用到的工具包：&lt;code&gt;pacman -S wireless_tools wpa_supplicant wpa_actiond ifplugd dialog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启用自动连接&lt;ul&gt;
&lt;li&gt;单一网络：&lt;code&gt;systemctl enable dhcpcd@eth0.service&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;变化网络：自动连接在 &lt;code&gt;/etc/network.d&lt;/code&gt; 下的网络&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  systemctl enable net-auto-wired.service
  systemctl enable net-auto-wired.service
  systemctl enable net-auto-wireless.service&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置用户&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置root密码：&lt;code&gt;passwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加用户：&lt;code&gt;useradd -m -g users -s /bin/bash harttle&lt;/code&gt;，设置用户密码：&lt;code&gt;passwd harttle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除用户：&lt;code&gt;userdel -r harttle&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;重建引导&lt;/h2&gt;
&lt;p&gt;以grub为例，可选syslinux&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装grub：&lt;code&gt;pacman -S grub-bios&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;写入主引导：&lt;code&gt;grub-install --target=i386-pc --recheck /dev/sda&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置grub区域：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  cp /usr/share/locale/en\@quot/LC_MESSAGES/grub.mo /boot/grub/locale/en.mo&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更新启动列表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索windows：&lt;code&gt;pacman -S os-prober&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更新列表：&lt;code&gt;grub-mkconfig -o /boot/grub/grub.cfg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重启：&lt;code&gt;exit;umount /mnt{boot,home,};reboot&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;安装工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AUR&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;# /etc/pacman.conf 中加入&lt;/span&gt;
  [archlinuxfr]
  SigLevel = Optional TrustAll
  Server = http://repo.archlinux.fr/&lt;span class=&quot;hljs-variable&quot;&gt;$arch&lt;/span&gt;
  pacman -Syu yaourt&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;sudo&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;  安装：&lt;code&gt;pacman -S sudo&lt;/code&gt;&lt;br&gt;  配置：&lt;code&gt;etc/sudoers&lt;/code&gt; 添加 &lt;code&gt;harttle ALL=(ALL) ALL&lt;/code&gt;，使harttle可以使用sudo&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;bash&lt;/code&gt; 自动补全：&lt;code&gt;bash-completion&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;vim&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;安装图形界面&lt;/h2&gt;
&lt;p&gt;以KDE为例，可选gnome&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装驱动：&lt;code&gt;mesa(3D)&lt;/code&gt;,&lt;code&gt;xf86-video-vesa(Default)&lt;/code&gt;,&lt;code&gt;xf86-video-nouveau(open nvidia)&lt;/code&gt;,&lt;code&gt;nouveau-dri&lt;/code&gt;(open nvidia)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装图形界面的底层协议实现：&lt;code&gt;pacman -S xorg&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装kde及其语言包：&lt;code&gt;pacman -S kde kde-l10n-zh_cn&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最小安装：&lt;code&gt;kdebase&lt;/code&gt;，&lt;code&gt;phonon-gstreamer&lt;/code&gt;，&lt;code&gt;kde-l10n-zh_cn&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置启动&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;采用 &lt;code&gt;startx&lt;/code&gt;：&lt;code&gt;~/.xinitrc&lt;/code&gt; 加入 &lt;code&gt;exec ck-launch-session startx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;采用kdm(kde)，可选gdm(gnome)&lt;ul&gt;
&lt;li&gt;安装 &lt;code&gt;kdebase-workspace&lt;/code&gt;，编辑 &lt;code&gt;~/.xprofile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置 kdm 启动：&lt;code&gt;systemctl enable kdm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kde的gtk支持：安装 &lt;code&gt;oxygen-gtk2&lt;/code&gt;，&lt;code&gt;oxygen-gtk3&lt;/code&gt;，&lt;code&gt;kde-gtk-config&lt;/code&gt;(AUR) 进入系统设置-&amp;gt;公共外观行为-&amp;gt;应用程序外观-&amp;gt;gtk configuration相关设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;kde网络管理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; pacman -S networkmanager kdeplasma-applets-networkmanagement
 systemctl enable NetworkManager.service&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置登录屏幕主题：&lt;code&gt;archlinux-themes-kdm(AUR)&lt;/code&gt;，kde systemsettings 中的设置不起作用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在fstab加入开机挂载的分区，需要 &lt;code&gt;ntfs-3g&lt;/code&gt;(AUR)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; /dev/hda1        /mnt/winC        ntfs-&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;g iocharset=utf8,umask=&lt;span class=&quot;hljs-number&quot;&gt;022&lt;/span&gt;,noatime &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;汉化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置X默认字符集：在 &lt;code&gt;~/.bashrc&lt;/code&gt;、&lt;code&gt;~/.xinitrc&lt;/code&gt; 或 &lt;code&gt;~/.xprofile&lt;/code&gt; 中加入&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  LOCALE=en_US.UTF-&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; LANG=zh_CN.UTF-&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; LC_ALL=&lt;span class=&quot;hljs-string&quot;&gt;&quot;zh_CN.UTF-8&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装字体库&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;wqy-bitmapfont&lt;/code&gt;，&lt;code&gt;wqy-zenhei&lt;/code&gt;，&lt;code&gt;ttf-arphic-ukai&lt;/code&gt;，&lt;code&gt;ttf-arphic-uming&lt;/code&gt;，&lt;code&gt;ttf-fireflysung&lt;/code&gt;，&lt;code&gt;wqy-microhei&lt;/code&gt;（AUR），&lt;code&gt;wqy-microhei-lite&lt;/code&gt;（AUR）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输入法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 fcitx&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; pacman -S fcitx fcitx-gtk2 fcitx-gtk3 fcitx-qt&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;安装配置工具：&lt;code&gt;fcitx-configtool&lt;/code&gt;(基于gtk3), &lt;code&gt;fcitx-configtool-gtk2&lt;/code&gt;(基于gtk2), &lt;code&gt;kcm-fcitx&lt;/code&gt;(基于KDE的KCM)&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置X的输入法：在 &lt;code&gt;~/.xinitrc&lt;/code&gt; 或 &lt;code&gt;~/.xprofile&lt;/code&gt; 中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; XMODIFIERS=@im=fcitx
 &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; GTK_IM_MODULE=fcitx
 &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; QT_IM_MODULE=fcitx&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;设置启动：&lt;code&gt;cp /etc/xdg/autostart/fcitx-autostart.desktop ~/.config/autostart/&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终端输入法：fbterm&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  yaourt -S fbterm fcitx-fbterm
  &lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; gpasswd &lt;span class=&quot;hljs-operator&quot;&gt;-a&lt;/span&gt; YOUR_USERNAME video &lt;span class=&quot;hljs-comment&quot;&gt;#非根用户运行fbterm&lt;/span&gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; setcap &lt;span class=&quot;hljs-string&quot;&gt;&#39;cap_sys_tty_config+ep&#39;&lt;/span&gt; /usr/bin/fbterm 或：&lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; chmod u+s /usr/bin/fbterm &lt;span class=&quot;hljs-comment&quot;&gt;#非根用户可使用键盘快捷方式&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;# ~/.fbtermrc&lt;/span&gt;
  font-names = Consolas（Monaco）,微软雅黑
  font-size=&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;

  &lt;span class=&quot;hljs-comment&quot;&gt;# ~/.bashrc&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; [ &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$TERM&lt;/span&gt;&quot;&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&quot;linux&quot;&lt;/span&gt; ]; &lt;span class=&quot;hljs-keyword&quot;&gt;then&lt;/span&gt;  
  alias fbterm=&lt;span class=&quot;hljs-string&quot;&gt;&#39;LANG=zh_CN.UTF-8 fbterm&#39;&lt;/span&gt;  
  fbterm  
  &lt;span class=&quot;hljs-keyword&quot;&gt;fi&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;字体&lt;/h2&gt;
&lt;p&gt;可在AUR中直接安装 Ubuntu字体、开源字体、Adobe字体，甚至 Windows 字体。&lt;/p&gt;

</description>
				<pubDate>Thu, 07 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/linux/arch-install.html</link>
				<guid isPermaLink="true">http://harttle.github.io/linux/arch-install.html</guid>
			</item>
		
			<item>
				<title>Linux 连接 Windows Server VPN</title>
				<description>&lt;p&gt;Linux 连接 Windows Server VPN，以 archLinux 为例，适用于 Ubuntu。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装 pptp&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# kde in arch&lt;/span&gt;
 pacman -S extra/networkmanager-pptp&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新建 VPN 连接&lt;/p&gt;
&lt;p&gt; 网关：服务器IP或域名&lt;br&gt; 登录：用户名&lt;br&gt; 密码：密码&lt;br&gt; 域：空&lt;br&gt; 认证方式：MSCHAP MSCHAPv2&lt;br&gt; 使用 MPPE 加密&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Wed, 06 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/%E5%85%B6%E4%BB%96/vpn-linux-to-windows.html</link>
				<guid isPermaLink="true">http://harttle.github.io/%E5%85%B6%E4%BB%96/vpn-linux-to-windows.html</guid>
			</item>
		
			<item>
				<title>搜索引擎搭建</title>
				<description>&lt;p&gt;采用 heritix+pagerank+lucene 方式搭建搜索引擎原型，并评估其性能。&lt;/p&gt;
&lt;h1&gt;爬虫（Heritrix）&lt;/h1&gt;
&lt;p&gt;heritrix 是用作web归档的爬虫框架，java语言实现，具有 Apache License 自由软件许可。我们采用heritrix抓取网页数据。&lt;/p&gt;
&lt;p&gt;可参照官方 Guide：&lt;a href=&quot;https://webarchive.jira.com/wiki/display/Heritrix/Heritrix+3.0+and+3.1+User+Guide&quot;&gt;https://webarchive.jira.com/wiki/display/Heritrix/Heritrix+3.0+and+3.1+User+Guide&lt;/a&gt;&lt;/p&gt;
&lt;!--more--&gt;

&lt;h2&gt;依赖项&lt;/h2&gt;
&lt;p&gt;可选择 open-jdk 或者 oracle jre。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# open jdk&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; apt-get install open-jdk-&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# ubuntu&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; pacman -S open-jdk-&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;       &lt;span class=&quot;hljs-comment&quot;&gt;# arch linux&lt;/span&gt;
&lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; rpm -ivh open-jdk-&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;# centos&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;oracle jre 安装可参考 &lt;a href=&quot;http://www.liberiangeek.net/2012/04/install-oracle-java-runtime-jre-7-in-ubuntu-12-04-precise-pangolin/&quot;&gt;http://www.liberiangeek.net/2012/04/install-oracle-java-runtime-jre-7-in-ubuntu-12-04-precise-pangolin/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载并解压&lt;/p&gt;
&lt;p&gt; 在 &lt;a href=&quot;https://webarchive.jira.com/wiki/display/Heritrix/Heritrix&quot;&gt;https://webarchive.jira.com/wiki/display/Heritrix/Heritrix&lt;/a&gt; 可以得到最新的版本。下载后解压。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; tar -xzvf heritrix-xxx.tar.gz&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;设置环境变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# 在 ~/.bashrc 中加入以下环境变量&lt;/span&gt;
 &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; JAVA_HOME=/path/to/your/jre
 &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; HERITRIX_HOME=/path/to/your/heritrix
 &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; JAVA_OPTS=-Xmx1024M  &lt;span class=&quot;hljs-comment&quot;&gt;# 可选，指定使用的内存上限&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动 UI&lt;/p&gt;
&lt;p&gt; 参照：&lt;a href=&quot;https://webarchive.jira.com/wiki/display/Heritrix/A+Quick+Guide+to+Running+Your+First+Crawl+Job&quot;&gt;https://webarchive.jira.com/wiki/display/Heritrix/A+Quick+Guide+to+Running+Your+First+Crawl+Job&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$HERITRIX_HOME&lt;/span&gt;
 &lt;span class=&quot;hljs-comment&quot;&gt;# -a 设置用户名和密码，-j 设置抓取到的网页的路径，例如：&lt;/span&gt;
 bin/heritrix &lt;span class=&quot;hljs-operator&quot;&gt;-a&lt;/span&gt; harttle:&lt;span class=&quot;hljs-number&quot;&gt;123456&lt;/span&gt; -j /home/harttle/search-engine/pages/&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 然后在浏览器打开 &lt;a href=&quot;https://localhost:8843，登录后根据提示新建一个job。&quot;&gt;https://localhost:8843，登录后根据提示新建一个job。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;建立job后，可编辑 crawler-beans.cxml 文件进行设置。heritrix 支持在网页中直接编辑该文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该文件位于 -j 参数指定的路径/job-name/ 下，或者默认位置：$HERITRIX_HOME/jobs/job-name/。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;联系信息&lt;/p&gt;
&lt;p&gt;  设置 &lt;code&gt;metadata.operatorContactUrl&lt;/code&gt; 为包含你的联系信息的页面，方便网络管理员联系你。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;该属性将被用于填充 HTTP 请求的 &lt;code&gt;User-Agent&lt;/code&gt; 字段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;目标服务器&lt;/p&gt;
&lt;p&gt;  设置 &lt;code&gt;longerOverrides&lt;/code&gt; 中的 &lt;code&gt;prop&lt;/code&gt; 字段为要处理为web服务器域名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免heritrix下载媒体文件&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;scope&lt;/code&gt; 字段指定了heritrix的访问范围，为了避免访问媒体文件的 URI，可以编辑 &lt;code&gt;MatchesListRegexDecideRule&lt;/code&gt; 字段，采用如下设置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  &amp;lt;bean class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.archive.modules.deciderules.MatchesListRegexDecideRule&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;property name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;decision&quot;&lt;/span&gt; value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;REJECT&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;property name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;listLogicalOr&quot;&lt;/span&gt; value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;property name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;regexList&quot;&lt;/span&gt;&amp;gt;
     &amp;lt;list&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(avi|wmv|mpe?g|mp3))$&amp;lt;/value&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(rar|zip|tar|gz))$&amp;lt;/value&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(pdf|doc|xls|odt))$&amp;lt;/value&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(xml))$&amp;lt;/value&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(txt|conf|pdf))$&amp;lt;/value&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(swf))$&amp;lt;/value&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(js|css))$&amp;lt;/value&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(bmp|gif|jpe?g|png|svg|tiff?))$&amp;lt;/value&amp;gt;
       &amp;lt;value&amp;gt;.*(?i)(\.(docx?|xlsx?|pptx?))$&amp;lt;/value&amp;gt;
     &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只归档 &lt;code&gt;Content-Type&lt;/code&gt; 为 &lt;code&gt;text/html&lt;/code&gt; 的文件&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;warcWriter&lt;/code&gt; 字段指定了写入归档的规则，为了只匹配特定 &lt;code&gt;Content-Type&lt;/code&gt; 的文件，可以为该字段添加如下规则：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  &amp;lt;bean id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;warcWriter&quot;&lt;/span&gt; class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.archive.modules.writer.WARCWriterProcessor&quot;&lt;/span&gt;&amp;gt;
     &amp;lt;property name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;shouldProcessRule&quot;&lt;/span&gt;&amp;gt;
       &amp;lt;bean class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.archive.modules.deciderules.DecideRuleSequence&quot;&lt;/span&gt;&amp;gt;
         &amp;lt;property name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;rules&quot;&lt;/span&gt;&amp;gt;
           &amp;lt;list&amp;gt;
             &amp;lt;!-- Begin by REJECTing all... --&amp;gt;
             &amp;lt;bean class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.archive.modules.deciderules.RejectDecideRule&quot;&lt;/span&gt; /&amp;gt;
             &amp;lt;bean class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.archive.modules.deciderules.ContentTypeMatchesRegexDecideRule&quot;&lt;/span&gt;&amp;gt;
               &amp;lt;property name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;decision&quot;&lt;/span&gt; value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ACCEPT&quot;&lt;/span&gt; /&amp;gt;
               &amp;lt;property name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;regex&quot;&lt;/span&gt; value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;^text/html.*&quot;&lt;/span&gt; /&amp;gt;
             &amp;lt;/bean&amp;gt;
           &amp;lt;/list&amp;gt;
         &amp;lt;/property&amp;gt;
       &amp;lt;/bean&amp;gt;
     &amp;lt;/property&amp;gt;
     &amp;lt;!-- other properties --&amp;gt;
  &amp;lt;/bean&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动 heritrix&lt;/p&gt;
&lt;p&gt;  在 Web-based UI 中，依次执行 build、launch、unpause 即可启动 heritix。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;网站排名（Page-Rank）&lt;/h1&gt;
&lt;h2&gt;提取链接关系&lt;/h2&gt;
&lt;p&gt;我们现在要进行 Page-Rank，需要获得网页之间的链接关系。可以通过heritrix生成的日志文件（&lt;code&gt;crawl.log&lt;/code&gt;）来提取。&lt;/p&gt;
&lt;p&gt;参见：&lt;a href=&quot;https://webarchive.jira.com/wiki/display/Heritrix/Logs&quot;&gt;https://webarchive.jira.com/wiki/display/Heritrix/Logs&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;cat crawl.log | awk &lt;span class=&quot;hljs-string&quot;&gt;&#39;$7==&quot;text/html&quot;{print $6 &quot; =&amp;gt; &quot; $4}&#39;&lt;/span&gt; &amp;gt; links&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在我们得到了包含链接关系的文件 &lt;code&gt;links&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;进行 Page Rank&lt;/h2&gt;
&lt;p&gt;Page Rank 是 Google 搜索引擎进行网站排名的重要算法之一。&lt;a href=&quot;http://en.wikipedia.org/wiki/Pagerank&quot;&gt;wiki&lt;/a&gt; 给出了 Matlab 实现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;% Parameter M adjacency matrix where M_i,j represents the link from &#39;j&#39; to &#39;i&#39;, such that for all &#39;j&#39; sum(i, M_i,j) = 1&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;% Parameter d damping factor&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;% Parameter v_quadratic_error quadratic error for v&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;% Return v, a vector of ranks such that v_i is the i-th rank from [0, 1]&lt;/span&gt;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;[v]&lt;/span&gt; = &lt;span class=&quot;hljs-title&quot;&gt;rank&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(M, d, v_quadratic_error)&lt;/span&gt;&lt;/span&gt;

N = &lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;(M, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;% N is equal to half the size of M&lt;/span&gt;
v = &lt;span class=&quot;hljs-built_in&quot;&gt;rand&lt;/span&gt;(N, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
v = v ./ norm(v, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);
last_v = &lt;span class=&quot;hljs-built_in&quot;&gt;ones&lt;/span&gt;(N, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) * &lt;span class=&quot;hljs-built_in&quot;&gt;inf&lt;/span&gt;;
M_hat = (d .* M) + (((&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - d) / N) .* &lt;span class=&quot;hljs-built_in&quot;&gt;ones&lt;/span&gt;(N, N));

&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(norm(v - last_v, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &amp;gt; v_quadratic_error)
        last_v = v;
        v = M_hat * v;
        v = v ./ norm(v, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;);
&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;

endfunction

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;[v]&lt;/span&gt; = &lt;span class=&quot;hljs-title&quot;&gt;rank2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(M, d, v_quadratic_error)&lt;/span&gt;&lt;/span&gt;

N = &lt;span class=&quot;hljs-built_in&quot;&gt;size&lt;/span&gt;(M, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;); &lt;span class=&quot;hljs-comment&quot;&gt;% N is equal to half the size of M&lt;/span&gt;
v = &lt;span class=&quot;hljs-built_in&quot;&gt;rand&lt;/span&gt;(N, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);
v = v ./ norm(v, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);   &lt;span class=&quot;hljs-comment&quot;&gt;% This is now L1, not L2&lt;/span&gt;
last_v = &lt;span class=&quot;hljs-built_in&quot;&gt;ones&lt;/span&gt;(N, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) * &lt;span class=&quot;hljs-built_in&quot;&gt;inf&lt;/span&gt;;
M_hat = (d .* M) + (((&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - d) / N) .* &lt;span class=&quot;hljs-built_in&quot;&gt;ones&lt;/span&gt;(N, N));

&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(norm(v - last_v, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &amp;gt; v_quadratic_error)
        last_v = v;
        v = M_hat * v;  
        &lt;span class=&quot;hljs-comment&quot;&gt;% removed the L2 norm of the iterated PR&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;end&lt;/span&gt;

endfunction&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下是调用过程代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;M = &lt;span class=&quot;hljs-matrix&quot;&gt;[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; ; &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ; &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; ; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;;
rank(M, &lt;span class=&quot;hljs-number&quot;&gt;0.80&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0.001&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;Page Rank 的其他语言实现可以从 GitHub 获得：&lt;a href=&quot;https://github.com/louridas/pagerank&quot;&gt;https://github.com/louridas/pagerank&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;倒排索引（Lucene）&lt;/h1&gt;
&lt;p&gt;倒排索引（Inverted index）被广泛应用在搜索引擎中，它存储着在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。以下通过 Lucene 框架实现索引以及查询。&lt;/p&gt;
&lt;p&gt;官方 Guide：&lt;a href=&quot;http://lucene.apache.org/core/4_5_1/demo/overview-summary.html&quot;&gt;http://lucene.apache.org/core/4_5_1/demo/overview-summary.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;获取页面文件&lt;/h2&gt;
&lt;p&gt;在使用 Lucene 进行全文索引之前，我们需要得到包含页面文件的目录。下面的 shell 脚本将完成 &lt;code&gt;.warc.gz&lt;/code&gt; 到页面文件目录的转换。运行该脚本将产生 &lt;code&gt;files&lt;/code&gt; 目录，其中包含所有的页面文件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;页面文件将以编号命名，第一行为 URL，其后为 HTML 内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#!/bin/bash
&lt;/span&gt;
less *.warc.gz | sed &lt;span class=&quot;hljs-string&quot;&gt;&#39;s/\r//g&#39;&lt;/span&gt; &amp;gt; pages.txt

[ ! &lt;span class=&quot;hljs-operator&quot;&gt;-d&lt;/span&gt; files ] &amp;amp;&amp;amp; mkdir files

&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;read&lt;/span&gt; -r line
&lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;hljs-built_in&quot;&gt;let&lt;/span&gt; i++
    lines[&lt;span class=&quot;hljs-variable&quot;&gt;$i&lt;/span&gt;]=&lt;span class=&quot;hljs-variable&quot;&gt;$line&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt; &amp;lt; pages.txt

nline=&lt;span class=&quot;hljs-variable&quot;&gt;$i&lt;/span&gt;

url=&lt;span class=&quot;hljs-string&quot;&gt;&#39;&#39;&lt;/span&gt;
state=&lt;span class=&quot;hljs-string&quot;&gt;&#39;none&#39;&lt;/span&gt;
ndoc=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (( i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;i&amp;lt;=nline;i++ ))
&lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt;
    line=&lt;span class=&quot;hljs-variable&quot;&gt;${lines[$i]}&lt;/span&gt;

    &lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$line&lt;/span&gt;&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;WARC/1.0&quot;&lt;/span&gt;)
            state=&lt;span class=&quot;hljs-string&quot;&gt;&#39;warc&#39;&lt;/span&gt;
            ;;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;WARC-Type: response&quot;&lt;/span&gt;)
            state=&lt;span class=&quot;hljs-string&quot;&gt;&#39;warc-valid&#39;&lt;/span&gt;
            url=&lt;span class=&quot;hljs-variable&quot;&gt;${lines[$i+1]}&lt;/span&gt;
            url=&lt;span class=&quot;hljs-variable&quot;&gt;${url#*: }&lt;/span&gt;
            &lt;span class=&quot;hljs-built_in&quot;&gt;let&lt;/span&gt; ndoc++
            &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$url&lt;/span&gt; &amp;gt;&amp;gt; files/&lt;span class=&quot;hljs-variable&quot;&gt;$ndoc&lt;/span&gt;
            &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &amp;gt;&amp;gt; files/&lt;span class=&quot;hljs-variable&quot;&gt;$ndoc&lt;/span&gt;
            ;;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/span&gt;)
            [ &lt;span class=&quot;hljs-variable&quot;&gt;$state&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&#39;warc-valid&#39;&lt;/span&gt; ] &amp;amp;&amp;amp; state=&lt;span class=&quot;hljs-string&quot;&gt;&#39;http&#39;&lt;/span&gt;
            ;;
        &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&lt;/span&gt;)
            [ &lt;span class=&quot;hljs-variable&quot;&gt;$state&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&#39;http&#39;&lt;/span&gt; ] &amp;amp;&amp;amp; state=&lt;span class=&quot;hljs-string&quot;&gt;&#39;doc&#39;&lt;/span&gt;
            ;;
        *)
            [ &lt;span class=&quot;hljs-variable&quot;&gt;$state&lt;/span&gt; = &lt;span class=&quot;hljs-string&quot;&gt;&#39;doc&#39;&lt;/span&gt; ] &amp;amp;&amp;amp; &lt;span class=&quot;hljs-built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-variable&quot;&gt;$line&lt;/span&gt; &amp;gt;&amp;gt; files/&lt;span class=&quot;hljs-variable&quot;&gt;$ndoc&lt;/span&gt;
            ;;
    &lt;span class=&quot;hljs-keyword&quot;&gt;esac&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;建立索引&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装与配置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# 下载后解压&lt;/span&gt;
 tar -xzvf lucene-xxx.tar.gz
 &lt;span class=&quot;hljs-built_in&quot;&gt;cd&lt;/span&gt; lucene

 &lt;span class=&quot;hljs-comment&quot;&gt;# 设置环境变量，直接加入所有的 jar 包&lt;/span&gt;
 dir=`&lt;span class=&quot;hljs-built_in&quot;&gt;pwd&lt;/span&gt;`
 &lt;span class=&quot;hljs-keyword&quot;&gt;export&lt;/span&gt; CLASSPATH=`find -name &lt;span class=&quot;hljs-string&quot;&gt;&#39;*.jar&#39;&lt;/span&gt; | sed &lt;span class=&quot;hljs-string&quot;&gt;&quot;s@^.@&lt;span class=&quot;hljs-variable&quot;&gt;$dir&lt;/span&gt;@g&quot;&lt;/span&gt; | sed &lt;span class=&quot;hljs-string&quot;&gt;&#39;:a;N;s/\n/:/;ta&#39;&lt;/span&gt;`&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建立索引与搜索&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-comment&quot;&gt;# 建立索引，files 为页面文件所在目录，会在当前目录产生 index 目录来保存索引信息&lt;/span&gt;
 java org.apache.lucene.demo.IndexFiles -docs files

 &lt;span class=&quot;hljs-comment&quot;&gt;# 搜索，将进入交互式搜索程序&lt;/span&gt;
 java org.apache.lucene.demo.SearchFiles&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Tue, 05 Nov 2013 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/web/se-project.html</link>
				<guid isPermaLink="true">http://harttle.github.io/web/se-project.html</guid>
			</item>
		
			<item>
				<title>算法导论</title>
				<description>&lt;h1&gt;基础知识&lt;/h1&gt;
&lt;h2&gt;算法基础&lt;/h2&gt;
&lt;h3&gt;插入排序&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//INSERTION-SORT(A)&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; to A.length
    key = A[j]
    &lt;span class=&quot;hljs-comment&quot;&gt;//Insert A[j] into the sorted sequence A[1..j-1]&lt;/span&gt;
    i = j - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; 
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; and A[i] &amp;gt; key
        A[i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = A[i]
        i = i - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    A[i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = key&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;循环不变式：初始化、保持、终止&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;分析算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单处理器计算模型：随机访问机（random-access machine，RAM）：算数指令、数据移动指令、控制指令。&lt;/li&gt;
&lt;li&gt;最坏情况、平均情况、增长量级&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;

&lt;h3&gt;设计算法&lt;/h3&gt;
&lt;h4&gt;分治法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;将原问题分解为几个规模较小但类似于原问题的子问题，递归地求解这些子问题，然后再合并这些子问题的解来建立原问题的解。&lt;/li&gt;
&lt;li&gt;步骤：分解、解决、合并&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//MERGE(A,p,q,r)&lt;/span&gt;
n1 = q - p + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
n2 = r - q
let L[&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n1+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] and R[&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n2+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] be &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; arrays
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n1
    L[i]=A[p+i-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n2
    R[j] = A[q+j]
L[n1+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = MAX
R[n2+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = MAX
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k = p to r
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; L[i] &amp;lt;= R[j]
        A[k] = L[i]
        i = i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;
        A[k] = R[j]
        j = j+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//MERGE-SORT(A,p,r)&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; p&amp;lt;r
    q=(p+r)/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;
    MERGE-SORT(A,p,q)
    MERGE-SORT(A,q+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,r)
    MERGE(A,p,q,r)&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;分析分支算法&lt;/h4&gt;
&lt;p&gt;归并排序算法的分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分解：计算子数组的中间位置，D(n) = O(1)&lt;/li&gt;
&lt;li&gt;解决：求解规模为n/2的子问题，将贡献 2T(n/2) 的运行时间&lt;/li&gt;
&lt;li&gt;合并：C(n) = O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最坏情况运行时间&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n)=
 \begin{cases}
O(1)=c, n=1\\
2T(n/2)+O(n)=2T(n/2)+cn, n&amp;gt;1
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n)=\Theta(n\lg n)\)&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;函数的增长&lt;/h2&gt;
&lt;h3&gt;渐进记号&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta\)&lt;/span&gt;：渐进地给出一个函数的上界和下界&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;mathjax&quot;&gt;\(O\)&lt;/span&gt;：只有一个渐进上界&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Omega\)&lt;/span&gt;：只有一个渐进下界&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;mathjax&quot;&gt;\(o\)&lt;/span&gt;：非渐进紧确的上界&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\omega\)&lt;/span&gt;：非渐进紧确的下界&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;标准记号与常用函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单调性&lt;/li&gt;
&lt;li&gt;向下取整与向上取整&lt;/li&gt;
&lt;li&gt;模运算&lt;/li&gt;
&lt;li&gt;多项式&lt;/li&gt;
&lt;li&gt;指数&lt;/li&gt;
&lt;li&gt;对数&lt;/li&gt;
&lt;li&gt;阶乘&lt;/li&gt;
&lt;li&gt;多重函数：重复多次作用在初值上&lt;/li&gt;
&lt;li&gt;多重对数函数&lt;/li&gt;
&lt;li&gt;斐波那契数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;分治策略&lt;/h2&gt;
&lt;p&gt;在分治策略中，我们递归地求解一个问题，在每层递归中应用如下三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分解（divide）&lt;/li&gt;
&lt;li&gt;解决（conquer）&lt;/li&gt;
&lt;li&gt;合并（combine）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三种求解递归式的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代入法：猜测一个界，用数学归纳法证明&lt;/li&gt;
&lt;li&gt;递归树法：将递归式转换为一棵树，级数求和&lt;/li&gt;
&lt;li&gt;主方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;最大子数组问题&lt;/h3&gt;
&lt;h4&gt;暴力求解：&lt;span class=&quot;mathjax&quot;&gt;\(\Omega(n^2)\)&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;分治策略求解&lt;/h4&gt;
&lt;p&gt;任何连续数组所处的位置必然是以下三种之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全位于左子数组&lt;/li&gt;
&lt;li&gt;完全位于右子数组&lt;/li&gt;
&lt;li&gt;跨越了中点：可在线性时间内求出跨越中点的最大子数组&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;运行时间&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n)=\Theta(n\lg n)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;矩阵乘法的 Strassen 算法&lt;/h3&gt;
&lt;h4&gt;直接计算&lt;/h4&gt;
&lt;p&gt;SQUARE-MATRIX-MULTIPLY：&lt;span class=&quot;mathjax&quot;&gt;\(T(n)=\Theta(n^3)\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;简单的分治算法&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n)=\Theta(n^3)\)&lt;/span&gt;，简单的分治算法并不由于直接的SQUARE-MATRIX-MULTIPLY过程。&lt;/p&gt;
&lt;h4&gt;Strassen 算法&lt;/h4&gt;
&lt;p&gt;Strassen算法包括四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将输入矩阵A、B和输出矩阵C分解为&lt;span class=&quot;mathjax&quot;&gt;\(n/2\times n/2\)&lt;/span&gt;的子矩阵。采用下标计算，时间为&lt;span class=&quot;mathjax&quot;&gt;\(\Omega(n^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;创建10个&lt;span class=&quot;mathjax&quot;&gt;\(n/2\times n/2\)&lt;/span&gt;的子矩阵&lt;span class=&quot;mathjax&quot;&gt;\(S_1,~S_2,~...,~S_{10}\)&lt;/span&gt;，每个矩阵保存1中创建的两子矩阵和或差&lt;/li&gt;
&lt;li&gt;使用1中的子矩阵和2中的10个矩阵，递归地计算7个矩阵积&lt;span class=&quot;mathjax&quot;&gt;\(P_1,~P_2,~...,~P_{7}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;通过 &lt;span class=&quot;mathjax&quot;&gt;\(P_i\)&lt;/span&gt; 矩阵的不同组合进行加减运算，计算出结果矩阵C的子矩阵&lt;span class=&quot;mathjax&quot;&gt;\(C_{11},~C_{12},~C_{21},~C_{22}\)&lt;/span&gt;，花费时间：&lt;span class=&quot;mathjax&quot;&gt;\(\Omega(n^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;递归式：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n)=
 \begin{cases}
O(1)=c, n=1\\
7T(n/2)+O(n)=2T(n/2)+cn, n&amp;gt;1
\end{cases}\)&lt;/span&gt;&lt;br&gt;根据主方法，得到该递归式的解为&lt;span class=&quot;mathjax&quot;&gt;\(\Omega(n^{\lg 7})\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;使用主方法求解递归式&lt;/h3&gt;
&lt;p&gt;对于递归式&lt;span class=&quot;mathjax&quot;&gt;\(T(n)=aT(n/b)+f(n)\)&lt;/span&gt;，将函数&lt;span class=&quot;mathjax&quot;&gt;\(f(n)\)&lt;/span&gt;与&lt;span class=&quot;mathjax&quot;&gt;\(n^{\log_ba}\)&lt;/span&gt;进行比较：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若&lt;span class=&quot;mathjax&quot;&gt;\(f(n)\)&lt;/span&gt;更大（在多项式意义上），解为&lt;span class=&quot;mathjax&quot;&gt;\(\Omega(f(n))\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;若&lt;span class=&quot;mathjax&quot;&gt;\(n^{\log_ba}\)&lt;/span&gt;更大，解为&lt;span class=&quot;mathjax&quot;&gt;\(\Omega(n^{\log_ba})\)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;若大小相当，解为&lt;span class=&quot;mathjax&quot;&gt;\(\Omega(f(n)\lg n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;概率分析和随机算法&lt;/h2&gt;
&lt;h3&gt;雇用问题&lt;/h3&gt;
&lt;p&gt;假设应聘办公助理的候选人编号为1到n，在面试完应聘者i后，如果他比目前的办公助理更合适，就会辞掉当前的办公助理，然后聘用他。估算雇佣过办公助理的总费用（雇佣一个办公助理费用为&lt;span class=&quot;mathjax&quot;&gt;\(c_h\)&lt;/span&gt;）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;HIRE-ASSISTENT(n)
best = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//candidate 0 is a least-qualified dummy candidate&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
    interview candidate i
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; candidate i is better than candidate best
        best = i
        hire candidate i&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;最坏的情形&lt;/h4&gt;
&lt;p&gt;总费用为&lt;span class=&quot;mathjax&quot;&gt;\(O(c_hn)\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;平均情形&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;平均情况运行时间：概率分布在算法的输入上&lt;/li&gt;
&lt;li&gt;期望运行时间：算法本身做出随机选择&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指示器随机变量&lt;/h3&gt;
&lt;p&gt;给定样本空间S和一个事件A，那么事件A对应的 &lt;strong&gt;指示器随机变量&lt;/strong&gt;&lt;span class=&quot;mathjax&quot;&gt;\(I\{A\}\)&lt;/span&gt;定义为：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(I\{A\}=
\begin{cases}
1,~if~A~happened\\
0,~if~A~didn&amp;#39;t~happen
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举一个简单的例子，我们来确定抛掷硬币时正面朝上的期望次数。样本空间为&lt;span class=&quot;mathjax&quot;&gt;\(S=\{H, T\}\)&lt;/span&gt;，其中&lt;span class=&quot;mathjax&quot;&gt;\(Pr\{H\}=Pr\{T\}=1/2\)&lt;/span&gt;，指示器随机变量&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(X_H=I\{H\}=
\begin{cases}
1,~if~H~happened\\
0,~if~T~happened
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在一次抛掷中，正面朝上的期望次数为指示器变量&lt;span class=&quot;mathjax&quot;&gt;\(X_H\)&lt;/span&gt;的期望值：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(E[X_H]=E[I\{H\}]=1\cdot Pr\{H\} + 0\cdot Pr\{T\} = 1\cdot (1/2)+ 0\cdot (1/2)=1/2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;n次抛掷中出现正面的总次数&lt;span class=&quot;mathjax&quot;&gt;\(X=\sum_{i=1}^n X_i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;正面朝上次数的期望 &lt;span class=&quot;mathjax&quot;&gt;\(E[X]=E\left[\sum_{i=1}^n X_i \right] = \sum_{i=1}^n E[X_i] = \sum_{i=1}^n 1/2 = n/2\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;用指示器随机变量分析雇用问题&lt;/h4&gt;
&lt;p&gt;应聘者i比1到i-1更有资格的概率为1/i，因而&lt;span class=&quot;mathjax&quot;&gt;\(E[X_i]=1/i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;故雇佣总数为 &lt;span class=&quot;mathjax&quot;&gt;\(E[X] = E\left[\sum^n_{i=1} X_i \right] = \sum_{i=1}^n 1/i = \ln n\)&lt;/span&gt;，雇佣费用平均情形下为&lt;span class=&quot;mathjax&quot;&gt;\(O(c_h \ln n)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;随机算法&lt;/h3&gt;
&lt;p&gt;算法中的随机排列使得输入次序不再相关，因而没有特别的输入会引出它的最坏情况行为。&lt;/p&gt;
&lt;p&gt;对于雇用问题，只需要随机地变换应聘者序列&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;RANDOMIZED-HIRE-ASSISTANT(n)
randomly permute the &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; of candidates
best = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//candidate 0 is a least-qualified dummy candidate&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
    interview candidate i
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; candidate i is better than candidate best
        best = i
        hire candidate i&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;产生 &lt;strong&gt;均匀随机排列&lt;/strong&gt; （等可能地产生数字1~n的每一种排列）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;PERMUTE-BY-SORTING(A)
n = A.length
let P[&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;..n] be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
    P[i] = RANDOM(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, n**&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)
sort A, &lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; P as sort keys&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 可以证明，P中所有元素都唯一的概率至少是 &lt;span class=&quot;mathjax&quot;&gt;\(1-1/n\)&lt;/span&gt;。假设所有优先级都不同，则过程PERMUTE-BY-SORTING产生输入的均匀随机排列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;RANDOMIZE-IN-PLACE(A)
n = A.length
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i =&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
    swap A[i] with A[RANDOM(i, n)]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以证明，过程RANDOMIZE-IN-PLACE可计算出一个均匀随机排列。&lt;/p&gt;
&lt;p&gt;具有n个元素的 &lt;strong&gt;k排列&lt;/strong&gt;（k-permutation）是包含这n个元素中的k个元素的序列，并且不重复，一共有 &lt;span class=&quot;mathjax&quot;&gt;\(n!/(n-k)!\)&lt;/span&gt;种可能的k排列。&lt;/p&gt;
&lt;h1&gt;排序和顺序统计量&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;待排序的项称为 &lt;strong&gt;记录&lt;/strong&gt;（record），每个记录包含一个 &lt;strong&gt;关键字&lt;/strong&gt;（key），即排序问题中要重排的值，记录的剩余部分由 &lt;strong&gt;卫星数据&lt;/strong&gt;（statellite data）组成。&lt;/li&gt;
&lt;li&gt;如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法是 &lt;strong&gt;原址的&lt;/strong&gt;（in place）。插入排序可以在&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^2)\)&lt;/span&gt;时间内将n个数排好序，是一种非常快的原址排序算法；归并排序有更好的渐近运行时间&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n\lg n)\)&lt;/span&gt;，但它使用的MERGE过程并不是原址的。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;最坏情况运行时间&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;平均情况/期望运行时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;插入排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归并排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n\lg n)\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n\lg n)\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;堆排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(O(n\lg n)\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;—&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;快速排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n\lg n)\)&lt;/span&gt;（期望）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计数排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(k+n)\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(k+n)\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基数排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(d(n+k))\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(d(n+k))\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;桶排序&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;（平均情况）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;堆排序&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;th&gt;空间原址性&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;插入排序&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;mathjax&quot;&gt;\(O(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归并排序&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;mathjax&quot;&gt;\(O(n\lg n)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;堆排序&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;mathjax&quot;&gt;\(O(n\lg n)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;堆&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;计算父节点、左右孩子节点下标&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;  PARENT(i)
      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;

  LEFT(i)
      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;i

  RIGHT(i)
      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最大堆&lt;/strong&gt;&lt;br&gt;  除了根以外的所有节点 i 满足：&lt;span class=&quot;mathjax&quot;&gt;\(A[\rm{PARENT}(i)]\geq A[i]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小堆&lt;/strong&gt;&lt;br&gt;  除了根以外的所有节点 i 满足：&lt;span class=&quot;mathjax&quot;&gt;\(A[\rm{PARENT}(i)]\leq A[i]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对于完全二叉树，叶节点数 = 非叶节点数 或 非叶节点数+1&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;维护堆的性质&lt;/h3&gt;
&lt;p&gt; MAX-HEAPIFY(A, i) 通过逐级下降，使得下标为 i 的根节点的子树符合最大堆的性质&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;MAX-HEAPIFY(A, i)
l = LEFT(i)
r = RIGHT(i)
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; l &amp;lt;= A.heap-size and A[l] &amp;gt; A[i]
    largest = l
&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;
    largest = i
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; r &amp;lt;= A.heap-size and A[r] &amp;gt; A[largest]
    largest = r
&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; largest != i
    exchange A[i] with A[largest]
    MAX-HEAPIFY(A, largest)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每个孩子的子树的大小最多为 &lt;span class=&quot;mathjax&quot;&gt;\(2n/3\)&lt;/span&gt;（最坏情况发生在树的最底层半满的时候），故MAX-HEAPIFY运行时间&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n) \leq T(2n/3) + \Theta(1)\)&lt;/span&gt;，解为&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = O(\lg n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;建堆&lt;/h3&gt;
&lt;p&gt;BUILD-MAX-HEAP 把大小为 n = A.length 的数组 A[1..n] 转换为最大堆。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;BUILD-MAX-HEAP(A)
    A.heap-size = A.length
    &lt;span class=&quot;hljs-comment&quot;&gt;// 子数组 $A(n/2+1..n)$ 中的元素都是叶节点&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = A.length/&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; downto &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        MAX-HEAPIFY(A, i)&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;渐近上界&lt;br&gt;  BUILD-MAX-HEAP 需要调用MAX-HEAPIFY O(n) 次，故总的时间复杂度为 &lt;span class=&quot;mathjax&quot;&gt;\(O(n\lg n)\)&lt;/span&gt;，或者&lt;span class=&quot;mathjax&quot;&gt;\(O(nh)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;更加紧确&lt;br&gt;  含n个元素的堆高度为 &lt;span class=&quot;mathjax&quot;&gt;\(\lfloor \lg n\rfloor\)&lt;/span&gt;，高度为h的元素数最多为 &lt;span class=&quot;mathjax&quot;&gt;\(\lceil n/2^{h+1} \rceil\)&lt;/span&gt;，于是 BUILD-MAX-HEAP的时间复杂度为&lt;br&gt;  &lt;span class=&quot;mathjax&quot;&gt;\(O\left( \sum_{h=0}^{\lfloor \lg n\rfloor} \lceil n/2^{h+1} \rceil O(h) \right) = O\left(n\sum_{h=0}^{\lfloor \lg n\rfloor}\frac{h}{2^h}\right) = O\left(n\sum_{h=0}^{\infty}\frac{h}{2^h}\right) = O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;堆排序算法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;HEAPSORT(A)
    BUILD-MAX-HEAP(A)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = A.length downto &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;
        exchange A[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] wiith A[i]
        A.heap-size = A.heap-size - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        MAX-HEAPIFY(A, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;MAX-HEAPIFY 时间复杂度为 &lt;span class=&quot;mathjax&quot;&gt;\(O(\lg n)\)&lt;/span&gt;，被HEAPSORT n-1 次调用，故 HEAPSORT 的时间复杂度为 &lt;span class=&quot;mathjax&quot;&gt;\(O(n\lg n)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;优先队列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优先队列&lt;/strong&gt; 是一种用来维护由一组元素构成的集合S的数据结构，每个元素有一个相关的值，称为 &lt;strong&gt;关键字&lt;/strong&gt;（key）。优先队列同样有两种形式： &lt;strong&gt;最大优先队列&lt;/strong&gt;和 &lt;strong&gt;最小优先队列&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;一个最大优先队列支持以下操作：&lt;ul&gt;
&lt;li&gt;INSERT(S, x)：把元素x插入集合S中。&lt;/li&gt;
&lt;li&gt;MAXINUM(S)：返回S中具有最大关键字的元素。&lt;/li&gt;
&lt;li&gt;EXTRACT-MAX(S)：去掉并返回S中具有最大关键字的元素。&lt;/li&gt;
&lt;li&gt;INCREASE-KEY(S, x, k)：将元素x的关键字值加到k&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最大优先队列用于共享计算机系统的作业调度，最小优先队列用于基于事件驱动的模拟器（关键字为事件发生时间）。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;HEAP-MAXINUM(A)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; A[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]

HEAP-EXTRACT-MAX(A)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; A.heap-size &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        error &lt;span class=&quot;hljs-string&quot;&gt;&quot;heap underflow&quot;&lt;/span&gt;
    max = A[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]
    A[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = A[A.heap-size]
    A.heap-size = A.heap-size - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    MAX-HEAPIFY(A, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; max&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;HEAP-EXTRACT-MAX 的时间复杂度为 &lt;span class=&quot;mathjax&quot;&gt;\(O(\lg n)\)&lt;/span&gt;（取决于MAX-HEAPIFY的时间复杂度）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;HEAP-INCREASE-KEY(A, i, key)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; key &amp;lt; A[i]
        error &lt;span class=&quot;hljs-string&quot;&gt;&quot;new key is smaller than current key&quot;&lt;/span&gt;
    A[i] = key
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; i &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; and A[PARENT(i)] &amp;lt; A[i]
        exchange A[i] with A[PARENT(i)]
        i = PARENT(i)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;HEAP-INCREASE-KEY 中当前元素不断与父元素比较，当前元素大则将二者交换，直至当前元素的关键字小于父节点。时间复杂度为&lt;span class=&quot;mathjax&quot;&gt;\(O(\lg n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;MAX-HEAP-INSERT(A, key)
    A.heap-size = A.heap-size + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    A[A.heap-size] = - MAX_INT
    HEAP-INCREASE-KEY(A, A.heap-size, key)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;MAX-HEAP-INSERT的时间复杂度为&lt;span class=&quot;mathjax&quot;&gt;\(O(\lg n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;快速排序&lt;/h2&gt;
&lt;p&gt;快速排序的时间复杂度为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n\lg n)\)&lt;/span&gt;，能够进行原址排序。&lt;/p&gt;
&lt;h3&gt;快速排序的描述&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;QUICKSORT(A, p, r)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; p &amp;lt; r    
        q = PARTITION(A, p, r)
        QUICKSORT(A, p, q-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
        QUICKSORT(A, q+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, r)

&lt;span class=&quot;hljs-comment&quot;&gt;//将数组分为两部分，返回临界值下标&lt;/span&gt;
PARTITION(A, p, r)
    x = A[r]    &lt;span class=&quot;hljs-comment&quot;&gt;//以最后一个数为主元（pivot element）&lt;/span&gt;
    i = p-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//小于主元子数组的下标上限&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j = p to r-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; A[j] &amp;lt;= x
            i = i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;//增加小于主元子数组的大小&lt;/span&gt;
            exchange A[i] with A[j]    &lt;span class=&quot;hljs-comment&quot;&gt;//将A[j]加入小于主元的子数组&lt;/span&gt;
    exchange A[i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] with A[r]    &lt;span class=&quot;hljs-comment&quot;&gt;//将主元从数组末尾移动至子数组之间&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; i + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了排序一个数组A，初始调用为：QUICKSORT(A, 1, A.length)。&lt;/p&gt;
&lt;h3&gt;快速排序的性能&lt;/h3&gt;
&lt;h4&gt;最坏情况&lt;/h4&gt;
&lt;p&gt;当划分产生的两个子问题分别包含 n-1 和 0 个元素时，最坏情况发生。划分操作的时间复杂度为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(T(0)=\Theta(1)\)&lt;/span&gt;，这时算法运行时间的递归式为&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = T(n-1) + T(0) + \Theta(n) = T(n-1) + \Theta(n)\)&lt;/span&gt;，解为&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = \Theta(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;最好情况划分&lt;/h4&gt;
&lt;p&gt;当划分产生的两个子问题分别包含&lt;span class=&quot;mathjax&quot;&gt;\(\lfloor n/2 \rfloor\)&lt;/span&gt;和&lt;span class=&quot;mathjax&quot;&gt;\(\lceil n/2 \rceil-1\)&lt;/span&gt;个元素时，最好情况发生。算法运行时间递归式为&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = 2T(n/2) + \Theta(n)\)&lt;/span&gt;，解为&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = \Theta(n\lg n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;平衡的划分&lt;/h4&gt;
&lt;p&gt;只要划分是常数比例的，算法的运行时间总是&lt;span class=&quot;mathjax&quot;&gt;\(O(n\lg n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设按照 9:1 划分，每层代价之多为 cn，递归深度为 &lt;span class=&quot;mathjax&quot;&gt;\(\log_{10/9}n = \Theta(\lg n)\)&lt;/span&gt;，故排序的总代价为&lt;span class=&quot;mathjax&quot;&gt;\(O(n\lg n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;对平均情况的直观观察&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对于一次差的划分接着一个好的划分，将产生三个大小为 0、(n-1)/2-1 和 (n-1)/2 的子数组，划分代价为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n) + \Theta(n-1) = \Theta(n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;对于一次好的划分，将产生两个大小为 (n-1)/2 的子数组，划分代价为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从直观上看，差划分引起的二次划分代价&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n-1)\)&lt;/span&gt;可以被吸收到差划分代价&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;中去，而得到与好划分一样好的结果。&lt;/p&gt;
&lt;h3&gt;快速排序的随机化版本&lt;/h3&gt;
&lt;p&gt;可以通过在算法中引入随机性，使得算法对所有输入都能获得较好的期望性能。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//新的划分程序，只是在真正进行划分前进行一次交换&lt;/span&gt;
RANDOMIZED-PARTITION(A, p, r)
    i = RANDOM(p, r)
    exchange A[r] with A[i]
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; PARTITION(A, p, r)&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;快速排序分析&lt;/h3&gt;
&lt;h4&gt;最坏情况分析&lt;/h4&gt;
&lt;p&gt;使用代入法证明快速排序的时间复杂度为&lt;span class=&quot;mathjax&quot;&gt;\(O(n^2)\)&lt;/span&gt;。假设T(n)为最坏情况下 QUICKSORT 在输入规模为 n 的数据集合上所花费的时间，则有&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = \max_{0\leq q \leq n-1}(T(q) + T(n-q-1)) + \Theta(n)\)&lt;/span&gt;&lt;br&gt;将&lt;span class=&quot;mathjax&quot;&gt;\(T(n)\leq cn^2\)&lt;/span&gt;带入右侧，得到&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n) \leq \max_{0\leq q \leq n-1}(cq^2 + c(n-q-1)^2) + \Theta(n) = cn^2 - c(2n-1) + \Theta(n) \leq cn^2\)&lt;/span&gt;。&lt;br&gt;故&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = O(n^2)\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;期望运行时间&lt;/h4&gt;
&lt;p&gt;设 PARTITION 的第4行所做的比较操作次数为X，则 QUICKSORT 的运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(O(n+X)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 PARTITION 至多被调用n次，每次调用包括固定的工作量和for循环，for循环都要执行第4行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们考察第四行的比较操作的实际执行次数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将数组A的元素重命名为&lt;span class=&quot;mathjax&quot;&gt;\(z_1,~z_2,~...,~z_n\)&lt;/span&gt;，其中&lt;span class=&quot;mathjax&quot;&gt;\(z_i\)&lt;/span&gt;表示第i小的元素。&lt;/li&gt;
&lt;li&gt;定义&lt;span class=&quot;mathjax&quot;&gt;\(Z_{ij} = \{ z_i~,z_{i+1},~...,~z_j \}\)&lt;/span&gt;为&lt;span class=&quot;mathjax&quot;&gt;\(z_i\)&lt;/span&gt;和&lt;span class=&quot;mathjax&quot;&gt;\(z_j\)&lt;/span&gt;之间元素的集合。&lt;/li&gt;
&lt;li&gt;定义指示器随机变量&lt;span class=&quot;mathjax&quot;&gt;\(X_{ij} = I(z_i compared with z_j)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因每一对元素至多比较一次，故总的比较次数：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(X=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}X_{ij}\)&lt;/span&gt;，&lt;br&gt;总比较次数的期望：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(E(X) = \sum_{i=1}^{n-1}\sum_{j=i+1}^{n}Pr(z_i~compared~with~z_j)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(z_i\)&lt;/span&gt;与&lt;span class=&quot;mathjax&quot;&gt;\(z_j\)&lt;/span&gt;进行比较，当且仅当&lt;span class=&quot;mathjax&quot;&gt;\(Z_ij\)&lt;/span&gt;（共j-i+1个元素）中被选中的第一个主元为&lt;span class=&quot;mathjax&quot;&gt;\(z_i\)&lt;/span&gt;或&lt;span class=&quot;mathjax&quot;&gt;\(z_j\)&lt;/span&gt;，即：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(Pr(z_i~compared~with~z_j) = \frac{2}{j-i+1}\)&lt;/span&gt;&lt;br&gt;故总比较次数期望：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(E(X) = \sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac{2}{j-i+1} \lt \sum_{i=1}^{n-1}\sum_{k=1}^{n}\frac{2}{k} = \sum_{i=1}^{n-1}O(\lg n) = O(n\lg n)\)&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;线性时间排序&lt;/h2&gt;
&lt;h3&gt;比较排序算法的下界&lt;/h3&gt;
&lt;p&gt;比较排序可以被抽象为一棵 &lt;strong&gt;决策树&lt;/strong&gt;。决策树是一棵完全二叉树，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在决策树中，每个内部结点以被比较数的下标 i:j 标记，每个叶节点都标注一个序列。排序算法的执行对应于一条从根节点到叶节点的路径，每个内部结点表示一次比较，左子树表示 a[i]&amp;lt;=a[j]的后续比较，右子树表示a[i]&amp;gt;a[j]的后续比较。如图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pic002.cnblogs.com/images/2012/369370/2012081216212084.gif&quot; alt=&quot;决策树模型&quot;&gt;&lt;/p&gt;
&lt;p&gt;在最坏情况下，任何比较排序算法都需要做 &lt;span class=&quot;mathjax&quot;&gt;\(\Omega(n\lg n)\)&lt;/span&gt; 次比较。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;因为输入数据的 n! 中可能的情况都必须出现在叶节点，故 &lt;span class=&quot;mathjax&quot;&gt;\(n! \leq 2^h\)&lt;/span&gt; ，即 &lt;span class=&quot;mathjax&quot;&gt;\(h \geq \lg(n!) = \Theta(n\lg n)\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(h=\Omega(n\lg n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;比较算法最坏情况下的比较次数等于其决策树的高度。&lt;/li&gt;
&lt;li&gt;堆排序和归并排序都是渐近最优的比较排序算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3&gt;计数排序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;计数排序&lt;/strong&gt;假设n个输入元素均为[0, k]的整数，当 k=O(n) 时，排序的运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计数排序的基本思想是：对每一个输入x，确定小于x的元素个数，然后把x直接放到输出数组的相应位置上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;COUNTING-SORT(A, B, k)
let C[&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;.k] be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; to k
    C[i] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to A.length
    C[A[j]]=C[A[j]]+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;hljs-comment&quot;&gt;//now C[i] contains the number of elements equal to i&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to k
    C[i]=C[i]+C[i-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]
&lt;span class=&quot;hljs-comment&quot;&gt;//now C[i] contains the number of elements &amp;lt;= i&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j = A.length downto &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    B[C[A[j]]]=A[j]
    C[A[j]]=C[A[j]]-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;计数排序遍历了两次A和C，故总时间代价为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(k+n)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;计数排序是  &lt;strong&gt;稳定的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基数排序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;基数排序&lt;/strong&gt; 先按 &lt;em&gt;最低有效位&lt;/em&gt; 进行排序，之后用同样的方法按次低有效位进行排序，直至所有数都排好。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;计数排序是一种用在卡片排序机上的算法，因卡片机需要排成一排而不能从高位递归地排序。&lt;/li&gt;
&lt;li&gt;为了确保基数排序的正确性，一位数排序算法必须是稳定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;RADIX-SORT(A, d)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to d
        use a stable sort to sort &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt; A on digit i&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;给定n个k进制d位数，如果使用的稳定排序算法耗时&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n+k)\)&lt;/span&gt;，那么RADIX-SORT的时间代价为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(d(n+k))\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;给定一个b位2进制数（k=2）和正整数r&amp;lt;=b，如果使用的稳定排序算法耗时&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n+k)\)&lt;/span&gt;，那么RADIX-SORT的时间代价为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta((b/r)(n+2^r))\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将b位2进制数转化为b/2位&lt;span class=&quot;mathjax&quot;&gt;\(2^r\)&lt;/span&gt;进制数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设&lt;span class=&quot;mathjax&quot;&gt;\(b \geq \lfloor \lg n \rfloor\)&lt;/span&gt;，选择&lt;span class=&quot;mathjax&quot;&gt;\(r = \lfloor \lg n \rfloor\)&lt;/span&gt;，得到RADIX-SORT运行时间为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(bn/\lg n)\)&lt;/span&gt;。特殊地，如果&lt;span class=&quot;mathjax&quot;&gt;\(b = O(\lg n)\)&lt;/span&gt;，将得到基数排序的运行时间：&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;渐近意义上，基数排序要比快速排序的期望运行时间（&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n\lg n)\)&lt;/span&gt;）更好，但是两个表达式中隐含的常数因子是不同的。&lt;br&gt;利用计数排序作为中间稳定排序的基数排序不是原址排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;桶排序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;桶排序&lt;/strong&gt;假设输入数据服从均匀分布，平均情况下时间代价为 O(n)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;桶排序将 [0, 1) 区间划分为 n 个相同大小的子区间，称为 &lt;strong&gt;桶&lt;/strong&gt;。然后将 n 个输入按大小放入各个桶中，先对每个桶中的数进行排序，然后遍历输出每个桶中的数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;BUCKET-SORT(A)
    n = A.length
    let B[&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;.n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; to n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        make B[i] an empty &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
        insert A[i] into &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; B[nA[i]]
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; to n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        sort &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; B[i] with insertion sort
    concatenate the lists B[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;],B[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;],...,B[n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] together in order&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;桶排序的时间代价为：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = \Theta(n) + \sum^{n-1}_{i=0}O(n_i^2)\)&lt;/span&gt;&lt;br&gt;期望运行时间：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(E[T(n)] = E\left[ \Theta(n) + \sum^{n-1}_{i=0}O(n_i^2) \right] = \Theta(n)+ \sum^{n-1}_{i=0}O(E[n_i^2])\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;定义指示器随机变量 &lt;span class=&quot;mathjax&quot;&gt;\(X_{ij} = I\{A[j]~in~bucket~i\}\)&lt;/span&gt;，则&lt;span class=&quot;mathjax&quot;&gt;\(n_i = \sum^n_{j=1}X_{ij}\)&lt;/span&gt;，&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(E[n^2_i] = E\left[ \left( \sum_{j=1}^n X_{ij} \right)^2 \right] = \sum^n_{j=1}E[X_{ij}^2] + \sum_{1\leq j \leq n} \sum_{1\leq k \leq n, k \neq j} E[X_{ij}X_{ik}]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而&lt;span class=&quot;mathjax&quot;&gt;\(E[X_{ij}X_{ik}] = E[X_{ij}^2]=\frac{1}{n^2}\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(E[X_{ij}^2] = 1^2\cdot \frac{1}{n} + 0^2\cdot \left( 1-\frac{1}{n}) \right) = \frac{1}{n}\)&lt;/span&gt;，&lt;br&gt;故&lt;span class=&quot;mathjax&quot;&gt;\(E[n^2_i] = 2 - 1/n\)&lt;/span&gt;，桶排序的期望运行时间 &lt;span class=&quot;mathjax&quot;&gt;\(E[T(n)] = \Theta(n) + n\cdot O(2-1/n) = \Theta(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即使输入数据不服从均匀分布，只要所有桶的大小的平方和与元素数呈线性关系，期望运行时间就是&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;中位数和顺序统计量&lt;/h2&gt;
&lt;p&gt;在一个由n个元素组成的集合中，第i个 &lt;strong&gt;顺序统计量&lt;/strong&gt;（order statistic）是该集合中第i小的元素， &lt;strong&gt;最小值&lt;/strong&gt; 是第一个顺序统计量， &lt;strong&gt;最大值&lt;/strong&gt; 是第n个顺序统计量， &lt;strong&gt;中位数&lt;/strong&gt; 是所属集合的“中点元素”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;n为奇数时，中位数是唯一的；n为偶数时，存在两个中位数，分别为 &lt;strong&gt;上中位数&lt;/strong&gt;和 &lt;strong&gt;下中位数&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;选择问题&lt;/strong&gt;定义为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入&lt;/strong&gt;：一个包含n个数的集合A和整数i（1&amp;lt;=i&amp;lt;=n）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出&lt;/strong&gt;：元素&lt;span class=&quot;mathjax&quot;&gt;\(x\in A\)&lt;/span&gt;，且A中恰好有i-1个其他元素小于它&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;最小值和最大值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;MINIMUM(A)
    min = A[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; to A.length
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; min &amp;gt; A[i]
            min = A[i]
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; min&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;找到最小值比较次数上界为 n-1&lt;/li&gt;
&lt;li&gt;同时找出最大值和最小值比较次数上界为&lt;span class=&quot;mathjax&quot;&gt;\(3\lfloor n/2 \rfloor\)&lt;/span&gt;&lt;blockquote&gt;
&lt;p&gt;如果n为奇数，将最大值最小值设为第一个元素，成对比较其余元素，将较大者与最大值比较，将较小者与最小值比较；如果n为偶数，比较前两个，将最大值设为较大者，最小值设为较小者，此后继续成对比较。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;期望为线性时间的选择算法&lt;/h3&gt;
&lt;p&gt;RANDOMIZED-SELECT以快速排序算法为模型，但只处理划分后的一边，期望运行时间为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;RANDOMIZED-SELECT(A, p, r, i)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; p == r
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; A[p]
    q = RANDOMIZED-PARTITION(A, p, r)
    k = q-p+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i == k    &lt;span class=&quot;hljs-comment&quot;&gt;//the pivot value is the answer&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; A[q]
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i &amp;lt; k
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; RANDOMIZED-SELECT(A, p, q-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, i)
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; RANDOMIZED-SELECT(A, q+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, r, i-k)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RANDOMIZED-SELECT的最坏情况运行时间为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^2)\)&lt;/span&gt;，即使找最小元素也是如此，因为在每次划分时极不走运地总是按余下元素中最大的来进行划分，而划分操作需要&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;时间。&lt;/p&gt;
&lt;p&gt;假设所有元素都是互异的，在期望线性时间内，我们可以找到任一顺序统计量，特别是中位数。即RANDOMIZED-SELECT算法的期望运行时间为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可通过定义子数组A[p..q]正好包含k个元素的顺序统计量来得到递归式并使用归纳法加以证明。直观地讲，因为平均每次只保留一半，每层调用的执行时间将是等比数列，求和后得到总时间为2n。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;最坏情况为线性时间的选择算法&lt;/h3&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将n个元素划分为n/5组&lt;/li&gt;
&lt;li&gt;寻找每组的中位数&lt;/li&gt;
&lt;li&gt;使用SELECT找出上一步中找出的中位数的中位数x&lt;/li&gt;
&lt;li&gt;使用x作为主元执行PARTITION，则x为第k小的元素&lt;/li&gt;
&lt;li&gt;如果i==k，返回x；如果i&lt;k，在低区调用SELECT找出第i小的元素；如果i&gt;k，在高区调用SELECT查找第i-k小的元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;运行时间递归式为&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(T(n) = 
\begin{cases}
O(1),~if~n&amp;lt;140\\
T(\lceil n/5 \rceil) + T(7n/10+6) + O(n),~if~n \geq 140
\end{cases}\)&lt;/span&gt;，解为&lt;span class=&quot;mathjax&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/p&gt;
&lt;h1&gt;数据结构&lt;/h1&gt;
&lt;h2&gt;栈和队列&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;（stack）实现的是一种后进先出策略。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;STACK-EMPTY(S)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; S.top == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; TRUE
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; FALSE

 PUSH(S, x)
    S.top = S.top + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    S[S.top] = x

POP(S)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; STACK-EMPTY(S)
        error &lt;span class=&quot;hljs-string&quot;&gt;&quot;underflow&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; S.top = S.top - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; S[S.top +&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;队列&lt;/strong&gt;（queue）实现的是一种先进先出策略。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;ENQUEUE(Q, x)
    Q[Q.tail] = x
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; Q.tail == Q.length
        Q.tail = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; Q.tail = Q.tail + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;

DEQUEUE(Q)
    x = Q[Q.head]
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; Q.head == Q.length
        Q.head = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; Q.head = Q.head + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;链表&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;双向链表&lt;/strong&gt;（doubly linked list）的每个元素都是一个对象，每个对象有一个关键字key和两个指针：next和prev。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果x.prev=NIL，则元素x没有先驱，因此是链表的第一个元素，即链表的 &lt;strong&gt;头&lt;/strong&gt;（head）；如果x.next=NIL，则元素x没有后继，因此是链表的最后一个元素，即链表的 &lt;strong&gt;尾&lt;/strong&gt;（tail）。&lt;/li&gt;
&lt;li&gt;L.head 指向链表的第一个元素。如果L.head=NIL，则链表为空。&lt;/li&gt;
&lt;li&gt;如果一个链表是 &lt;strong&gt;单链接的&lt;/strong&gt;（singly linked），则省略每个元素中的prev指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;LIST-SEARCH(L, k)
    x = L.head
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; x != NIL and x.key != k
        x = x.next
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x

LIST-INSERT(L, x)
    x.next = L.head
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; L.head != NIL
        L.head.prev = x
    L.head = x
    x.prev = NIL

LIST-DELETE(L, x)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x.prev != NIL
        x.prev.next = x.next
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; L.head = x.next
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x.next != NIL
        x.next.prev = x.prev&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于存在 &lt;strong&gt;哨兵&lt;/strong&gt;（sentinel）的双向循环链表（circular，doubly linked list with a sentinel），L.nil.next指向表头，L.nil.prev指向表尾。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;慎用哨兵，假如有许多个很短的链表，哨兵将造成严重的存储浪费。仅当可以真正简化代码时才使用哨兵。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;LIST-DELETE&#39;(L, x)
    x.prev.next = x.next
    x.next.prev = x.prev

LIST-SEARCH&#39;(L, k)
    x = L.nil.next
    while x != L.nil and x.key != k
        x = x.next
    return x

LIST-INSERT&#39;(L, x)
    x.next = L.nil.next
    L.nil.next.prev = x
    L.nil.next = x
    x.prev = L.nil&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;指针和对象的实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对象的单数组表示&lt;/li&gt;
&lt;li&gt;对象的多数组表示&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象的分配与释放&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;垃圾收集器&lt;/strong&gt;（garbage collector）负责确定哪些对象是未使用的。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;把自由对象保存在一个单链表中，称为 &lt;strong&gt;自由表&lt;/strong&gt;（free list），自由表类似一个栈，下一个被分配的对象就是最后被释放的那个。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//全局变量free指向自由表中的第一个元素&lt;/span&gt;
ALLOCATE-OBJECT()
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt; == NIL
      error &lt;span class=&quot;hljs-string&quot;&gt;&quot;out of space&quot;&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; x = &lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt;
      &lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt; = x.next
      &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x

FREE-OBJECT(x)
  x.next = &lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt;
  &lt;span class=&quot;hljs-built_in&quot;&gt;free&lt;/span&gt; = x&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;有根数的表示&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;二叉树&lt;/strong&gt;T的属性p、left、right分别存放指向父结点、左孩子和右孩子的指针。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果x.p = NIL，则x是根节点；如果x没有左孩子，则 x.left = NIL，右孩子的情况与此类似；属性T.root 指向整棵树T的根节点。如果T.root = NIL，则该树为空。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;分支无限制的有根数&lt;/strong&gt;可以使用 &lt;strong&gt;左孩子有兄弟表示法&lt;/strong&gt;（left-child，right-sibling representation）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;x.left-child 指向结点x最左边的孩子结点&lt;br&gt;x.right-sibling 指向右侧相邻的兄弟结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;树的其他表示方法：对一棵完全二叉树使用堆来表示，堆用一个单数组加上堆的最末结点的下标表示。&lt;/p&gt;
&lt;h2&gt;散列表&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;散列表&lt;/strong&gt;（hash table）是实现了字典操作（INSERT，SEARCH，DELETE）的一种有效数据结构。在一些合理的假设下，在散列表中查找一个元素的平均时间是 O(1) 。&lt;/p&gt;
&lt;h3&gt;直接寻址表&lt;/h3&gt;
&lt;p&gt;在直接寻址方式下，具有关键字k的元素被放在槽k中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为表示动态集合，我们用一个称为 &lt;strong&gt;直接寻址表&lt;/strong&gt;（direct-address table）的数组，记为 T[0..m-1]。数组中的位置称为 &lt;strong&gt;槽&lt;/strong&gt;（slot），每个槽对应全域U中的一个关键字。如果该集合中没有关键字为k的元素，则 T[k]=NIL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;几个字典操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;DIRECT-ADDRESS-SEARCH(T, k)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; T[k]

DIRECT-ADDRESS-INSEART(T, x)
    T[x.key] = x

DIRECT-ADDRESS-DELETE(T, x)
    T[x.key]=NIL&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;散列表&lt;/h3&gt;
&lt;p&gt;在散列方式下，具有关键字k的元素方舟子槽 h(k) 中。即利用 &lt;strong&gt;散列函数&lt;/strong&gt;（hash function）h，由关键字 k 计算出槽的位置。函数h将关键字的全域U映射到 &lt;strong&gt;散列表&lt;/strong&gt;（hash table）T的槽位上：&lt;br&gt;h: U -&amp;gt; {0,1,...,m-1}&lt;/p&gt;
&lt;h4&gt;通过链接法解决冲突&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;CHAINED-HASH-INSERT(T, x)
    insert x at the head of &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; T[h(x.key)]

CHAINED-HASH-SEARCH(T, k)
    search &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; an element with key k in &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; T[h(k)]

CHAINED-HASH-DELETE(T, x)
    &lt;span class=&quot;hljs-keyword&quot;&gt;delete&lt;/span&gt; x from the &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; T[h(x.key)]&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;链接法散列的分析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;定义一个能存放n个元素的，具有m个槽位的散列表T的 &lt;strong&gt;装载因子&lt;/strong&gt;（load factor）&lt;span class=&quot;mathjax&quot;&gt;\(\alpha = n/m\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;简单均匀散列（simple uniform hashing）：任何一个给定元素等可能地散列到m个槽位中的任何一个，且与其他元素被散列到什么位置上无关。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在简单均匀三列的假设下，对于用链接法解决冲突的散列表，一次不成功查找的平均时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(1+\alpha)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一次不成功的查找，首先计算槽位置 h(k)，时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(1)\)&lt;/span&gt;；然后遍历该槽上链表中的所有元素，平均个数为 &lt;span class=&quot;mathjax&quot;&gt;\(\alpha\)&lt;/span&gt;。故一次不成功查找的平均时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(1+\alpha)\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在简单均匀三列的假设下，对于用链接法解决冲突的散列表，一次成功查找的平均时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(1+\alpha)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同上，但是遍历槽上链表中的元素时，平均遍历个数为 &lt;span class=&quot;mathjax&quot;&gt;\(\alpha/2\)&lt;/span&gt;，故一次成功查找的平均时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(1+\alpha/2)=\Theta(1+\alpha)\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;散列函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;好的散列函数的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;满足简单均匀散列假设&lt;/li&gt;
&lt;li&gt;散列值在某种程度上应独立于数据可能存在的任何模式&lt;/li&gt;
&lt;li&gt;某些很近似的关键字具有截然不同的散列值&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;除法散列法&lt;/h4&gt;
&lt;p&gt;h(k) = k mod m&lt;/p&gt;
&lt;p&gt;当应用除法散列法时，要避免选择m的某些值（例如远离2的幂次）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设 &lt;span class=&quot;mathjax&quot;&gt;\(m=2^p-1\)&lt;/span&gt;，k 为按基数&lt;span class=&quot;mathjax&quot;&gt;\(2^p\)&lt;/span&gt;表示的字符串，则很容易证明，散列值只与字符串各字符ASCII值的和有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;乘法散列法&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(h(k) = \lfloor m(kA \rm{mod}~1) \rfloor\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(0&amp;lt;A&amp;lt;1\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为存储方便，m一般选择2的幂次。&lt;/li&gt;
&lt;li&gt;A的最佳取值与待散列数据的特征有关。Knuth认为，&lt;span class=&quot;mathjax&quot;&gt;\(A \approx (\sqrt{5} -1)/2\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;全域散列法&lt;/h4&gt;
&lt;p&gt;任何一个特定的散列函数都可通过选择特定的关键字，使得n个关键字全部散列到同一个槽中，此时平均检索时间为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n)\)&lt;/span&gt;。为了避免这种情况，可以随机地选择散列函数，使之独立于要存储的关键字。这种方法称为 &lt;strong&gt;全域散列&lt;/strong&gt;（universal hashing）&lt;/p&gt;
&lt;h3&gt;开放寻址法&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;开放寻址法&lt;/strong&gt;（open addressing）中，所有的元素都存放在散列表里，每个表项包含动态集合中的一个元素，或者NIL。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此时，装载因子永远不会超过1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了插入一个元素，需要连续地检查散列表，称为 &lt;strong&gt;探查&lt;/strong&gt;（probe）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要将散列函数加以扩充，将探查号作为第二个参数。对于每个关键字 k，产生 0~m-1 的探查序列（同样，m为槽数，n为元素数）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;HASH-INSERT(T, k)
    i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    repeat
        j = h(k,i)    &lt;span class=&quot;hljs-comment&quot;&gt;//j为探查序列的第i项的存储位置&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; T[j] == NIL
            T[j]=k
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; j
        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; i=i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    until i==m
    error &lt;span class=&quot;hljs-string&quot;&gt;&quot;hash table overflow&quot;&lt;/span&gt;

HASH-SEARCH(T, k)
    i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    repeat
        j=h(k,i)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; T[j] == k
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; j
        i = i+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    until T[j] == NIL or i==m
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除操作比较困难。可以将删除的元素赋值为DELETED而不是NIL，使得在此仍可以插入元素，而SEARCH则会跳过该槽。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此时，查找时间不再依赖于装载因子了。为此，在必须删除关键字的应用中，更常见的做法是采用链接法来解决冲突。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;线性探查&lt;/h4&gt;
&lt;p&gt;在 &lt;strong&gt;线性探查&lt;/strong&gt;（linear probing）中，采用散列函数：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(h(k, i) = (h&amp;#39;(k) +i )\rm{mod}~m,~i=0,1,...,m-1\)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;随着连续被占用的槽不断增加，平均查找时间随之增加。称为 &lt;strong&gt;一次群集&lt;/strong&gt;（primary clustering）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;二次探查&lt;/h4&gt;
&lt;p&gt;在 &lt;strong&gt;二次探查&lt;/strong&gt;（quadratic probing）中，采用散列函数：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(h(k, i) = (h&amp;#39;(k) + c_1 i + c_2 i^2 ) \rm{mod}~m\)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在二次探查中，如果两关键字的初始探查位置相同，在他们的探查序列也是相同的。称为 &lt;strong&gt;二次群集&lt;/strong&gt;（secondary clustering）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;双重散列&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;双重散列&lt;/strong&gt;（double hashing）是用于开放寻址法的最好方法之一。采用如下散列函数&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(h(k,i) = (h_1(k) + ih^2(k)) \rm{mod}~m\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;开放寻址散列的分析&lt;/h4&gt;
&lt;p&gt;给定一个装载因子为&lt;span class=&quot;mathjax&quot;&gt;\(\alpha\)&lt;/span&gt;的开放寻址散列表，并假设均匀散列，则对于一次不成功的查找，期望的探查次数至多为&lt;span class=&quot;mathjax&quot;&gt;\(1/(1-\alpha)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于不成功的查找，第j次查找相当于在 m-(j-1) 个未探查的槽中，查找 n-(j-1) 个元素中的任一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;给定一个装载因子为&lt;span class=&quot;mathjax&quot;&gt;\(\alpha\)&lt;/span&gt;的开放寻址散列表，平均情况下，向一个装载因子为 &lt;span class=&quot;mathjax&quot;&gt;\(\alpha\)&lt;/span&gt; 的开放寻址散列表中插入一个元素至多需要做 &lt;span class=&quot;mathjax&quot;&gt;\(1/(1-\alpha)\)&lt;/span&gt; 次探查。&lt;/p&gt;
&lt;p&gt;对于一个装载因子为&lt;span class=&quot;mathjax&quot;&gt;\(\alpha&amp;lt;1\)&lt;/span&gt;的开放寻址散列表，一次成功查找中的探查期望数至多为&lt;span class=&quot;mathjax&quot;&gt;\(\frac{1}{\alpha} \ln \frac{1}{1-\alpha}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;完全散列&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;完全散列&lt;/strong&gt;（perfect hashing）进行查找时，能在最坏情况下用 O(1) 次访存完成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;采用两级的散列方法设计完全散列方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;二叉搜索树&lt;/h2&gt;
&lt;h3&gt;什么是二叉搜索树&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;二叉搜索树&lt;/strong&gt;：对任何结点x，其左子树中的关键字最大不超过x.key，其右子树中的关键字最小不低于x.key。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二叉搜索树不一定是平衡的，其操作时间为 O(h)。当其非常不平衡时，O(h) 将远远超过 O(lg n)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;中序遍历&lt;/strong&gt;（inorder tree walk）：输出的子树根的关键字位于其左子树的关键字值和右子树的关键字值之间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类似， &lt;strong&gt;先序遍历&lt;/strong&gt;（preorder tree walk）中输出根的关键字在其子树的关键字之前； &lt;strong&gt;后序遍历&lt;/strong&gt;（postorder tree walk）输出的根的关键字在其子树的关键字之后。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;INORDER-TREE-WALK(x)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x != NIL
        INORDER-TREE-WALK(x.left)
        print x.key    
        INORDER-TREE-WALK(x.left)&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;查询二叉搜索树&lt;/h3&gt;
&lt;h4&gt;查找关键字k&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个指向树根的指针x和关键字k，如果这个结点存在，TREE-SEARCH返回一个指向关键字为k的结点的指针；否则返回NIL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;TREE-SEARCH
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x==NIL or k==x.key
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; k &amp;lt; x.key
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; TREE-SEARCH(x.left, k)
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; TREE-SEARCH(x.right, k)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者采用非递归方式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在大多数计算机，接待版本的效率要高得多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;ITERATIVE-TREE-SEARCH(x, k)
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; x!=NIL and k!=x.key
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; k&amp;lt;x.key
            x = x.left
        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; x = x.right
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;查找最小和最大元素&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;TREE-MINIMUM(x)
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; x.left != NIL
        x = x.left
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x

TREE-MAXIMUM(x)
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; x.right != NIL
        x = x.right
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;先驱和后继&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;TREE-SUCCESSOR(x)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x.right != NIL    &lt;span class=&quot;hljs-comment&quot;&gt;//右子树存在：返回右子树最小值&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; TREE-MINIMUM(x, right)
    y = x.p
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; y != NIL and x == y.right    &lt;span class=&quot;hljs-comment&quot;&gt;//右子树不存在：返回第一个在右侧的祖父结点&lt;/span&gt;
        x = y
        y = y.p
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; y&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在一棵高度为h的二叉搜索树上，动态集合上的操作 SEARCH、MINIMUM、MAXIMUM、SUCCESSOR和PREDECESSOR可以在O(h)时间内完成。&lt;/p&gt;
&lt;h3&gt;插入和删除&lt;/h3&gt;
&lt;h4&gt;插入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;TREE-INSERT(T, z)
    y = NIL
    x = T.root
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; x != NIL
        y = x
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; z.key &amp;lt; x.key
            x = x.left
        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; x = x.right
    z.p = y
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; y == NIL
        T.root = z
    elseif z.key &amp;lt; y.key
        y.left = z
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; y.right = z&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;删除&lt;/h4&gt;
&lt;p&gt;从二叉搜索树T中删除结点x分为以下4中情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;x无左子树&lt;br&gt; 使用x的右子树代替x&lt;/li&gt;
&lt;li&gt;x无右子树&lt;br&gt; 使用x的左子树代替x&lt;/li&gt;
&lt;li&gt;x右子树无左子树&lt;br&gt; 使用x的右子树代替x，x的左子树作为x右子树的左子树&lt;/li&gt;
&lt;li&gt;x右子树有右子树&lt;br&gt; 使用x的右子树代替x，递归右子树的左子树直至NIL，x的左子树代替这个NIL&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;左子树（如果有的话）应放在右子树的MINIMUM处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一棵高度为h的二叉搜索树上，动态集合上的操作 TREE-INSERT、TREE-DELETE可以在O(h)时间内完成。&lt;/p&gt;
&lt;h3&gt;随机构建二叉搜索树&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;随机构建二叉搜索树&lt;/strong&gt;（randomly built binary search tree）为按随机次序插入这些关键字到一棵初始的空树而生成的树，这里输入关键字的 n! 个排列中的每个都是等可能地出现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们用 &lt;span class=&quot;mathjax&quot;&gt;\(X_n\)&lt;/span&gt; 表示一棵有n个不同关键字的二叉搜索树的 &lt;strong&gt;高度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指数高度&lt;/strong&gt;（exponential height）定义为&lt;span class=&quot;mathjax&quot;&gt;\(Y_n = 2^{X_n}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;关键字的 &lt;strong&gt;秩&lt;/strong&gt;（rank）&lt;span class=&quot;mathjax&quot;&gt;\(R_n\)&lt;/span&gt;代表该关键字在排好序的集合中占据的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;红黑树&lt;/h2&gt;
&lt;h3&gt;红黑树的性质&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;红黑树&lt;/strong&gt;（red-black tree）是许多“平衡”搜索树中的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为 O(lg n)。&lt;/p&gt;
&lt;p&gt;一棵红黑树是满足下面 &lt;strong&gt;红黑性质&lt;/strong&gt;的二叉搜索树：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个结点或是红色的，或是黑色的&lt;/li&gt;
&lt;li&gt;根结点是黑色的&lt;/li&gt;
&lt;li&gt;每个叶结点（NIL）都是黑色的&lt;/li&gt;
&lt;li&gt;如果一个结点是红色的，则它的两个子结点都是黑色的&lt;/li&gt;
&lt;li&gt;对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;从某个结点x出发到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的 &lt;strong&gt;黑高&lt;/strong&gt;（black-height），记为 bh(x)。定义 &lt;strong&gt;红黑树的黑高&lt;/strong&gt;为其根节点的黑高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一棵有n个内部结点的红黑树的高度至多为 &lt;span class=&quot;mathjax&quot;&gt;\(2\lg (n+1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;数据结构的扩张&lt;/h2&gt;
&lt;p&gt;通过存储额外信息的方法来扩张一种标准的数据结构，然后对这种数据结构，编写新的操作来支持所需要的应用。&lt;/p&gt;
&lt;h3&gt;动态顺序统计&lt;/h3&gt;
&lt;p&gt;修改红黑树，使得可以在 O(lg n) 时间内确定任何顺序统计量。给每个结点x添加一个属性size保存以x为根的子树的结点个数。&lt;/p&gt;
&lt;h4&gt;查找具有给定秩的元素&lt;/h4&gt;
&lt;p&gt;过程OS-SELECT(x, i)返回一个指针，指向以x为根的子树中包含第i小关键字的结点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;OS-SELECT(x, i)
    r = x.left.size + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i == r
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x
    elseif i&amp;lt; r
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; OS-SELECT(x.left, i)
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; OS-SELECT(x.right, i-r)&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;确定一个元素的秩&lt;/h4&gt;
&lt;p&gt;过程OS-RANK返回对T中序遍历对应的线性序列中x的位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;OS-RANK(T, x)
    r = x.left.size +&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    y = x
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; y != T.root
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; y == y.p.right
            r = r + y.p.left.size +&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        y = y.p
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;如何扩张数据结构&lt;/h3&gt;
&lt;p&gt;扩张一种数据结构可以分为四个步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择一种基础数据结构&lt;/li&gt;
&lt;li&gt;确定基础数据结构中要维护的附加信息&lt;/li&gt;
&lt;li&gt;检验基础数据结构上的基本修改操作能否维护附加信息&lt;/li&gt;
&lt;li&gt;设计一些新的操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设f是n个结点的红黑树T扩张的属性，且假设对任一结点x，f的值仅依赖于结点x、x.left、x.right的信息，还可能包括x.left.f和x.right.f。那么我们可以在插入和删除操作期间对T的所有节点的f值进行维护，并且不影响这两个操作 O(lg n) 的渐近时间性能。&lt;/p&gt;
&lt;h3&gt;区间树&lt;/h3&gt;
&lt;p&gt;通过扩张红黑树来支持由区间构成的动态集合上的一些操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;INTERVAL-INSEART(T, x)：将包含区间属性int的元素x插入到区间树T中&lt;/li&gt;
&lt;li&gt;INTERVAL-DELETE(T, x)：从区间树T中删除元素x&lt;/li&gt;
&lt;li&gt;INTERVAL-SEARCH(T, i)：返回一个指向区间树T中元素x的指针，使 x.int 与 i 重叠；若此元素不存在，则返回 T.nil&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;区间三分率&lt;/strong&gt;（interval trichotomy）：1. i 与 i&amp;#39; 重叠；2. i 在 i&amp;#39; 的右边；3. i 在 i&amp;#39; 的左边&lt;br&gt;&lt;strong&gt;高端点&lt;/strong&gt;（high endpoint）：i.hight&lt;br&gt;&lt;strong&gt;低端点&lt;/strong&gt;（low endpoint）：i.low&lt;br&gt;&lt;strong&gt;重叠&lt;/strong&gt;（overlap）：i.low &amp;lt;= i&amp;#39;.high 且 i&amp;#39;.low &amp;lt;= i.high&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;附加信息：在结点x中添加属性 max，它是以x为根的子树中所有区间端点的最大值。&lt;/p&gt;
&lt;p&gt;新的操作：INTERVAL-SEARCH(T, i)，用来查找树T中与区间i重叠的那个结点，若不存在返回哨兵 T.nil 的指针。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;INTERVAL-SEARCH(T, i)
    x = T.root
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; x!=T.nil and i does not overlap x.&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; x.left != T.nil and x.left.max &amp;gt;= i.low
            x = x.left
        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;
            x = x.right
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;高级设计和分析技术&lt;/h1&gt;
&lt;h2&gt;动态规划&lt;/h2&gt;
&lt;p&gt;动态规划方法通常用来求解 &lt;strong&gt;最优化问题&lt;/strong&gt;（optimization problem），通常有四个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刻画一个最优解的特征&lt;/li&gt;
&lt;li&gt;递归地定义最优解的值&lt;/li&gt;
&lt;li&gt;计算最优解的值&lt;/li&gt;
&lt;li&gt;利用计算出的信息构造一个最优解&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（dynamic programming）与分治方法相似，都是通过组合子问题的解来求解原问题。区别在于分治法的子问题互不相交，而动态规划应用于子问题重叠的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;钢条切割问题&lt;/h3&gt;
&lt;p&gt;问题定义：给定一段长度为n的钢条和价格表&lt;span class=&quot;mathjax&quot;&gt;\(p_i (i=1,2,...,n)\)&lt;/span&gt;，求切割钢条方案，使得销售收益&lt;span class=&quot;mathjax&quot;&gt;\(r_n\)&lt;/span&gt;最大。&lt;/p&gt;
&lt;p&gt;钢条切割问题满足 &lt;strong&gt;最优子结构&lt;/strong&gt;（optimal substructure）性质：问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解。&lt;/p&gt;
&lt;h4&gt;直接的自顶向下的递归方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;CUT-ROD(p, n)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; n==&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    q = -MAX
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
        q = max(q,p[i]+CUT-ROD(p,n-i))
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; q&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该算法的运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(T(n)=2^n\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;带备忘的自顶向下法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;MEMOIZED-CUT-ROD(p,n)
    let r[&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;.n] be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; to n
        r[i] = -MAX
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; MEROIZED-CUT-AUX(p,n,r)

MEMOIZED-CUT-ROD-AUX(p,n,r)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; r[n] &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; r[n]
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
        q = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; q = -MAX
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
            q = max(q,p[i]+MEMOIZED-CUT-ROD-AUX(p,n-i,r))
    r[n] = q
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; q&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该算法的渐近运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;自底向上法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;BOTTOM-UP-CUT-ROD(p,n)
    let r[&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;.n] be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;
    r[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
        q = -MAX
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to j
            q = max(q,p[i]+r[j-i])
        r[j] = q
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; r[n]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该算法与自顶向下法有相同的渐近运行时间。&lt;/p&gt;
&lt;h4&gt;重构解&lt;/h4&gt;
&lt;p&gt;扩展 BOTTOM-UP-CUT-ROD 算法，计算最大收益&lt;span class=&quot;mathjax&quot;&gt;\(r_j\)&lt;/span&gt;同时，记录最优解对应的第一段钢条的切割长度 &lt;span class=&quot;mathjax&quot;&gt;\(s_j\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
    let r[&lt;span class=&quot;hljs-number&quot;&gt;0.&lt;/span&gt;.n] be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;
    r[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
        q = -MAX
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to j
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; q&amp;lt; p[i]+r[j-i]
                q = p[i]+r[j-i]
                s[j] = i
        r[j] = q
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; r and s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出长度为n的钢条的完整的最优切割方案&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;PRINT-CUT-ROD-SOLUTION(p,n)
    (r,s) = EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; n&amp;gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
        print s[n]
        n=n-s[n]&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;矩阵链乘法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;矩阵链乘法&lt;/strong&gt;（matrix-chain multiplication problem）可描述如下：给定n个矩阵的链 &lt;A1,A2,...An&gt;，矩阵 Ai 的规模为 &lt;span class=&quot;mathjax&quot;&gt;\(p_{i-1}\times p_i\)&lt;/span&gt;，求完全括号化方案，使得计算乘积 A1A2...An 所需的标量乘法次数最少。&lt;/p&gt;
&lt;p&gt;我们称有如下性质的矩阵乘积链为 &lt;strong&gt;完全括号化&lt;/strong&gt;（fully parenthesized）：它是单一矩阵，或者两个完全括号化的矩阵乘积链的积，且已外加括号。括号化方案的数量与n呈指数关系，通过暴力搜索穷尽所有可能的括号化方案来寻找最优方案，是一个糟糕的策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个例子，计算三个矩阵连乘{A1，A2，A3}；维数分别为10&lt;em&gt;100 , 100&lt;/em&gt;5 , 5&lt;em&gt;50&lt;br&gt;按此顺序计算需要的次数（（A1&lt;/em&gt;A2）&lt;em&gt;A3）:10X100X5+10X5X50=7500次&lt;br&gt;按此顺序计算需要的次数（A1&lt;/em&gt;（A2*A3））:10X5X50+10X100X50=75000次&lt;br&gt;所以问题是：如何确定运算顺序，可以使计算量达到最小化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;子问题：令m[i][j]表示第i个矩阵至第j个矩阵这段的最优解。&lt;br&gt;如果i=j，则m[i][j]这段中就一个矩阵，需要计算的次数为0；&lt;br&gt;如果i&amp;gt;j，则m[i][j]=min{m[i][k]+m[k+1][j]+p[i-1]Xp[k]Xp[j]}，其中i&amp;lt;=k&amp;lt;j ;&lt;/p&gt;
&lt;p&gt;注意计算顺序，保证在计算 m[i][j] 的时候，m[i][k]和m[k+1][j]已经计算出来了。&lt;/p&gt;
&lt;p&gt;求解表 m&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;MATRIX-CHAIN-ORDER(p)
    n = p.length -&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; 
    let m[&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n,&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n] and s[&lt;span class=&quot;hljs-number&quot;&gt;1.&lt;/span&gt;.n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;2.&lt;/span&gt;.n] be &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; tables
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
        m[i,i] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; l =  &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; to n
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n-l+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
            j = i+l-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
            m[i,j] = MAX
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k = i to j-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
                q = m[i,k]+m[k+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,j] + p(i-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)p(k)p(j)
                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; q&amp;lt; m[i,j]
                    m[i,j] = q
                    s[i,j] = k
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; m and s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构造最优解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;PRINT-OPTIMAL-PARENS(s, i, j)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i==j
        print &lt;span class=&quot;hljs-string&quot;&gt;&quot;Ai&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; print &lt;span class=&quot;hljs-string&quot;&gt;&quot;(&quot;&lt;/span&gt;
        PRINT-OPTIMAL-PARENS(s, i, s[i,j])
        PRINT-OPTIMAL-PARENS(s, s[i,j]+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, j)
        print &lt;span class=&quot;hljs-string&quot;&gt;&quot;)&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;动态规划原理&lt;/h3&gt;
&lt;p&gt;适合应用动态规划方法求解的最优化问题应该具备两个要素：最优子结构和子问题重叠。&lt;/p&gt;
&lt;p&gt;给定一个有向图 G=(V,E) 和两个顶点 &lt;span class=&quot;mathjax&quot;&gt;\(u,~v\in V\)&lt;/span&gt;。&lt;br&gt;&lt;strong&gt;无权最短路径&lt;/strong&gt;：找到一条从 u 到 v 的边数最少的路径。这条路径必然是简单路径。&lt;br&gt;&lt;strong&gt;无权最长路径&lt;/strong&gt;：找到一条从 u 到 v 的边数最多的路径，这条路径要求是简单路径。&lt;/p&gt;
&lt;p&gt;无权最短路径具有最优子结构性质，而无权最长路径没有该性质。原因在于，虽然最长路径问题和最短路径问题的解都用到了两个子问题，但两个最长简单路径子问题是相关的，而两个最短路径子问题是 &lt;strong&gt;无关的&lt;/strong&gt;（independent）。&lt;/p&gt;
&lt;p&gt;如果递归算法反复求解相同的子问题，我们就称最优化问题具有 &lt;strong&gt;重叠子问题&lt;/strong&gt;（overlapping subproblems）性质。与之相反，适合用分治方法求解的问题通常在递归的每一步都生成全新的问题。直接的递归算法无疑会重复计算每个子问题，而带备忘的递归算法可以达到与带备忘自顶向下的动态规划算法相似的效率。&lt;/p&gt;
&lt;h3&gt;最长公共子序列&lt;/h3&gt;
&lt;p&gt;给定一个序列X[1..m]，另一个序列Z[1..k]满足如下条件时称为X的子序列：存在一个严格递增的X的下标序列 i[1..k] ，对所有的 1&amp;lt;=j&amp;lt;=k，满足 x[i[j]] = z[j]。&lt;/p&gt;
&lt;p&gt;c[i,j]表示X[i]和Y[j]的 &lt;strong&gt;最长公共子序列&lt;/strong&gt;（longest commen subsequence，LCS），根据 LCS 的最优子结构性质，可得到如下公式&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(c[i,j] = \begin{cases}
0,~if~i=0~or~j=0\\
c[i-1,j-1]+1,~if~i,j&amp;gt;0~and~x_i=y_j\\
max(c[i,j-1],c[i-1,j]),~if~i,j&amp;gt;0~and~x_i\neq y_j
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过动态规划的方法，可以先求解表c，再根据表c构造LCS。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，对于LCS算法，每个c[i,j]只依赖于c[i-1,j], c[i,j-1], c[i-1,j-1]和x,y的关系，用这些可以在常数时间内计算c[i,j]，因此完全可以去掉表c，只需要常量的存储。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;最优二叉搜索树&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;最优二叉搜索树&lt;/strong&gt;（optimal binary search tree）：给定一个n个不同关键字的已排序的序列K，希望构造一棵二叉搜索树。每个关键字都有一个概率表示其搜索频率，我们希望该二叉搜索树的期望搜索代价最小。&lt;/p&gt;
&lt;p&gt;最优子结构：如果一棵最优二叉搜索树T有一棵子树T‘，那么T&amp;#39;必然是其包含的关键字构成的子问题的最优解。递归式为：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(e[i,j] = \begin{cases}
q_{i-1},~if~j=i-1\\
\min_{i\leq r \leq j} \{ e[i,r-1]+e[r+1,j]+w(i,j) \},~if~i\leq j
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以通过类似矩阵链乘的算法进行求解，时间复杂度也是&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;贪心算法&lt;/h2&gt;
&lt;h3&gt;活动选择问题&lt;/h3&gt;
&lt;p&gt;问题描述：假定有n个 &lt;strong&gt;活动&lt;/strong&gt;（activity）的集合S，这些活动使用同一资源（即同一时刻只供一个活动使用）。每个活动有一个 &lt;strong&gt;开始时间&lt;/strong&gt;（s[i]）和 &lt;strong&gt;结束时间&lt;/strong&gt;（f[i]），在 &lt;strong&gt;活动选择问题&lt;/strong&gt;中，我们希望选出一个最大兼容活动集。假定活动已按结束时间递增排序。&lt;/p&gt;
&lt;h4&gt;动态规划法&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(S_{ij}\)&lt;/span&gt; 表示结束时间在活动 i 结束后 j 开始前的活动集合，c[i,j] 表示 &lt;span class=&quot;mathjax&quot;&gt;\(S_{ij}\)&lt;/span&gt; 的最优解的大小，则&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(c[i,j]=\begin{cases}
0,~if S_{ij} = \emptyset\\
max\{ c[i,k]+c[k,j]+1 \},~if S_{ij} \neq \emptyset
\end{cases}\)&lt;/span&gt;&lt;br&gt;可以通过带备忘的递归算法，或者自底向上法填写表项。&lt;/p&gt;
&lt;h4&gt;贪心选择&lt;/h4&gt;
&lt;p&gt;加入无需求解所有子问题就可以选择一个活动加入最优解，将省去上式中考察所有选择的过程，即 &lt;strong&gt;贪心选择&lt;/strong&gt;。&lt;span class=&quot;mathjax&quot;&gt;\(S_k={a_i\in S: s_i \geq f_k}\)&lt;/span&gt; 为在 &lt;span class=&quot;mathjax&quot;&gt;\(a_k\)&lt;/span&gt; 结束后开始的任务集合。&lt;/p&gt;
&lt;p&gt;递归贪心算法 RECURSIVE-ACTIVITY-SELECTOR 的输入为两个数组 s 和 f，表示活动的开始和结束时间，下标 k 指出要求解的子问题 &lt;span class=&quot;mathjax&quot;&gt;\(S_k\)&lt;/span&gt;，以及问题规模 n。返回 &lt;span class=&quot;mathjax&quot;&gt;\(S_k\)&lt;/span&gt; 的一个最大兼容活动集。求解原问题可以调用 RECURSIVE-ACTIVITY-SELECTOR(s,f,0,n)。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;RECURSIVE-ACTIVITY-SELECTOR(s,f,k,n)
    m = k+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; m&amp;lt;=n and s[m]&amp;lt;f[k]
        m++
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m&amp;lt;=n
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; {a[m]} U RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; null&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以转换为迭代贪心算法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;GREEDY-ACTIVITY-SELECTOR(s,f)
    n = s.length
    A={a[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]}
    k=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; m=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; to n
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; s[m] &amp;gt;= f[k]
            A = A U {a[m]}
            k = m
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; A&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;贪心算法原理&lt;/h3&gt;
&lt;p&gt;如果一个问题的最优解包含其子问题的最优解，则称此问题具有 &lt;strong&gt;最优子结构&lt;/strong&gt;星坠，此性质是能否应用动态规划和贪心方法的关键要素。两者的差别在于 &lt;strong&gt;贪心选择性质&lt;/strong&gt;（greedy-choice property）：我们可以通过做出局部最优（贪心）选择来构造全局最优解。&lt;/p&gt;
&lt;h4&gt;贪心与动态规划&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;0-1 背包问题&lt;/strong&gt;（0-1 knapsack problem）：正在抢劫商店的小偷发现n个商品，第i个商品价值v[i]美元，重w[i]磅。小偷希望拿走尽量多的物品，而他的背包最多容纳W磅的物品。对于每个商品小偷要么完整拿走，要么把它留下，不能部分拿走或拿走多次。&lt;br&gt;&lt;strong&gt;分数背包问题&lt;/strong&gt;（fractional knapsack problem）中，设定于 0-1背包问题一样，但低于每一个商品，小偷可以拿走其一部分。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两个背包问题都具有最优子结构性质。但我们可以使用贪心策略求解分数背包问题，而不能求解0-1背包问题。原因是小偷无法装满背包时，空闲空间降低了方案的有效每磅价值。当我们考虑是否装入某商品时，必须比较包含此商品的子问题的解与不包含它的子问题的解，然后才能做出选择。这将产生大量的重叠子问题，即需要使用动态规划算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;赫夫曼编码&lt;/h3&gt;
&lt;p&gt;我们考虑一种 &lt;strong&gt;二进制字符编码&lt;/strong&gt;（或简称 &lt;strong&gt;编码&lt;/strong&gt;）的方法，每个字符用唯一二进制串表示，称为 &lt;strong&gt;码字&lt;/strong&gt;。 &lt;strong&gt;变长编码&lt;/strong&gt;（variable-length code）可以达到比 &lt;strong&gt;定长编码&lt;/strong&gt;好得多的压缩率，其思想是赋予高频字符短码字，赋予低频字符长码字。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;前缀码&lt;/strong&gt;（prefix code）中，没有任何码字是其他码字的前缀。此时编码文件的开始码字是无歧义的。我们可以简单地识别出开始码字，将其转换回原字符，然后对编码文件剩余部分重复这种解码过程。解码过程可以用二叉树方便地表示。&lt;/p&gt;
&lt;p&gt;给定编码树 T，定义 &lt;span class=&quot;mathjax&quot;&gt;\(d_T(c)\)&lt;/span&gt; 为字母表 C 中字符 c 的叶结点的深度，即 c 的码字长度。定义 T 的 &lt;strong&gt;代价&lt;/strong&gt;：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(B(T) = \sum_{c\in C} c.freq \cdot d_T(c)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赫夫曼编码&lt;/strong&gt;（Huffman code）是一种使用贪心算法构造的最优前缀码。C是n个字符的集合，C中的每个字符c有一个属性c.freq给出其出现频率。Q为以freq为关键字的最小优先队列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;HUFFMAN(C)
    n = |C|
    Q = C
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        allocate a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; code z
        z.left = x = EXTRACT-MIN(Q)
        z.right = y = EXTRACT-MIN(Q)
        z.freq = x.freq + y.freq
        INSERT(Q,z)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; EXTRACT-MIN(Q)    &lt;span class=&quot;hljs-comment&quot;&gt;//return the root of the tree&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;假定 Q 使用最小二叉堆实现，则堆操作时间为 O(n)，HUFFMAN的运行时间为 O（n lg n)，如果将最小二叉堆换为 van Emde Boas 树，可以将运行时间将为 O(n lg lg n)。&lt;/p&gt;
&lt;h4&gt;HUFFMAN算法的正确性&lt;/h4&gt;
&lt;p&gt;引理1：令C为一个字母表，其中的每个字符c有一个频率c.freq。x和y为频率最低的两个字符。那么存在C的一个最优前缀码，x和y有相同的码字长度，且只有最有一个二进制位不同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;叶结点都会成对出现。因为如果出现单独的叶结点，用该结点替换其父结点，可以得到更优的树。&lt;br&gt;不会有任何结点深于频率最低的x和y。因为假如存在这样一个z，那么调换x与z，可以得到更优的树。&lt;br&gt;所以x和y可以位于最低的那两个叶结点上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;引理2：令C为一个字母表，其中的每个字符c有一个频率c.freq。x和y为频率最低的两个字符。令 C&amp;#39; 为 C 去掉 x 和 y，加入 z(z.freq = x.freq+y.freq) 得到的字母表。T‘ 为 C’ 的一个最优前缀码对应的编码树。则将T&amp;#39; 的z替换为一个有x和y子节点的内部结点得到的树T，表示C的一个最优前缀码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 B(T) = B(T&amp;#39;) + x.freq + y.freq，这样的替换将产生确定的代价差额。故T&amp;#39;是最优的可以得到T是最优的（由引理1可以得到总是存在这样的替换）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;高级数据结构&lt;/h1&gt;
&lt;h2&gt;B树&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;B树类似于红黑树。他们在降低磁盘I/O操作数方面更好一些。因为B树的分支因子可以非常大，所以其高度要比红黑树小得多。&lt;/li&gt;
&lt;li&gt;B树是以一种自然的方式推广了的二叉搜索树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;B树的定义&lt;/h3&gt;
&lt;p&gt;我们假定，任何与 &lt;strong&gt;关键字&lt;/strong&gt;相联系的 &lt;strong&gt;卫星数据&lt;/strong&gt;将与关键字一样存放在同一结点中，并随着关键字一起移动。一棵B树T是具有以下性质的有根树（根为T.root）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;B+树是B树的变种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;每个结点x有如下属性：&lt;br&gt; a. x.n，表示结点x中的关键字个数&lt;br&gt; b. x.n个关键字以非降序排列&lt;br&gt; c. x.leaf，表示x是否为叶结点&lt;/li&gt;
&lt;li&gt;每个内部结点包含 x.n+1 个指针指向孩子们 c[i]&lt;/li&gt;
&lt;li&gt;x 中的关键字 x.key[i] 对子树中的关键字 k[i] 进行分割，n个关键字，n+1个子树&lt;/li&gt;
&lt;li&gt;每个叶结点有相同的深度，即树的高度h&lt;/li&gt;
&lt;li&gt;每个结点的关键字数由 &lt;strong&gt;最小度数&lt;/strong&gt;（minimum degree）t&amp;gt;=2控制：&lt;br&gt; a. 除根节点外，每个结点至少含 t-1 个关键字&lt;br&gt; b. 每个结点至多含 2t-1 个关键字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 n&amp;gt;=1，那么对任意一棵包含n个关键字、高度为h、最小度数t&amp;gt;=2 的B树T，有&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(h\leq \log_t \frac{n+1}{2}\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;B树上的基本操作&lt;/h3&gt;
&lt;h4&gt;搜索&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;B-TREE-SEARCH(x,k)
    i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; i&amp;lt;=x.n and k&amp;gt;x.key[i]
        i++
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i&amp;lt;=x.n and k==x.key[i]
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (x,i)
    elseif x.leaf
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; NIL
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; DISK-READ(x,c[i])
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; B-TREE-SEARCH(x.c[i],k)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;循环所用时间为 O(t)，访问磁盘页数为 &lt;span class=&quot;mathjax&quot;&gt;\(O(\log_t n)\)&lt;/span&gt;，总的CPU时间为 &lt;span class=&quot;mathjax&quot;&gt;\(O(t\log_t n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;创建&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;B-TREE-CREATE(T)
    x = ALLOCATE-NODE()
    x.leaf = TRUE
    x.n = &lt;span class=&quot;hljs-number&quot;&gt;00&lt;/span&gt;
    DISK-WRITE(x)
    T.root = x&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CPU时间为 O(1)。&lt;/p&gt;
&lt;h4&gt;插入&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;分裂 B 树中的结点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B-TREE-SPLIT-CHILD(x,i)&lt;/p&gt;
&lt;p&gt;输入：非满的内部结点 x，它的一个满的孩子x.c[i]的下标 i。&lt;br&gt;输出：将该子结点分裂为2个，并在 x 中添加关键字分开这两个孩子&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;沿树下行插入关键字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B-TREE-INSERT-NONFULL(x,k)&lt;/p&gt;
&lt;p&gt;输入：非满的树x，要插入的关键字k&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果x是叶结点，直接插入k&lt;/li&gt;
&lt;li&gt;如果x是内部结点，找到该关键字对应的子树&lt;/li&gt;
&lt;li&gt;如果该子树是满的，就分裂它&lt;/li&gt;
&lt;li&gt;在这个非满的子树上调用 B-TREE-INSERT-NONFULL&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;构造非满根结点并插入关键字k&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;B-TREE-INSERT(T,k)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果根节点不满，调用 B-TREE-INSERT-NONFULL(T.root,k)&lt;/li&gt;
&lt;li&gt;如果根结点是满的，将根结点置于新的根结点下，调用 B-TREE-SPLIT-CHILD 将原根结点分为两个孩子。调用调用 B-TREE-INSERT-NONFULL(T.root,k)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;从B树中删除关键字&lt;/h3&gt;
&lt;p&gt;当删除内部结点的关键字时，需要重新安排这个结点的孩子。当要删除的关键字的路径上的结点有最少的关键字树时还可能需要向上回溯。删除操作有以下几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关键字k在叶结点x中：直接删除它&lt;/li&gt;
&lt;li&gt;关键字k在内部结点x中：&lt;br&gt; a. 如果k左边的子树关键字足够(&amp;gt;=t)，拿出最大的一个代替k&lt;br&gt; b. 如果k右边的子树关键字足够(&amp;gt;=t)，拿出最小的一个代替k&lt;br&gt; c. 既然左右子树关键字都不多于 t-1，将右子树与k合并入左子树，得到 2t-1 个关键字的新结点&lt;/li&gt;
&lt;li&gt;关键字k不在当前的内部结点x中：降至一个至少含t个关键字的结点，通过对x的某个合适的子结点进行递归。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;图算法&lt;/h1&gt;
&lt;h2&gt;基本的图算法&lt;/h2&gt;
&lt;h3&gt;图的表示&lt;/h3&gt;
&lt;p&gt;图 G=(V,E) 可以用两种标准表示方法表示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;邻接链表&lt;/strong&gt;：由一个包含 |V| 条链表的数组 Adj 构成，每个结点有一条链表。&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;权重图&lt;/strong&gt;：直接将边 (u,v) 的权重值 w(u,v) 存放在 u 的邻接链表里。&lt;br&gt;邻接链表表示 &lt;strong&gt;稀疏图&lt;/strong&gt;（边的条数|E|远小于&lt;span class=&quot;mathjax&quot;&gt;\(|V|^2\)&lt;/span&gt;）时非常紧凑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;邻接矩阵&lt;/strong&gt;：由&lt;span class=&quot;mathjax&quot;&gt;\(|V|\times |V|\)&lt;/span&gt;的矩阵 &lt;span class=&quot;mathjax&quot;&gt;\(A=(a_{ij})\)&lt;/span&gt; 表示：&lt;br&gt; &lt;span class=&quot;mathjax&quot;&gt;\(a_{ij}=
 \begin{cases}
 1,~if~(i,j)\in E\\
 0,~other
 \end{cases}\)&lt;/span&gt;&lt;blockquote&gt;
&lt;p&gt;邻接矩阵更适合表示 &lt;strong&gt;稠密图&lt;/strong&gt;、需要快速判断任意两个点是否相连的图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;广度优先搜索&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;广度优先搜索&lt;/strong&gt;是最简单的图搜索算法之一，也是许多重要的图算法的原型。算法需要发现所有距离源点s为k的结点之后，才会发现距离源点s为k+1的结点。&lt;/p&gt;
&lt;p&gt;u.color 记录结点u的颜色，u.pi 记录u的前驱结点，u.d 记录广度优先搜索计算出的与源点s的距离。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;BFS(G,s)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex u in G.V ={s}
        u.color = WHITE
        u.d = MAX
        u.pi = NIL
    s.color = GRAY
    s.d = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    s.pi = NIL
    Q = NULL
    ENQUEUE(Q,s)
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; Q != NULL
        u = DEQUEUE(Q)
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each v in G.Adj[u]
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; v.color == WHITE
                v.color = GRAY
                v.d = u.d + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
                v.pi = u
                ENQUEUE(Q,v)
        u.color = BLACK&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;扫描邻接链表的总时间为 O(E)，初始化成本为 O(V)，故BFS的总运行时间为 O(V+E)。&lt;/p&gt;
&lt;h4&gt;最短路径&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;最短路径距离&lt;/strong&gt; &lt;span class=&quot;mathjax&quot;&gt;\(\delta(s,v)\)&lt;/span&gt;为从源点s到结点v之间所有路径里面最少的边数。称从源点s到结点v的长度为&lt;span class=&quot;mathjax&quot;&gt;\(\delta(s,v)\)&lt;/span&gt;的路径为 &lt;strong&gt;最短路径&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; 给定有向图或无向图G=(V,E)，任意结点&lt;span class=&quot;mathjax&quot;&gt;\(s\in V\)&lt;/span&gt;，则对于任意边 &lt;span class=&quot;mathjax&quot;&gt;\((u,v) \in E\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(\delta(s,v)\leq \delta(s,u)+1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; 给定有向图或无向图G=(V,E)，任意结点&lt;span class=&quot;mathjax&quot;&gt;\(v\in V\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(v.d \geq \delta(s,v)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; 设BFS的队列Q为 &lt;v1,v2,...,vr&gt;，则 &lt;span class=&quot;mathjax&quot;&gt;\(v_r.d \leq v_1.d +1\)&lt;/span&gt;，并且对于 i=1,2,...,r-1，&lt;span class=&quot;mathjax&quot;&gt;\(v_i.d \leq v_{i+1}.d\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即队列中前面的 d 不大于后面的，且首位差距不超过 1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt; 给定有向图或无向图G=(V,E)，BFS将发现所有从源点s可到达的结点v，且对任意 &lt;span class=&quot;mathjax&quot;&gt;\(v\in V\)&lt;/span&gt;，v.d = \delta(s,v)$。s 到 v.pi 的最短路径加上边(v.pi,v) 为一条 s 到 v的最短路径。&lt;/p&gt;
&lt;h4&gt;广度优先树&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;前驱子图&lt;/strong&gt;：&lt;span class=&quot;mathjax&quot;&gt;\(G_\pi  = (V_\pi, E_\pi)\)&lt;/span&gt;，其中 &lt;span class=&quot;mathjax&quot;&gt;\(V_\pi = \{ v\in V: v.\pi \neq NIL \} \cup \{ s \}\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(E_\pi = \{ (v.\pi,v): v \in V_\pi - \{ s \} \}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; 给定有向图或无向图G=(V,E)，BFS过程建造出来的 pi 属性使得前驱子图 &lt;span class=&quot;mathjax&quot;&gt;\(G_\pi  = (V_\pi, E_\pi)\)&lt;/span&gt; 称为一棵广度优先树。&lt;/p&gt;
&lt;p&gt;打印广度优先树&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;PRINT-PATH(G,s,v)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; v == s
        print s
    elseif v.pi == NIL
        print &lt;span class=&quot;hljs-string&quot;&gt;&quot;no path from&quot;&lt;/span&gt; s &lt;span class=&quot;hljs-string&quot;&gt;&quot;to&quot;&lt;/span&gt; v &lt;span class=&quot;hljs-string&quot;&gt;&quot;exists&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; PRINT-PATH(G,s,v.pi)
        print v&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;深度优先搜索&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;深度优先搜索的前驱子图&lt;/strong&gt;：&lt;span class=&quot;mathjax&quot;&gt;\(G_\pi  = (V, E_\pi)\)&lt;/span&gt;，其中 &lt;span class=&quot;mathjax&quot;&gt;\(E_\pi = \{ (v.\pi,v): v \in V~and~v.\pi \neq NIL\}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;深度优先搜索会在每个结点盖上两个 &lt;strong&gt;时间戳&lt;/strong&gt;：第一个时间戳 v.d 记录v第一次被发现的时间（涂上灰色）；第二个时间戳 v.f 记录完成对 v 的邻接链表扫描的时间（涂上黑色）。&lt;/p&gt;
&lt;p&gt;DFS输入G是无向图或有向图，time为全局变量用来计算时间戳。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;DFS(G)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex u in G.V
        u.color = WHITE
        u.pi = NIL
    time = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex u in G.V
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; u.color == WHITE
            DFS-VISIT(G,u)

DFS-VISIT(G,u)
    time++
    u.d = time
    u.color = GRAY
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each v in G:Ajd[u]
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; v.color == WHITE
            v.pi = u
            DFS-VISIT(G,v)
    u.color = BLACK
    time++
    u.f = time&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;初始化时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(V)\)&lt;/span&gt;，遍历邻接链表时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(E)\)&lt;/span&gt;，故算法运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(V+E)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;深度优先搜索的性质&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt; 在对有向图或无向图 G=(V,E) 进行DFS时，对任意结点 u 和 v：以下三种情况只有一种成立：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[u.d,u.f]与[v.d,v.f]完全分离：深度优先森林中，u与v互相不为对方后代&lt;/li&gt;
&lt;li&gt;[u.d,u.f]完全包含于[v.d,v.f]：深度优先森林中，u是v的后代&lt;/li&gt;
&lt;li&gt;与2相反的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;推论&lt;/strong&gt; 在深度优先森林中，v是u的真后代当且仅当 u.d&amp;lt;v.d&amp;lt;v.f&amp;lt;u.f。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;白色路径定理&lt;/strong&gt;：在G的深度优先森林中，v是u的后代当且仅当发现u时，存在u到v的由全部由白色结点构成的路径。&lt;/p&gt;
&lt;h4&gt;边的分类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;树边&lt;/strong&gt;：深度优先森林 &lt;span class=&quot;mathjax&quot;&gt;\(G_\pi\)&lt;/span&gt; 的边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后向边&lt;/strong&gt;：结点u连接到所在深度优先树中一个祖先结点v的边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前向边&lt;/strong&gt;：结点u连接到所在深度优先树中一个后代结点v的边。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;横向变&lt;/strong&gt;：其他所有的边。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一次探索边 (u,v) 时，结点v的颜色会反应边的信息：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;v 为白色：(u,v) 为树边&lt;/li&gt;
&lt;li&gt;v 为灰色：(u,v) 为后向边&lt;/li&gt;
&lt;li&gt;v 为白色：(u,v) 为前向边或横向边&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt; 对无向图G进行DFS时，每条边要么是树边，要么是后向边&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有向图中的横向边在无向图中成为树边或后向边。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;拓扑排序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;拓扑排序&lt;/strong&gt;是G中所有结点的一种线性排序，满足：如果G包含边(u,v)，则u在拓扑排序中处于结点v的前面。&lt;/p&gt;
&lt;p&gt;如下算法完成对有向无环图的拓扑排序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;TOPOLOGICAL-SORT(G)
    call DFS(G) to compute finishing times v.f &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex v
    as each vertex is finished, insert it onto the front of a linked &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; the linked &lt;span class=&quot;hljs-built_in&quot;&gt;list&lt;/span&gt; of vertex&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; 有向图G是无环的当且仅当对其DFS不产生后向边。&lt;/p&gt;
&lt;h3&gt;强连通分量&lt;/h3&gt;
&lt;p&gt;有向图G=(V,E)的 &lt;strong&gt;强连通分量&lt;/strong&gt;为一个最大结点集合 &lt;span class=&quot;mathjax&quot;&gt;\(C \subset V\)&lt;/span&gt;，对于该集合中任意两点可以互相到达。&lt;/p&gt;
&lt;p&gt;定义图G=(V,E)的转置为&lt;span class=&quot;mathjax&quot;&gt;\(G^T=(V,E^T)\)&lt;/span&gt;，其中 &lt;span class=&quot;mathjax&quot;&gt;\(E^T = \{ (u,v): (v,u) \in E \}\)&lt;/span&gt;。下面的线性时间（&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(V+E)\)&lt;/span&gt;）算法使用两次DFS计算G的强连通分量。分别运行在G和&lt;span class=&quot;mathjax&quot;&gt;\(G^T\)&lt;/span&gt;上。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;STRONGLY-CONNECTED-COMPONENTS(G)
    call DFS(G) to compute finishing times u.f &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex u
    compute G^T
    call DFS(G^T), but in the main loop of DFS, consider the vertices in order of decreasing u.f
    output the vertices of each tree in the DFS forest formed in line &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; as a separate strongly connected component&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;对G的DFS建立了深度优先森林，计算 &lt;span class=&quot;mathjax&quot;&gt;\(G^T\)&lt;/span&gt; 将该森林中所有边反转，对 &lt;span class=&quot;mathjax&quot;&gt;\(G^T\)&lt;/span&gt; 的DFS选择从上述森林的根结点出发，尝试到达原来的叶结点，能走通的结点加入到强连通分量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; C和C&amp;#39;为G的两个不同的强连通分量，&lt;span class=&quot;mathjax&quot;&gt;\(u,v\in C\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(u‘,v’\in C‘\)&lt;/span&gt;。如果G包含u到u’的路径，则不可能包含 v&amp;#39; 到 u&amp;#39; 的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; C和C&amp;#39;为G的两个不同的强连通分量，如果存在边 &lt;span class=&quot;mathjax&quot;&gt;\((u,v)\in E\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(u\in C\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(v\in C&amp;#39;\)&lt;/span&gt;，则 f(C)&amp;gt;f(C&amp;#39;)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义d(U)和f(U)为U中所有结点最早和最晚发现时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;推论&lt;/strong&gt; C和C&amp;#39;为G的两个不同的强连通分量，如果存在边 &lt;span class=&quot;mathjax&quot;&gt;\((u,v)\in E^T\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(u\in C\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(v\in C&amp;#39;\)&lt;/span&gt;，则 f(C)&amp;lt;f(C&amp;#39;)。&lt;/p&gt;
&lt;h2&gt;最小生成树&lt;/h2&gt;
&lt;p&gt;对于连同无向图G=(V,E)，我们希望找到一个五环子集 &lt;span class=&quot;mathjax&quot;&gt;\(T\subsetE\)&lt;/span&gt;，既能将所有结点连接起来，又具有最小的权重（&lt;span class=&quot;mathjax&quot;&gt;\(w(T)=\sum_{(u,v)\in T}w(u,v)\)&lt;/span&gt;），由于T无环，T必然是一棵树，称为图G的 &lt;strong&gt;生成树&lt;/strong&gt;，求取该生成树的问题为 &lt;strong&gt;最小生成树问题&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;最小生成树的形成&lt;/h3&gt;
&lt;p&gt;在每一时刻生长最小生成树的一条边，并维护如下循环不变式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在每次循环之前，边集合A是某棵最小生成树的一个子集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样不破坏循环不变式的的边(u,v)称为集合A的 &lt;strong&gt;安全边&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;GENERIC-MST(G,w)
    A=NULL
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; A does not form a spanning tree
        find an edge(u,v) that is safe &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; A
        A = A U {(u,v)}
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; A&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;无向图G=(V,E)的一个 &lt;strong&gt;切割&lt;/strong&gt;(S,V-S)是集合V的一个划分。如果一条边 &lt;span class=&quot;mathjax&quot;&gt;\((u,v)\in E\)&lt;/span&gt; 的一个端点位于S，另一个端点位于V-S，则称该边 &lt;strong&gt;横跨&lt;/strong&gt;该切割。如果集合A中不存在横跨该切割的边，则称该切割 &lt;strong&gt;尊重&lt;/strong&gt;集合A。在横跨一个切割的所有边中，权重最小的边称为 &lt;strong&gt;轻量级边&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt; 设G=(V,E)是一个在边E上定义了实数权重函w的连通无向图。A为E的子集，且在G的某棵最小生成树中。(S,V-S)为尊重集合A的任意一个切割。(u,v)是横跨该切割的一条轻量级边。则边(u,v)对于集合A是安全的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设(u.v)不在最小生成树T中，因u v必然在树中相连，故(u,v)与树中两者的连线构成环。至少有两边横跨该切割，一边为(u,v)，设另一边为(x,y)。考虑新的一棵生成树：T&amp;#39;=T-{(x,y)}+{(u,v)}，因(u,v)是轻量级边，故w(T&amp;#39;)不大于w(T)，即T&amp;#39;也是最小生成树。显然(x,y)不在A中，于是A与(u,v)都在T&amp;#39;中，即(u,v)对于集合A是安全的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;推论&lt;/strong&gt; 设G=(V,E)是一个在边E上定义了实数权重函w的连通无向图。A为E的子集，且在G的某棵最小生成树中。设 &lt;span class=&quot;mathjax&quot;&gt;\(C=(V_C,E_C)\)&lt;/span&gt;为森林 &lt;span class=&quot;mathjax&quot;&gt;\(G_A=(V,A)\)&lt;/span&gt; 中的一棵树。如果边(u,v)是连接C 和 &lt;span class=&quot;mathjax&quot;&gt;\(G_A\)&lt;/span&gt; 中其他树的一条轻量级边，则该边对于A是安全的。&lt;/p&gt;
&lt;h3&gt;Kruskal算法和Prim算法&lt;/h3&gt;
&lt;h4&gt;Kruskal算法&lt;/h4&gt;
&lt;p&gt;在所有连接森林中两棵不同树的边里面，找到权重最小的加入最小生成树。Kruskal算法属于贪心算法。&lt;/p&gt;
&lt;p&gt;FIND-SET(u)用来返回包含u的集合的代表元素，UNION过程对两棵树进行合并，判断FIND-SET(u)==FIND-SET(v)可知两点是否在同一集合。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;MST-KRUSKAL(G,w)
    A=NULL
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex v in G.V
        MAKE-SET(v)    &lt;span class=&quot;hljs-comment&quot;&gt;//each tree contains one vertex&lt;/span&gt;
    sort the edges of G.E into nondecreasing order by weight w
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each edge(v,u) in G.E, taken in nondecreasing order by weight w
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; FIND-SET(u) != FIND-SET(v)
            A = A U {(u,v)}
            UNION(u,v)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; A&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;共有O(E)个FIND-SET和UNION操作，|V|个MAKE-SET操作，故总运行时间为 O(E lgV + V lgV) = O(E lgE)（对于连通图：&lt;span class=&quot;mathjax&quot;&gt;\(E \geq V-1\)&lt;/span&gt;）。注意到 &lt;span class=&quot;mathjax&quot;&gt;\(|E|&amp;lt;|V|^2\)&lt;/span&gt;，运行时间为O(E lgV)。&lt;/p&gt;
&lt;h4&gt;Prim 算法&lt;/h4&gt;
&lt;p&gt;集合A中的边总是构成一棵树，每次选择一条轻量级边加入A。Prim算法属于贪心算法。&lt;/p&gt;
&lt;p&gt;所有不在A中的结点存放于以key为权值的最小优先队列Q中。对每一个结点v，v.key保存连接v和树中结点的所有边中最小边的权重。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;MST-PRIM(G,w,r)    &lt;span class=&quot;hljs-comment&quot;&gt;//对于任意指定的根结点r，都可生成拥有同样边集合的树&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each u in G.V
        u.key = MAX
        u.pi = NIL
    r.key = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    Q = G.V
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; Q!=NULL
        u = EXTRACT-MIN(Q)
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each v in G.Adj[u]
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; v in Q and w(u,v) &amp;lt; v.key
                v.pi = u
                v.key = w(u,v)&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;每次循环结束后，保证了下一次循环中EXTRACT-MIN得到的u都是最小生成树中的结点（因为本次循环中(u,v)为轻量级边）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建造堆的时间为 O(V)；EXTRACT-MIN的时间为 O(lg V)，遍历结点循环次数为 |V|；修改key用到的DECREASE-KEY在二叉最小堆的时间为 O(lg V)，在斐波那契堆的时间为 O(1)，遍历边循环次数为|E|。故算法MST-PRIM的运行时间为 O(V + V lgV + E lgV)=O(E lgV)（最小二叉堆实现）或者 O(E + V lgV)（斐波那契堆实现）。&lt;/p&gt;
&lt;h2&gt;单源最短路径&lt;/h2&gt;
&lt;p&gt;在 &lt;strong&gt;最短路径问题&lt;/strong&gt;中，给定一个带权重的有向图G=(V,E)和权重函数 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;，该函数将每条边映射到实数值的权重。&lt;br&gt;图中一条路径p的 &lt;strong&gt;权重&lt;/strong&gt; w(p) 是构成该路径的所有边的权重之和：&lt;span class=&quot;mathjax&quot;&gt;\(\omega(p)=\sum_{i=1}^k \omega(v_{i-1},v_i)\)&lt;/span&gt;。&lt;br&gt;从结点u到结点 v的 &lt;strong&gt;最短路径权重&lt;/strong&gt; &lt;span class=&quot;mathjax&quot;&gt;\(\delta(u,v) = \begin{cases}\min\{\omega(p):u\to v\},\quad if~there~is~a~path~from~u~to~v}\\ \infty,\quad other\end{cases}\)&lt;/span&gt;&lt;br&gt;&lt;strong&gt;最短路径的最优子结构性质&lt;/strong&gt;：两个结点之间的一条最短路径包含着其他的最短路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短路径问题的几个变体&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;单源最短路径问题&lt;/strong&gt;：给定一个图G=(V,E)，找到从给定 &lt;strong&gt;源点&lt;/strong&gt; &lt;span class=&quot;mathjax&quot;&gt;\(s\inV\)&lt;/span&gt; 到每个结点 &lt;span class=&quot;mathjax&quot;&gt;\(v\in V\)&lt;/span&gt; 的最短路径。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单目的地最短路径问题&lt;/strong&gt;：找到从每个结点 v 到给定 &lt;strong&gt;目的地&lt;/strong&gt;结点 t 的最短路径。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单结点对最短路径问题&lt;/strong&gt;：找到给定结点 u 到给定结点 v 的最短路径。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有结点对最短路径问题&lt;/strong&gt;：对于每对结点 u 和 v，找到从结点 u 到结点 v 的最短路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt;（最短路径的子路径也是最短路径）给定带权重的有向图G=(V,E)和权重函数 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;。设 &lt;span class=&quot;mathjax&quot;&gt;\(p=&amp;lt;v_0,v_1,..,v_k&amp;gt;\)&lt;/span&gt; 为从结点 v0 到结点 vk 的一条最短路径，并且对于任意 i 和 j，&lt;span class=&quot;mathjax&quot;&gt;\(0\leq i \leq j\leq k\)&lt;/span&gt;，设 &lt;span class=&quot;mathjax&quot;&gt;\(p_{ij} = &amp;lt;v_i,v_{i+1},...,v_j&amp;gt;\)&lt;/span&gt; 为路径p中从结点 vi 到结点 vj 的子路径。那么 &lt;span class=&quot;mathjax&quot;&gt;\(p_{ij}\)&lt;/span&gt; 是从结点 vi 到结点 vj 的一条最短路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负权重的边&lt;/strong&gt;&lt;br&gt;如果图G不包含从源点s可到达的权重为负的环路，则对所有结点，最短路径权重都有精确定义；如果从结点s到结点v的某条路经上存在权重为负的环路，我们定义&lt;span class=&quot;mathjax&quot;&gt;\(\delta(s,v)=-\infty\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环路&lt;/strong&gt;&lt;br&gt;最短路径不能包含权重为正值的环路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最短路径表示&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;前驱子图&lt;/strong&gt; &lt;span class=&quot;mathjax&quot;&gt;\(G_\pi = (V_\pi, E_\pi)\)&lt;/span&gt;，其中 &lt;span class=&quot;mathjax&quot;&gt;\(V_\pi = \{ v\in V: v.\pi \neq \rm{NIL} \} \cup \{s\}\)&lt;/span&gt;，&lt;span class=&quot;mathjax&quot;&gt;\(V_\pi = \{ (v.\pi,V) \in E: v\in V_\pi - \{s\}\}\)&lt;/span&gt;。&lt;br&gt;算法终止时，&lt;span class=&quot;mathjax&quot;&gt;\(G_\pi\)&lt;/span&gt;是一棵“最短路径树”：有根结点的树，包括了从源结点 s 到每个可以从 s 到达的结点的一条最短路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;松弛操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对每个结点维护一个属性 v.d，记录从源结点 s 到结点 v 的最短路径权重的上界。称为 &lt;strong&gt;最短路径估计&lt;/strong&gt;。&lt;br&gt;使用 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(V)\)&lt;/span&gt; 运行时间的算法对最短路径估计和前驱结点初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;INITIALIZE-SINGLE-SOURCE(G,s)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex v in G.V
        v.d = MAX
        v.pi = NIL
    s.d = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对一条边(u,v)的 &lt;strong&gt;松弛&lt;/strong&gt;操作：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;RELAX(u,v,w)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; v.d &amp;gt; u.d+w(u,v)
        v.d = u.d+w(u,v)
        v.pi = u&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Bellman-Ford算法&lt;/h3&gt;
&lt;p&gt;Bellman-Ford算法解决的是一般情况下的单源最短路径问题。该算法返回TRUE当且仅当输入图不包含可以从源结点到达的权重为负值的环路。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;BELLMAN-FORD(G,w,s)
    INITIALIZE-SINGLE-SOURCE(G,s)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to |G.V|-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each edge(u,v) in G.E
            RELAX(u,v,w)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each edge(u,v) in G.E
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; v.d&amp;gt;u.d+w(u.v)
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; FALSE
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; TRUE&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总运行时间为 O(VE)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推论&lt;/strong&gt; 设G=(V,E)为一个带权重的源结点为s的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;。图G不包含从 s 可以到达的权重为负值的环路，则对于所有结点 v，存在一条从 s 到 v 的路径当且仅当 BELLMAN-FRD 算法终止时有 &lt;span class=&quot;mathjax&quot;&gt;\(v.d&amp;lt;\infty\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt;（Bellman-Ford算法的正确性）设BELLMAN-FORD算法运行在一带权重的源结点为 s 的有向图 G=(V,E) 上，该图的权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;。如果图G不包含从 s 可以到达的权重为负值的环路，则算法返回 TRUE，且对于所有结点 v，前驱子图 &lt;span class=&quot;mathjax&quot;&gt;\(G_\pi\)&lt;/span&gt; 是一棵根为 s 的最短路径树。如果G包含一条从 s 可以到达的权重为负值的环路，则算法返回FALSE。&lt;/p&gt;
&lt;h3&gt;有向无环图中的单源最短路径问题&lt;/h3&gt;
&lt;p&gt;根据结点的拓扑排序次序来对带权重的有向无环图 G=(V,E) 进行边的松弛操作，便可以在 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(V+E)\)&lt;/span&gt; 时间内计算出从单个源结点到所有结点之间的最短路径。每次对一个结点进行处理时，我们队从该结点发出的所有边进行松弛操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;DAG-SHORTEST-PATHS(G,w,s)
    topologically sort the vertices of G
    INITIALIZE-SINGLE-SOURCE(G,s)
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex u, taken in topologically sorted order
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex v in G.Adj[u]
            RELAX(u,v,w)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;算法的总运行时间为&lt;span class=&quot;mathjax&quot;&gt;\(\Theta(V+E)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt; 如果带权重无环路的有向图G=(V,E)有一个源结点s，则在算法DAG-SHORTEST-PATHS终止时，对于所有结点v，我们有 &lt;span class=&quot;mathjax&quot;&gt;\(v.d=\delta(s,v)\)&lt;/span&gt;，且前驱子图 &lt;span class=&quot;mathjax&quot;&gt;\(G_\pi\)&lt;/span&gt; 是一棵最短路径树。&lt;/p&gt;
&lt;h3&gt;Dijkstra 算法&lt;/h3&gt;
&lt;p&gt;Dijkstra算法解决的是带权重的有向图上单源最短路径问题，该算法要求所有边的权重都为非负值。Dijkstra 算法在运行过程中维持的关键信息是一组结点集合S：从源结点 s 到该集合中每个结点之间的最短路径已经被找到。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;DIJKSTRA(G,w,s
    INITIALIZE-SINGLE-SOURCE(G,s)
    S=NULL
    Q=G.V
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; Q!=NULL
        u = EXTRACT-MIN(Q)
        S=S U {u}
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; each vertex v in G.Adj[u]
            RELAX(u,v,w)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt;（Dijkstra算法的正确性）Dijkstra算法运行在带权重的有向图G=(V,E)时，如果所有权重为非负值，则在算法终止时，对于所有结点 u，有 &lt;span class=&quot;mathjax&quot;&gt;\(u.d=\delta(s,u)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可通过循环不变式证明：4~8行的while语句每次循环开始前，对于每个结点 &lt;span class=&quot;mathjax&quot;&gt;\(v \in S\)&lt;/span&gt;，有 &lt;span class=&quot;mathjax&quot;&gt;\(v.d = \delta(s,v)\)&lt;/span&gt;。&lt;br&gt;Q中最小结点所有连接到S的路径已被探测过，且pi已经标记为最短路径上的前驱结点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;推论&lt;/strong&gt; 如果在带权重的有向图G=(V,E)上运行Dijkstra算法，其中的权重皆为非负值，源点为s，则在算法终止时，前驱子图 &lt;span class=&quot;mathjax&quot;&gt;\(G_\pi\)&lt;/span&gt; 是一棵根结点为 s 的最短路径树。&lt;/p&gt;
&lt;p&gt;Dijkstra算法的时间复杂度同最短路径的 Prim 算法，依赖于最小优先队列的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组实现：&lt;span class=&quot;mathjax&quot;&gt;\(O(V^2+E)=O(V^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最小二叉堆实现：&lt;span class=&quot;mathjax&quot;&gt;\(O((V+E) \lg V)=O(E\lg V)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;斐波那契堆实现：&lt;span class=&quot;mathjax&quot;&gt;\(O(V\lg V + E)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;差分约束和最短路径&lt;/h3&gt;
&lt;h4&gt;线性规划&lt;/h4&gt;
&lt;p&gt;寻找一个 n 维向量 x，使得在由 &lt;span class=&quot;mathjax&quot;&gt;\(Ax\leq b\)&lt;/span&gt;（A为&lt;span class=&quot;mathjax&quot;&gt;\(m \times n\)&lt;/span&gt;矩阵，b为m维向量）给定的m个约束条件下优化目标函数 &lt;span class=&quot;mathjax&quot;&gt;\(\sum^n_{i=1} c_i x_i\)&lt;/span&gt;（c为n维向量，“优化”通常是指取值最大）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有时我们并不关注目标函数，而是仅仅希望找到一个 &lt;strong&gt;可行解&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;差分约束系统&lt;/h4&gt;
&lt;p&gt;在一个 &lt;strong&gt;差分约束系统&lt;/strong&gt;中，线性规划矩阵A的每一行只包括一个1和一个-1，其他项为0。因此 &lt;span class=&quot;mathjax&quot;&gt;\(Ax \leq b\)&lt;/span&gt; 所给出的约束条件变为 m 个涉及 n 个变量的 &lt;strong&gt;差额限制条件&lt;/strong&gt;。其中每个条件可以表示为：&lt;span class=&quot;mathjax&quot;&gt;\(x_j-x_i \leq b_k\)&lt;/span&gt;。这里 &lt;span class=&quot;mathjax&quot;&gt;\(1 \leq i,j \leq n,~i \neq j,~1\leq k \leq m\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; 设向量 &lt;span class=&quot;mathjax&quot;&gt;\(x = (x_1,x_2,...,x_n)\)&lt;/span&gt; 为差分约束系统 &lt;span class=&quot;mathjax&quot;&gt;\(Ax \leq b\)&lt;/span&gt; 的一个可行解，设 d 为任意常数，则 x+d 也睡该差分约束系统的一个解。&lt;/p&gt;
&lt;p&gt;给定差分约束系统 &lt;span class=&quot;mathjax&quot;&gt;\(Ax \leq b\)&lt;/span&gt;，其对应的 &lt;strong&gt;约束图&lt;/strong&gt;是一个带权重的有向图 G=(V,E)，其中：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(V=\{ v_0,v_1,...,v_n \}\)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(E = \{ (v_i,v_j): x_j-x_i \leq b_k~is~a~constraint  \} \cup \{ (v_0,v_1),(v_0,v_2),...,(v_0,v_n) \}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理&lt;/strong&gt; 给定差分约束系统 &lt;span class=&quot;mathjax&quot;&gt;\(Ax \leq b\)&lt;/span&gt;，设G=(V,E)是该系统对应的约束图，如果G不包含权重为负的环路，则&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(x = (\delta(v_0,v_1),\delta(v_0,v_2),...,\delta(v_0,v_n))\)&lt;/span&gt;&lt;br&gt;为该系统的一个可行解。如果图G包含权重为负值的环路，该系统没有可行解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对任意一条边(vi,vj)，根据三角不等式，&lt;span class=&quot;mathjax&quot;&gt;\(\delta(v_0,j_j) \leq \delta(v_0,v_i) + \omega(v_i,v_j)\)&lt;/span&gt;，即 &lt;span class=&quot;mathjax&quot;&gt;\(\delta(v_0,v_j) - \delta(v_0,v_i) \leq w(v_i,v_j)\)&lt;/span&gt;，即 &lt;span class=&quot;mathjax&quot;&gt;\(x_j - x_i \leq b_k\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;最短路径性质&lt;/h3&gt;
&lt;h4&gt;三角不等式性质&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt;（三角不等式）设G=(V,E)为一个带权重的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;，源点为s。则对于所有边 &lt;span class=&quot;mathjax&quot;&gt;\((u,v)\in E\)&lt;/span&gt;，我们有：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\delta(s,v) \leq \delta(s,u) + \omega(u,v)\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;最短路径估计值的松弛效果&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt;（上界性质）设G=(V,E)为一个带权重的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;，源点为s。该图由算法 INITIALIZE-SINGLE-SOURCE(G,s)执行初始化。那么对于所有结点 &lt;span class=&quot;mathjax&quot;&gt;\(v \in V, v.d \geq \delta(s,v)\)&lt;/span&gt;，并且该不变式在对图G的边进行任何次序的松弛过程中保持成立。而且一旦v.d取得其下界将不再变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推论&lt;/strong&gt;（非路径性质）设G=(V,E)为一个带权重的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;，假定从源结点 s 到给定结点 v 之间不存在路径，则在该图由算法 INITIALIZE-SINGLE-SOURCE(G,s)进行初始化后，我们有 &lt;span class=&quot;mathjax&quot;&gt;\(v.d = \delta(s,v) = \infty\)&lt;/span&gt;，并且该等式一直维持到G的所有松弛操作结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; 设G=(V,E)为一个带权重的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;。那么对边 &lt;span class=&quot;mathjax&quot;&gt;\((u,v) \in E\)&lt;/span&gt; 进行 RELAX(u,v,w)后，有 &lt;span class=&quot;mathjax&quot;&gt;\(v.d \deq u.d + \omega(u,v)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这即是松弛操作所做的工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt;（收敛性质）设G=(V,E)为一个带权重的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;，s为某个源点，&lt;span class=&quot;mathjax&quot;&gt;\(s \to u \to v\)&lt;/span&gt; 为G中的一条最短路径。假定G由INITIALIZE-SINGLE-SOURCE(G,s)初始化，并在这之后做了一系列松弛操作，其中包括对边(u,v)的松弛操作 RELAX(u,v,w)。如果在对边(u,v)进行松弛操作前的任意时刻有 &lt;span class=&quot;mathjax&quot;&gt;\(u.d = \delta(s,u)\)&lt;/span&gt;，则在该松弛操作之后的所有时刻有 &lt;span class=&quot;mathjax&quot;&gt;\(v.d = \delta(s,v)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt;（路径松弛性质）设G=(V,E)为一个带权重的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;，s为某个源点，考虑从s到vk的任意一条最短路径&lt;span class=&quot;mathjax&quot;&gt;\(p=&amp;lt;v_0,v_1,...,v_k&amp;gt;\)&lt;/span&gt;。如果G由INITIALIZE-SINGLE-SOURCE(G,s)进行初始化，并在这之后进行了一系列的松弛操作，包括对 &lt;span class=&quot;mathjax&quot;&gt;\((v_0,v_1),(v_1,v_2),...,(v_{k-1},v_k)\)&lt;/span&gt; 按照所列次序而进行的松弛操作，则在这些操作后我们有 &lt;span class=&quot;mathjax&quot;&gt;\(v_k.d =  \delta(s,v_k)\)&lt;/span&gt;，并且该等式一直保持成立。该性质的成立与其他边的松弛操作及次序无关。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用归纳法证明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;松弛操作与最短路径树&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt; 设G=(V,E)为一个带权重的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;，s为某个源点，假定图中不包含从s可以到达的权重为负值的环路，则在图G由INITIALIZE-SINGLE-SOURCE(G,s)进行初始化之后，前驱子图 &lt;span class=&quot;mathjax&quot;&gt;\(G_\pi\)&lt;/span&gt; 形成根为s的有根树，并且对任何对G的边进行的任意松弛操作都将维持该性质不变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引理&lt;/strong&gt;（前驱子图性质）设G=(V,E)为一个带权重的有向图，其权重函数为 &lt;span class=&quot;mathjax&quot;&gt;\(\omega: E \to \vec{\bm{R}}\)&lt;/span&gt;，s为某个源点，假定图中不包含从s可以到达的权重为负值的环路，由INITIALIZE-SINGLE-SOURCE(G,s)对G进行初始化，然后对G的边进行任意次序的松弛操作。该松弛操作序列将针对所有结点生成 &lt;span class=&quot;mathjax&quot;&gt;\(v.d = \delta(s,v)\)&lt;/span&gt;，则前驱子图 &lt;span class=&quot;mathjax&quot;&gt;\(G_\pi\)&lt;/span&gt; 形成根为s的最短路径树。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可用 cut &amp;amp; paste 证明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;所有结点对的最短路径问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前驱结点矩阵&lt;/strong&gt; &lt;span class=&quot;mathjax&quot;&gt;\(\Pi = (\pi_{ij})\)&lt;/span&gt;，其中 &lt;span class=&quot;mathjax&quot;&gt;\(\pi_{ij}\)&lt;/span&gt; 在 i=j 或 i到j不存在路径时为 NIL，其他情况为 i 到 j 最短路径上j的前驱结点。对每个结点 i，定义图G对于结点 i 的 &lt;strong&gt;前驱子图&lt;/strong&gt;为 &lt;span class=&quot;mathjax&quot;&gt;\(G_{\pi,i} = (V_{\pi,i}, E_{\pi,i})\)&lt;/span&gt;，其中&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(V_{\pi,i} = \{ j \in V: \pi_{i,j} \neq NIL\} \cup \{ i \},\quad E_{\pi,i} = \{ (\pi_{ij},j): j \in V_{\pi,i} - \{i\}\}\)&lt;/span&gt;&lt;br&gt;如果 &lt;span class=&quot;mathjax&quot;&gt;\(G_{\pi,i}\)&lt;/span&gt;是一棵最短路径树，如下算法将打印 i 到 j 的一条最短路径。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;PRINT-ALL-PAIRS-SHORTEST-PATH(PI, i, j)
    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i==j
        print i
    elseif PI[i,j] == NIL
        print &lt;span class=&quot;hljs-string&quot;&gt;&quot;no path from&quot;&lt;/span&gt; i &lt;span class=&quot;hljs-string&quot;&gt;&quot;to&quot;&lt;/span&gt; j &lt;span class=&quot;hljs-string&quot;&gt;&quot;exists&quot;&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; PRINT-ALL-PAIRS-SHORTEST-PATH(PI, i, PI[i,j])
        print j j&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;最短路径和矩阵算法&lt;/h3&gt;
&lt;h4&gt;递归解&lt;/h4&gt;
&lt;p&gt;定义 &lt;span class=&quot;mathjax&quot;&gt;\(l_{ij}^{(m)}\)&lt;/span&gt; 为 i 到 j 的至多包含 m 条边的所有路径中最小的权重，则：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(l_{ij}^{(0)} = \begin{cases}
0 \quad if~i=j\\
\infty \quad if~i\neq j
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(l_{ij}^{(m)} = \min_{1\leq k \leq n}\{ l_{ik}^{(m-1)} + \omega_{kj} \}\)&lt;/span&gt;，其中 &lt;span class=&quot;mathjax&quot;&gt;\(\omega_{jj} = 0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而最短路径由下式给出：&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\delta(i,j) = l_{ij}^{(n-1)}\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;算法实现&lt;/h4&gt;
&lt;p&gt;设 &lt;span class=&quot;mathjax&quot;&gt;\(L^{(m)} = (l^{(m)}_{ij})\)&lt;/span&gt;，则 &lt;span class=&quot;mathjax&quot;&gt;\(L^{(1)} = (\omega_{ij})\)&lt;/span&gt;。下面伪代码程序可以在给定 &lt;span class=&quot;mathjax&quot;&gt;\(W=(\Omega_{ij})\)&lt;/span&gt;和 &lt;span class=&quot;mathjax&quot;&gt;\(L^{(m-1)}\)&lt;/span&gt; 的情况下，计算 &lt;span class=&quot;mathjax&quot;&gt;\(L^{(m)}\)&lt;/span&gt;（将最短路径扩展一条边）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;EXTEND-SHORTEST-PATHS(L,W)
    n = L.rows
    let L&#39; be a new nXn matrix
    for i=1 to n
        for j=1 to n
            l&#39;[i,j] = MAX
            for k=1 to n
                l&#39;[i,j] = min(l&#39;[i,j], l[i,k]+w[k,j])
    return L&#39;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该算法运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;下面伪代码程序在 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^4)\)&lt;/span&gt; 时间内计算出 &lt;span class=&quot;mathjax&quot;&gt;\(L^{(n-1)}\)&lt;/span&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;SLOW-ALL-PAIRS-SHORTEST-PATHS(W)
    n = W.rows
    L1 = W
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; m=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; to n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        let Lm be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; nXn matrix
        Lm = EXTEND-SHORTEST-PATHS(L(m-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;),W)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; L(n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;矩阵转换&lt;/h4&gt;
&lt;p&gt;注意到递归式相似于矩阵相乘的规则：&lt;span class=&quot;mathjax&quot;&gt;\(c_{ij} = \sum_{k=1}^n a_{ik} \cdot b_{kj}\)&lt;/span&gt;。且算法结构与 SQUARE-MATRIX-MULTIPLY(A,B) 一致。可以使用矩阵乘法的交换性改进算法性能。仅用 &lt;span class=&quot;mathjax&quot;&gt;\(\lceil \lg (n-1) \rceil\)&lt;/span&gt; 次矩阵乘积计算矩阵 &lt;span class=&quot;mathjax&quot;&gt;\(L^{(n-1)}\)&lt;/span&gt;。计算方法如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(L^{(1)} = W\)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(L^{(2)} = L^{(1)} \cdot L^{(1)}\)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(L^{(4)} = L^{(2)} \cdot L^{(2)}\)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\cdot \cdot \cdot\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面过程使用 &lt;strong&gt;重复平方&lt;/strong&gt;技术来计算上述矩阵序列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;FASTER-ALL-PAIRS-SHORTEST-PATHS(W)
    n=W.rows
    L(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) = W
    m = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; m &amp;lt; n-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        let L(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;m) be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; nXn matrix
        L(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;m) = EXTEND-SHORTEST-PATHS(L(m), L(m))
        m = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;m
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; L(m)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;算法运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^3 \lg n)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Floyd-Warshall 算法&lt;/h3&gt;
&lt;h4&gt;递归解&lt;/h4&gt;
&lt;p&gt;设 &lt;span class=&quot;mathjax&quot;&gt;\(d_{ij}^{(k)}\)&lt;/span&gt; 为 i 到 j 的中间结点都在 {1,2,...,k} 的最短路径的权重。显然 &lt;span class=&quot;mathjax&quot;&gt;\(d_{ij}^{(0)}=\omega_{ij}\)&lt;/span&gt;，&lt;br&gt;&lt;span class=&quot;mathjax&quot;&gt;\(d_{ij}^{(k)} = \begin{cases}
\omega_{ij} \quad k=0\\
\min\left(d_{ij}^{(k-1)},d_{ik}^{(k-1)} + d_{kj}^{(k-1)}\right) \quad k \geq 1
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;矩阵 &lt;span class=&quot;mathjax&quot;&gt;\(D^{(n)} = (d_{ij}^{(n)})\)&lt;/span&gt; 给出了 &lt;span class=&quot;mathjax&quot;&gt;\(\delta(i,j) = d_{ij}^{(n)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;算法实现&lt;/h4&gt;
&lt;p&gt;Floyd-Warshalll 算法将所有点编号，逐个加入结果矩阵。输入为 &lt;span class=&quot;mathjax&quot;&gt;\(n\times n\)&lt;/span&gt; 的矩阵 W，算法返回最短路径权重矩阵 &lt;span class=&quot;mathjax&quot;&gt;\(D^{(n)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;FLOYD-WARSHALL(W)
    n = W.rows
    D(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) = W
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
        let D(k) be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; nXn matrix
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
                d[i,j](k) = min(d[i,j](k-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;), d[i,k](k-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) + d[k,j](k-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; D(n)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该算法运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;构建最短路径&lt;/h4&gt;
&lt;p&gt;我们可以在计算矩阵 &lt;span class=&quot;mathjax&quot;&gt;\(D^{(k)}\)&lt;/span&gt; 的同时计算前驱矩阵 &lt;span class=&quot;mathjax&quot;&gt;\(\Pi\)&lt;/span&gt;，下面给出 &lt;span class=&quot;mathjax&quot;&gt;\(\pi_{ij}^{(k)}\)&lt;/span&gt; 的递归式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\pi_{ij}^{(0)} = \begin{cases}
NIL \quad if~i=j ~ or ~ \omega_{ij}=\infty \\
i \quad if~i \neq j ~ and ~ \omega_{ij}&amp;lt;\infty
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mathjax&quot;&gt;\(\pi_{ij}^{(k)} = \begin{cases}
\pi_{ij}^{(k-1)} \quad  if~d_{ij}^{(k-1)} \leq d_{ik}^{(k-1)} + d_{kj}^{(k-1)}\\
\pi_{kj}^{(k-1)} \quad if~d_{ij}^{(k-1)} &amp;gt; d_{ik}^{(k-1)} + d_{kj}^{(k-1)}
\end{cases}\)&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;有向图的传递闭包&lt;/h4&gt;
&lt;p&gt;定义图G的 &lt;strong&gt;传递闭包&lt;/strong&gt;为图 &lt;span class=&quot;mathjax&quot;&gt;\(G^* = (V, E^*)\)&lt;/span&gt;，其中 &lt;span class=&quot;mathjax&quot;&gt;\(E^* = \{ (i,j): \quad if there is a path from i to j in G \}\)&lt;/span&gt;。有两种方法可以求得G的传递闭包：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;给E中所有边赋值1，运行 Floyd-Warshall 算法。时间复杂度为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果存在 i 到 j 的路径，则 &lt;span class=&quot;mathjax&quot;&gt;\(d_{ij} &amp;lt; n\)&lt;/span&gt;，否则，&lt;span class=&quot;mathjax&quot;&gt;\(d_{ij} = \infty\)&lt;/span&gt;。时间复杂度为 &lt;span class=&quot;mathjax&quot;&gt;\(\Theta(n^3)\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们定义：如果图G中 i 到 j 的路径的中间结点都取自 {1,2,...,k}，则 &lt;span class=&quot;mathjax&quot;&gt;\(t_{ij}^{(k)} = 1\)&lt;/span&gt;；否则为 0 。&lt;br&gt; 构建传递闭包 &lt;span class=&quot;mathjax&quot;&gt;\(G^*\)&lt;/span&gt; 的方法为：将(i,j) 置于 &lt;span class=&quot;mathjax&quot;&gt;\(E^*\)&lt;/span&gt; 当且仅当 &lt;span class=&quot;mathjax&quot;&gt;\(t_{ij}^{(n)} = 1\)&lt;/span&gt;。其递归定义如下：&lt;br&gt; &lt;span class=&quot;mathjax&quot;&gt;\(t_{ij}^{(0)} = \begin{cases}
 0 \quad if~i\neq j~and~(i,j)\in E\\
 1 \quad if~i=j~or~(i,j) \in E
 \end{cases}\)&lt;/span&gt;&lt;br&gt; &lt;span class=&quot;mathjax&quot;&gt;\(t_{ij}^{(k)} = t_{ij}^{(k-1)} \lor ( t_{ik}^{(k-1)} \land t_{kj}^{(k-1)}) \quad if~k \geq 1\)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即使用逻辑或操作（&lt;span class=&quot;mathjax&quot;&gt;\(\lor\)&lt;/span&gt;）和逻辑与操作（&lt;span class=&quot;mathjax&quot;&gt;\(\land\)&lt;/span&gt;）替换 Floyd-Warshall 算法中的 min 和 +。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如 Floyd-Warshall 算法一样，我们以 k 递增的次序来计算矩阵 &lt;span class=&quot;mathjax&quot;&gt;\(T^{(k)} = (t_{ij}^{(k)})\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;TRANSITIVE-CLOSURE(G)
    n = |G.V|
    let T(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; nXn matrix
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; i==j or (i,j) in G.E
                t[i,j](&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;
                t[i,j](&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; k=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
        let T(k) be a &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; nXn matrix
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; to n
                t[i,j](k) = t[i,j](k-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) or (t[i,k](k-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) and t[k,j](k-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;))
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; T(n)&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;用于稀疏图的 Johnson 算法&lt;/h3&gt;
&lt;p&gt;Johnson算法使用的技术成为 &lt;strong&gt;重新赋予权重&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果图G的所有边权重为非负值，对每个结点运行一次 Dijkstra 算法得到最短路径。使用斐波那契堆时的算法运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(V^2 \lg V + VE\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;如果图G包含权重为负的边，但没有负值环路，那么只有计算出一组非负权重值，然后使用同样的方法。&lt;blockquote&gt;
&lt;p&gt;新赋予的权重应满足下面两个性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对所有结点对，其最短路径不能因权重的变化而变化。&lt;/li&gt;
&lt;li&gt;对所有边，新权重 &lt;span class=&quot;mathjax&quot;&gt;\(w&amp;#39;(u,v)\)&lt;/span&gt; 非负。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;定义新的权重&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义 &lt;span class=&quot;mathjax&quot;&gt;\(w&amp;#39;(u,v) = w(u,v) + h(u) - h(v)\)&lt;/span&gt;，则路径权重 &lt;span class=&quot;mathjax&quot;&gt;\(w&amp;#39;(p) = \sum_{i=1}^k w&amp;#39;(v_{i-1}, v_i) = w(p) + h(v_0) - h(v_k)\)&lt;/span&gt;。即对于同样的结点对，各路径权重增加一个常数，其大小关系不发生变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义图 G&amp;#39; = (V&amp;#39;,E&amp;#39;)，其中 &lt;span class=&quot;mathjax&quot;&gt;\(V&amp;#39;=V \cup \{s\}\)&lt;/span&gt;（s 为新结点），&lt;span class=&quot;mathjax&quot;&gt;\(E&amp;#39; = E \cup \{ (s,v):~v\in V \}\)&lt;/span&gt;。对所有结点 &lt;span class=&quot;mathjax&quot;&gt;\(v \in V&amp;#39;\)&lt;/span&gt;，定义 &lt;span class=&quot;mathjax&quot;&gt;\(h(v) = \delta(s,v)\)&lt;/span&gt;，则根据三角不等式 &lt;span class=&quot;mathjax&quot;&gt;\(h(v)\leq h(u)+w(u,v)\)&lt;/span&gt;，即新的权重 &lt;span class=&quot;mathjax&quot;&gt;\(w&amp;#39;(u,v) = w(u,v)+h(u)-h(v) \geq 0\)&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;算法实现&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;JOHNSON(G,w)
    compute G&#39;
    for v in G.V
        w(s,v) = 0 
    if BELLMAN-FORD(G&#39;,w,s) == FALSE
        print &quot;the input graph contains a negative-weight cycle&quot;
    else
        for each v in G&#39;.V
            h(v) = delta(s,v) computed by the Bellman-Ford algorithm
        for each (u,v) in G&#39;.V
            w&#39;(u,v) = w(u,v) + h(h) - h(v)
        let D be a new nXn matrix
        for each u in G.V
            run DIJKSTRA(G,w&#39;,u) to compute delta&#39;(u,v) for v in G.V
            for each v in G.V
                d[u,v] = delta&#39;[u,v] + h(v) -h(u) //recover the weight
    return D&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用斐波那契堆实现 Dijkstra 算法的最小优先队列，则 Johnson 算法的运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(O(V^2 \lg V + VE)\)&lt;/span&gt;；使用二叉最小堆实现则运行时间为 &lt;span class=&quot;mathjax&quot;&gt;\(O(VE \lg V)\)&lt;/span&gt;。在稀疏图情况下，仍比 Floyd-Warshall 算法的时间表现好。&lt;/p&gt;

</description>
				<pubDate>Mon, 28 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/%E8%AF%BB%E4%B9%A6/introduction-to-algorithms.html</link>
				<guid isPermaLink="true">http://harttle.github.io/%E8%AF%BB%E4%B9%A6/introduction-to-algorithms.html</guid>
			</item>
		
			<item>
				<title>计算机网络</title>
				<description>&lt;h1&gt;概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;分布式系统&lt;br&gt;对于用户是一个统一的整体，只有一个模型或泛型，由操作系统之上的中间件负责实现。&lt;br&gt;eg. 万维网(world wide web)&lt;/li&gt;
&lt;li&gt;计算机网络&lt;br&gt;大量独立的计算机互相连接起来共同完成计算任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;计算机网络的应用&lt;/h2&gt;
&lt;h3&gt;商业应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;资源共享&lt;br&gt;地理位置束缚、客户-服务器模型&lt;/li&gt;
&lt;li&gt;通信媒介&lt;br&gt;电子邮件、电子商务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;家庭应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;即时消息、聊天室 &lt;/li&gt;
&lt;li&gt;对等通信(p2p)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;移动用户&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PDA（personal digital assistants）&lt;/li&gt;
&lt;li&gt;固定无线、移动无线&lt;/li&gt;
&lt;li&gt;WAP 1.0（wireless application protocol）：针对小屏幕简化的Web页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;网络硬件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;广播网络：广播、多播&lt;/li&gt;
&lt;li&gt;点到点：单播&lt;/li&gt;
&lt;li&gt;个人区域网络-&amp;gt;局域网-&amp;gt;城域网-&amp;gt;广域网-&amp;gt;Internet&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;局域网 LAN（local area network）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;总线型网络：以太网 IEEE 802.3&lt;/li&gt;
&lt;li&gt;环形网络：IBM令牌环 IEEE 802.5&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;城域网 MAN（metropolitan area network）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有线电视 &lt;/li&gt;
&lt;li&gt;集中控制：头端&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;广域网 WAN（wide area network）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主机、交换单元、通信子网、传输线、路由器 &lt;/li&gt;
&lt;li&gt;存储转发（分组交换）、路由算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;无线网络&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;系统互联：计算机外部设备 eg. 蓝牙&lt;/li&gt;
&lt;li&gt;无线 LAN：IEEE 802.11&lt;/li&gt;
&lt;li&gt;无线 WAN：蜂窝电话、IEEE 802.16&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;互联网&lt;/h3&gt;
&lt;p&gt;通过网关互相连接起来的网络&lt;/p&gt;
&lt;!--more--&gt;

&lt;h2&gt;网络软件&lt;/h2&gt;
&lt;h3&gt;协议层次&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;协议：通信双方关于如何进行通信的约定&lt;/li&gt;
&lt;li&gt;对等体：不同机器上包含对应层的实体&lt;/li&gt;
&lt;li&gt;接口：定义了下层向上层提供哪些原语操作和服务&lt;/li&gt;
&lt;li&gt;网络体系结构：层和协议的集合&lt;/li&gt;
&lt;li&gt;协议栈：一个特定的系统所使用的一组协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;各层的设计问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;编址机制&lt;/li&gt;
&lt;li&gt;错误控制&lt;/li&gt;
&lt;li&gt;流控制：传送速率&lt;/li&gt;
&lt;li&gt;多路复用、多路解复用：为多个上层会话使用同一个连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;面向连接与无连接的服务&lt;/li&gt;
&lt;li&gt;服务：某一层向它的上一层提供的一组原语&lt;/li&gt;
&lt;li&gt;协议：一组规则，规定同一层对等实体间交换的信息的格式和含义&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参考模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://static.oschina.net/uploads/space/2013/0519/012337_5jas_698768.gif&quot; alt=&quot;MODEL&quot;&gt;&lt;/p&gt;
&lt;h2&gt;网络实例&lt;/h2&gt;
&lt;h3&gt;Internet&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ARPANET：advanced research project agency，比电话网络更好的命令和控制系统。&lt;/li&gt;
&lt;li&gt;NSFNET：national science foundation，使用ARPANET的硬件；首次使用TCP/IP协议。&lt;/li&gt;
&lt;li&gt;Internet：客户-&amp;gt;POP（point of presence，汇接点）-&amp;gt;区域ISP（internet service provider，服务提供商）-&amp;gt;骨干网-&amp;gt;NAP（network access point）-&amp;gt;服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;面向连接的网络：X.25、帧中继、ATM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;X.25：第一个公共的数据网络&lt;/li&gt;
&lt;li&gt;帧中继：无错误控制、无流控制&lt;/li&gt;
&lt;li&gt;ATM（asynchronous transfer mode，异步传输模式）虚电路：155Mbps、622Mbps&lt;/li&gt;
&lt;li&gt;ATM 参考模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://static.oschina.net/uploads/space/2013/0519/015728_Kcl0_698768.jpg&quot; alt=&quot;atm&quot;&gt;&lt;/p&gt;
&lt;h3&gt;以太网&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ALOHANET：短距离无线电波（夏威夷，分上行和下行，通过冲突检测）&lt;/li&gt;
&lt;li&gt;Ethernet：DIX标准（多支路电缆，通过监听电缆确定发送）、令牌（获得令牌的计算机可以发送）、IBM令牌环&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;无线 LAN：802.11&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;有基站模式：访问点（access point）&lt;/li&gt;
&lt;li&gt;无基站模式：ad hoc 网络&lt;/li&gt;
&lt;li&gt;困难：冲突检测、多径衰减、移动性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;网络标准化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;事实（de facto）、法定（de jure）&lt;/li&gt;
&lt;li&gt;电信领域：公共承运商、邮电部（PTT）、国际电信联盟（ITU或CCITT）&lt;/li&gt;
&lt;li&gt;国际标准领域：ISO，成员包括ANSI（美国）、BSI（英国）、AFNOR（法国）、DIN（德国）；电气和电子工程师协会（IEEE）&lt;/li&gt;
&lt;li&gt;Internet 标准领域：IAB（internet activities board）包括IRTF（internet research task force）和IETF（internet engineering task force），通过RFC（request for comments 标准提案-&amp;gt;标准草案）完成标准。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;物理层&lt;/h1&gt;
&lt;h2&gt;数据通信的理论基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;傅里叶分析&lt;/li&gt;
&lt;li&gt;带宽：传输过程中振幅不会明显减弱的一段频率范围&lt;/li&gt;
&lt;li&gt;尼奎斯特定理：无噪声、有限带宽信道的最大传输率=2Hlog2(V) b/s&lt;/li&gt;
&lt;li&gt;香农定理：带宽为H，信噪比为S/N的信道最大传输率=Hlog2(1+S/N)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有导向的传输介质&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;磁介质：物理磁带&lt;/li&gt;
&lt;li&gt;无屏蔽双绞线（UTP，unshielded twisted pair）：3类双绞线（4对在一个塑料套内）；5类双绞线（拧得更紧，串音更少）&lt;/li&gt;
&lt;li&gt;IBM屏蔽双绞线&lt;/li&gt;
&lt;li&gt;同轴电缆：屏蔽性好，可以传输很长距离&lt;/li&gt;
&lt;li&gt;光纤：多模光纤、单模光纤；有源中继器、无源星型结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;无线传输&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;电磁波：调频扩频、直接序列扩频&lt;/li&gt;
&lt;li&gt;无线电传输：VLF、LF、MF（沿地表）；HF、VHF（电离层）&lt;/li&gt;
&lt;li&gt;微波传输：多径衰减、ISM频段&lt;/li&gt;
&lt;li&gt;红外线与毫米波&lt;/li&gt;
&lt;li&gt;光波传输&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;通信卫星&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;异频发射应答器、弯曲管道&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;同步卫星 GEO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Geostationary Earth Orbit&lt;/li&gt;
&lt;li&gt;保持站位、足迹（覆盖范围）、小孔终端（VSAT）、中心站（hub，连接VSAT）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;中间轨道卫星 MEO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Medium Earth Orbit&lt;/li&gt;
&lt;li&gt;GPS：24颗&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;低轨道卫星 LEO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Low Earth Orbit&lt;/li&gt;
&lt;li&gt;铱计划：77颗，改名为镝（66颗卫星）；针对偏远地区的电话用户；太空转发&lt;/li&gt;
&lt;li&gt;Globalstar：48颗；传回地面转发&lt;/li&gt;
&lt;li&gt;Teledesic：288颗；针对internet用户&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;公共交换电话网络&lt;/h2&gt;
&lt;h3&gt;电话系统结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;电话-&amp;gt;本地回路-&amp;gt;端局-&amp;gt;长途干线-&amp;gt;长途局-&amp;gt;中心交换局-&amp;gt;长途局...&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;电话业中的政治学&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ATT分解为ATT长话公司和23个Bell 运行公司（BOC，bell operating company）&lt;/li&gt;
&lt;li&gt;每个LATA（local access and transport areas）内有一个LEC（local exchange carrier）；IXC（IntereXchange carrier）在LATA区域建立POP（point of presence）实现LATA间通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;本地回路&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调制解调器：正弦载波、调频、调幅、波特、码元、QPSK、QAM-16、TCM、V.32 bis(14400bps)、V.34 bis（33.6kbps）、V.90（33.6kbps上行，56kbps下行）、V.92（48kbps上行）&lt;/li&gt;
&lt;li&gt;全双工（同时两个方向的传输）、半双工（同时只有一个方向）、单工（只有一个方向）&lt;/li&gt;
&lt;li&gt;数字用户线路（DSL，digital subscriber lines）、非对称数字用户线路（ADSL，asymmetric DSL）：ATT将整个带宽划分为多个频段，包括语音、上行数据、下行数据&lt;/li&gt;
&lt;li&gt;无线本地回路：ILEC、CLEC、WLL、MMDS、LMDS&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;干线和多路复用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;频分多路复用 FDM&lt;/li&gt;
&lt;li&gt;波分多路复用 WDM&lt;/li&gt;
&lt;li&gt;时分多路复用 TDM&lt;/li&gt;
&lt;li&gt;SONET/SDH&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;交换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;电路交换：建立物理连接&lt;/li&gt;
&lt;li&gt;报文交换：存储转发网络&lt;/li&gt;
&lt;li&gt;分组交换：数据块大小上限&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;移动电话系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按钮启动式通话系统：只有一个信道&lt;/li&gt;
&lt;li&gt;IMTS（improved mobile telephone system）：上行和下行信道&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第一代：模拟语音&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AMPS（advanced mobile phone system）：蜂窝单元、微蜂窝单元、MTSO（mobile telephone switching office，移动电话交换局）、MSC（mobile switching center，移动交换中心）、移交（软移交、硬移交）&lt;/li&gt;
&lt;li&gt;信道：832个全双工信道，包括控制、呼叫、访问、数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第二代：数字语音&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;D-AMPS（数字的高级移动电话系统）：美国，MAHO（移动电话辅助移交），使用FDM、TDM&lt;/li&gt;
&lt;li&gt;GSM（global system for mobile communication，全球移动通信系统）：美国和日本（修订形式），使用FDM、TDM&lt;/li&gt;
&lt;li&gt;CDMA（code division multiple access，码分多路访问）：美国和欧洲、时间片、正交的时间片序列（1为时间片序列、0为其补码）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;第三代：数字语音与数据&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IMT-2000（international mobile telecommunications）：ITU提出，筛选后的提案主要有两个：&lt;/li&gt;
&lt;li&gt;WCDMA（wideband CDMA）：爱立信提出，欧盟称其为UMTS（universal mobile telecomunications system） &lt;/li&gt;
&lt;li&gt;CDMA2000：qualcomm提出&lt;/li&gt;
&lt;li&gt;爱立信购买qualcomm基本方案，提出3G&lt;/li&gt;
&lt;li&gt;2.5G提案：EDGE（enhanced data rates for GSM evolution，基于GSM）、GPRS（general packet radio service，基于D-AMPS或者GSM上的层叠分组网络）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有线电视&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;共天线电视：天线（头端）-&amp;gt;同轴电缆-&amp;gt;分接头-&amp;gt;电视落线&lt;/li&gt;
&lt;li&gt;基于有线电视网络的internet&lt;/li&gt;
&lt;li&gt;HFC（hybrid fiber coax）：交换机-&amp;gt;头端-&amp;gt;光纤干线-&amp;gt;光纤节点-&amp;gt;同轴电缆-&amp;gt;分接头-&amp;gt;住宅（用户间冲突）&lt;/li&gt;
&lt;li&gt;固定电话系统：长途局（由光纤干线相连）-&amp;gt;光纤-&amp;gt;端局-&amp;gt;本地回路-&amp;gt;铜的双绞线-&amp;gt;住宅&lt;/li&gt;
&lt;li&gt;频谱分配：上行数据、下行数据（TV、FM、下行数据流）&lt;/li&gt;
&lt;li&gt;电缆调制解调器（DOCSIS，data over cable service interface specification）：通过电视电缆访问internet&lt;/li&gt;
&lt;li&gt;ASDL与有线电视网&lt;/li&gt;
&lt;li&gt;均使用光纤的骨干网&lt;/li&gt;
&lt;li&gt;有线电视网拥有几百倍与双绞线的承载容量&lt;/li&gt;
&lt;li&gt;有线电视网难以说明有效带宽容量：取决于用户数量和电视节目带宽&lt;/li&gt;
&lt;li&gt;ASDL更可靠：备份电源&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;数据链路层&lt;/h1&gt;
&lt;h2&gt;设计要点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;为网络层提供服务：无确认的无连接服务、有确认的无连接服务、有确认的面向连接服务&lt;/li&gt;
&lt;li&gt;处理传输错误&lt;/li&gt;
&lt;li&gt;流控制：基于反馈的流控制、基于速率的流控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;错误检测与纠正&lt;/h2&gt;
&lt;h3&gt;纠错码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;包含冗余信息，使接收方知道肯定包含哪些信息（前向纠错）&lt;/li&gt;
&lt;li&gt;海明距离：两码字中不同位数&lt;/li&gt;
&lt;li&gt;编码方案的海明距离：合法码字列表中最小的海明距离&lt;/li&gt;
&lt;li&gt;纠错码；为检测d个错误，需要海明距离为d+1的编码方案；为纠正d个错误，需要海明距离为2d+1的编码方案&lt;/li&gt;
&lt;li&gt;海明码：纠正单个错误、突发性错误（每次传送一列，分散错误）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;检错码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;包含冗余信息，使接收方知道发生了错误并请求重传。&lt;/li&gt;
&lt;li&gt;多项式编码（polynomial code），也称CRC（cyclic redundancy check，循环冗余校验码）：在帧尾加入校验和使追加后的帧可以被生成多项式G(x)除尽。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基本数据链路协议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;无限制的单工协议&lt;/li&gt;
&lt;li&gt;单工的停-等协议：等待确认&lt;/li&gt;
&lt;li&gt;有噪声的单工协议：PAR（positive acknowledgement with retransmission，支持重传的肯定确认协议）又称ARQ（automatic repeat request，自动重复请求协议），确认超时后重传&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;滑动窗口协议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;稍待确认&lt;/li&gt;
&lt;li&gt;发送窗口、接收窗口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1位滑动窗口协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;收到确认后发送下一帧&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用回退n帧技术的协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;回避往返延时&lt;/li&gt;
&lt;li&gt;管道化技术：管道容量=带宽*往返延迟&lt;/li&gt;
&lt;li&gt;回退n帧：接收方只接受下一帧&lt;/li&gt;
&lt;li&gt;选择性重传：接收方缓存错误帧后的所有帧&lt;/li&gt;
&lt;li&gt;否定的确认帧（NAK，negative acknowledgement）：避免发送方等待确认超时&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;协议验证&lt;/h2&gt;
&lt;h3&gt;有限状态机模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可达性分析、协议机、初始状态&lt;/li&gt;
&lt;li&gt;模型内容&lt;/li&gt;
&lt;li&gt;S：进程与信道可能的状态集合&lt;/li&gt;
&lt;li&gt;M：能在信道上进行交换的帧的集合&lt;/li&gt;
&lt;li&gt;I：进程初始状态的集合&lt;/li&gt;
&lt;li&gt;T：状态之间转换的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Peri网模型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模型内容&lt;/li&gt;
&lt;li&gt;库所（place）：状态&lt;/li&gt;
&lt;li&gt;变迁（transition）&lt;/li&gt;
&lt;li&gt;弧（arc）&lt;/li&gt;
&lt;li&gt;标记（token）：系统当前的状态&lt;/li&gt;
&lt;li&gt;转换用垂直或水平线表示，标记用粗黑点表示，库所用圆圈表示，&lt;/li&gt;
&lt;li&gt;激活的转换：转换的输入库所中有至少一个输入标记。激活的转换随时可以激发。&lt;/li&gt;
&lt;li&gt;文法：转换用箭头表示，两边为输入输出库所，每一转换对应一条文法。eg. BD-&amp;gt;AC&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据链路层协议示例&lt;/h2&gt;
&lt;h3&gt;HDLC&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;历史&lt;/li&gt;
&lt;li&gt;IBMSDLC（synchronous data link control，同步数据链路控制）协议&lt;/li&gt;
&lt;li&gt;ADCCP（advanced data communication control procedure，高级数据通信控制规程）：ANSI修改&lt;/li&gt;
&lt;li&gt;HDLC（high-level data link control，高级数据链路控制）：ISO修改&lt;/li&gt;
&lt;li&gt;CCITT采纳并修改HDLC作为LAP（link access procedure，链路访问规程），及LAPB&lt;/li&gt;
&lt;li&gt;面向位的协议的帧结构：分界标志序列+地址+控制+数据+校验和+分界标志序列&lt;/li&gt;
&lt;li&gt;三种帧：信息帧、管理帧、无序号的帧&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Internet 中的数据链路层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;internet连接过程：PC中使用TCP/IP的进程-&amp;gt;调制解调器-&amp;gt;拨号电话线（使用PPP的TCP/IP连接）-&amp;gt;调制解调器-&amp;gt;路由器-&amp;gt;路由选择进程...&lt;/li&gt;
&lt;li&gt;PPP（point-to-point protocol，点到点的协议）功能&lt;/li&gt;
&lt;li&gt;成帧的方法：无歧义分割、错误检测&lt;/li&gt;
&lt;li&gt;链路控制协议：LCP（link control protocol）&lt;/li&gt;
&lt;li&gt;协商网络层选项的方法：对每一支持的网络层给出NCP（network control protocol，网络控制协议）&lt;/li&gt;
&lt;li&gt;PPP帧格式与HDLC非常相似&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;介质访问控制子层&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;MAC（medium access control）：用于确定多路访问信道的下一个使用者，属于数据链路层底下部分。用于LAN中，而WAN是用点对点连接（卫星除外）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;信道分配问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LAN与MAN中静态信道分配方案：多用FDM，只能满足少数目拥有繁重任务的用户。&lt;/li&gt;
&lt;li&gt;LAN与MAN中动态信道分配方案：5个假设：站（终端）模型、单信道假设、冲突假设、持续时间/分槽时间、载波监测/无载波检测。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多路访问协议&lt;/h2&gt;
&lt;h3&gt;ALOHA&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;纯ALOHA：随时发送，检测到冲突（或未收到确认）则等待随机时间，尝试再次发送&lt;/li&gt;
&lt;li&gt;分槽ALOHA：等待下一时槽开始时才发送&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;载波检测多路访问协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1-持续CSMA（carrier sense multiple access）：持续检测信道，空闲则立即发送，冲突后等待随机时间后，再次检测和发送&lt;/li&gt;
&lt;li&gt;非持续的CSMA：检测到信道空闲则发送，信道占用则等待随机的时间后重复算法&lt;/li&gt;
&lt;li&gt;p-持续CSMA：检测到空闲，p的可能性发送，1-p的可能性延迟到下一时槽，重复该算法&lt;/li&gt;
&lt;li&gt;冲突检测的CSMA（CSMA/CD，CSMA with collision detection）：传送过程中检测到冲突则立即放弃任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;无冲突的协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;位图协议（一种预留协议，reservation protocol）：每个竞争周期包含N个时槽，j号站要发送则在j时槽传送1位（此时槽j号站专有），这是所有站按照此队列进行传送，都结束后开始另一个N位竞争周期。&lt;/li&gt;
&lt;li&gt;二进制倒计数（binary countdown）协议：要传送的站以二进制传送自己地址（从高位开始），然后取或运算，如果一个站看到自己的高位被改为1则放弃传送。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;有限竞争协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;负载轻时竞争方法更理想；负载重是无冲突协议更好，结合起来形成有限竞争协议（limited-contention protocol）&lt;/li&gt;
&lt;li&gt;自适应树搜索协议（深度优先）：0号时槽，所有站尝试获得信道；若冲突则1号时槽只有左支可以竞争；直到没有冲突，左支某站获得信道，下一时槽只允许右枝竞争。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;波分多路访问协议 WDMA（wavelength division multiple access）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个固定波长接收器：监听控制信道&lt;/li&gt;
&lt;li&gt;一个可调波长发送器：在其他站的控制信道发送信息&lt;/li&gt;
&lt;li&gt;一个固定波长发送器：发送数据&lt;/li&gt;
&lt;li&gt;一个可调波长接收器：选择监听一个数据发送器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;无线LAN协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;隐藏站问题：A检测到B而检测不到C，错误滴认为可以与B通信&lt;/li&gt;
&lt;li&gt;暴露站问题：A检测到介质中B与C的通信，错误的认为不能与D通信&lt;/li&gt;
&lt;li&gt;MACA（multiple access with collision avoidance，避免冲突的多路访问）：A给B发送RTS（request to send），B以CTS（clear to send）应答，这两帧均包含数据长度；此时听到RTS和CTS的站保持足够时间的沉默。&lt;/li&gt;
&lt;li&gt;MACAW（MACA for wireless）：引入ACK帧，及时重传。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;以太网&lt;/h2&gt;
&lt;h3&gt;以太网电缆&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;10Base5 粗同轴电缆（粗以太网），使用插入式分接头，在10Mbps上可支持500m&lt;/li&gt;
&lt;li&gt;10Base2 细同轴电缆（细以太网），BNC连接器（T型接头），这两种通过时间域反射计检测故障。&lt;/li&gt;
&lt;li&gt;10BaseT 双绞线，通过集线器连接&lt;/li&gt;
&lt;li&gt;10BaseF 光纤，支持上千米。每一版本的网络都可以通过中继器（repeater）扩大范围。&lt;/li&gt;
&lt;li&gt;100BaseT4 3类UTP&lt;/li&gt;
&lt;li&gt;100BaseTX 全双工，5类UTP&lt;/li&gt;
&lt;li&gt;100BaseFX 全双工，长距离，两根多模光纤&lt;/li&gt;
&lt;li&gt;1000Base-SX 多模光纤&lt;/li&gt;
&lt;li&gt;1000Base-LX 单模或多模光纤&lt;/li&gt;
&lt;li&gt;1000Base-CX 两对STP（shield twisted pair，屏蔽双绞线）&lt;/li&gt;
&lt;li&gt;1000Base-T 四对5类UTP&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;编码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;曼彻斯特编码：1（高电压+低电压）、0（低电压+高电压）&lt;/li&gt;
&lt;li&gt;差分曼彻斯特编码：间隔起始处没有相变为1，相变为0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;太网的性能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;二元指数后退法：第i次冲突后，随机等待0~2^i-1个时槽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;交换式以太网：核心为交换机，每块插卡构成自己的冲突域&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;逻辑链路控制子层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LLC（logical link control）：IEEE 802.2，与MAC构成数据链路层&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;无线LAN&lt;/h2&gt;
&lt;h3&gt;802.11物理层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;红外线：1M和2Mbps&lt;/li&gt;
&lt;li&gt;FHSS（frequency hopping spread spectrum，调频扩频），使用79个信道，停延时间小于400ms，对多径衰减有很好的抵抗能力&lt;/li&gt;
&lt;li&gt;DSSS（direct sequence spread spectrum，直接序列扩频）：使用巴克序列，每一位需要11个时间片&lt;/li&gt;
&lt;li&gt;OFDM（orthogonal frequency division multiplexing，正交频分多路复用）：802.11a，54Mbps，52个频率&lt;/li&gt;
&lt;li&gt;HR-DSSS（high rate direct sequence spread spectrum，高速率的直接序列扩频）：802.11b，支持1、2、5.5、11Mbps；802.11g为802.11b的增强版本，理论速度为54Mbps。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;802.11 MAC子层&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DCF（distributed coordination function，分布式协调功能），使用CSMA/CA协议，支持两种操作方法&lt;/li&gt;
&lt;li&gt;信道监听：空闲则送出整个帧，冲突后采用二元指数后退法计算等待时间&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虚拟信道监听：以MACAW为基础，NAV（network allocation vector，网络分配向量）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;PCF（point coordination function，点协调功能）：周期性广播信标帧（调频和停延时间、时钟同步等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;PCF与DCF同时运行，4种间隔：&lt;/li&gt;
&lt;li&gt;SIFS（short interframe spacing，短帧间间隔）：允许一个会话中各部分有机会首先被送达&lt;/li&gt;
&lt;li&gt;PIFS（PCF interframe spacing，PCF帧间间隔）：若SIFS后得到授权的站未开始传送，则基站可能广播信标帧或表决帧&lt;/li&gt;
&lt;li&gt;DIFS（DCF interframe spacing，DCF帧间间隔）：若基站未有动作，任一站开始尝试得到信道，冲突采用二元指数后退法&lt;/li&gt;
&lt;li&gt;EIFS（extended interframe spacing，扩展帧间间隔）：收到坏帧和未知帧的站使用这个间隔&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;服务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分发服务：基站提供&lt;/li&gt;
&lt;li&gt;关联：连接到基站&lt;/li&gt;
&lt;li&gt;分离：解除与基站的联系&lt;/li&gt;
&lt;li&gt;重新关联：改变首选基站&lt;/li&gt;
&lt;li&gt;分发：如何路由发送给基站的帧&lt;/li&gt;
&lt;li&gt;融合：翻译非802.11网络的帧&lt;/li&gt;
&lt;li&gt;站服务：单元内部进行&lt;/li&gt;
&lt;li&gt;认证：联系基站，确认新进入的站通过了基站的认证&lt;/li&gt;
&lt;li&gt;解除认证：离开网络&lt;/li&gt;
&lt;li&gt;私密性：指定使用RC4加密算法&lt;/li&gt;
&lt;li&gt;数据投递：参考以太网的模型，不保证可靠性，由上层处理检错和纠错&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;宽带无线网络&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;802.16：无线MAN，或无线本地回路，包括数据链路层与物理层&lt;/li&gt;
&lt;li&gt;带宽分配：FDD（frequency division duplexing，频分双工制）；TDD（time division duplexing，时分双工制）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;蓝牙技术 802.15&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;微微网：蓝牙系统的基本单元。微微网中有一个主节点，可以有7个活动的从节点，255个静观节点。&lt;/li&gt;
&lt;li&gt;分散网：一组互相连接的微微网，通过当作桥的从节点连接&lt;/li&gt;
&lt;li&gt;应用轮廓：一般访问、服务发现、串行端口、一般的对象交换、LAN访问……&lt;/li&gt;
&lt;li&gt;协议栈：物理层（物理无线电、基带）-&amp;gt;数据链路层（基带、链路控制）-&amp;gt;中间件层（电话、服务发现）-&amp;gt;应用程序（应用轮廓）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据链路层交换&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;802.x到802.y的网桥：在LLC层进行翻译&lt;/li&gt;
&lt;li&gt;本地网络互连：网桥使用扩散算法、逆向学习法&lt;/li&gt;
&lt;li&gt;生成树网桥：，采用序列号生成树，低位变为根；解决并行的透明网桥产生的回路&lt;/li&gt;
&lt;li&gt;远程网桥：采用PPP协议，将完整的MAC帧放入净荷域&lt;/li&gt;
&lt;li&gt;交换设施区别：物理层（转发器、集线器）；数据链路层（网桥、交换机）；网络层（路由器）；传输层（传输网关）；应用层（应用网关）&lt;br&gt;*虚拟LAN（VLAN）&lt;/li&gt;
&lt;li&gt;通过网桥或交换机的配置表来路由&lt;/li&gt;
&lt;li&gt;每个端口分配一个VLAN颜色：VLAN所有机器在统一端口才可以&lt;/li&gt;
&lt;li&gt;每个MAC地址分配一个VLAN颜色：从帧中提出MAC地址进行匹配&lt;/li&gt;
&lt;li&gt;每个3层协议或IP分配一个VLAN颜色：须检查净荷域&lt;/li&gt;
&lt;li&gt;IEEE 802.1Q：改变以太网的帧头、可理解VLAN的交换机&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;网络层&lt;/h1&gt;
&lt;h2&gt;设计要点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储-转发分组交换&lt;/li&gt;
&lt;li&gt;向传输层提供服务：独立于路由器技术、路由器数量类型拓扑关系对传输层不可见、跨越多个LAN和WAN进行统一编址&lt;/li&gt;
&lt;li&gt;无连接服务的实现：数据报、数据报子网&lt;/li&gt;
&lt;li&gt;面向连接服务的实现：虚电路（VC，virtual circuit）、虚电路子网；要求建立电路、路由器建立表项、分组只含VC号而不需目标和源地址、路由失效将终止、容易实现服务质量和拥塞控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;路由算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;路由：确定该使用哪一条路径&lt;/li&gt;
&lt;li&gt;转发：当一个分组到达时所采取的的动作&lt;/li&gt;
&lt;li&gt;自适应算法：会根据拓扑结构和流量的变化改变路由决策&lt;/li&gt;
&lt;li&gt;非自适应算法：不会根据当前测量或者估计的流量和拓扑结构，来调整它们的路由决策（静态路由）&lt;/li&gt;
&lt;li&gt;会话路由：虚电路子网中路由，当建立虚电路时才需要确定路由路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优化原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;最优化原则：如果路由器J在I到K的最优路径上，则J到K的最优路径也必定沿着同样的路由路径。&lt;/li&gt;
&lt;li&gt;汇集树：从所有的源到一个制定目标的最优路径的集合构成以目标节点为根的树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;最短路径路由&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;跳数、物理距离、延迟&lt;/li&gt;
&lt;li&gt;Dijkstra标记算法：两个节点间最短路径的算法，初始时所有节点的标记（从源节点沿着当前已知的最佳路径到达该节点的距离）都是暂时的，当已经发现一个标记代表了最短可能路径的时候，标记被变为永久的（以后不再改变）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;扩散算发&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;同样为静态的路由算法&lt;/li&gt;
&lt;li&gt;每一个进来的分组都被发送到除了进来的那条路线之外的每一条输出线路上。&lt;/li&gt;
&lt;li&gt;抑制扩散过程&lt;/li&gt;
&lt;li&gt;分组头包含跳计数器，初始值等于源于目标间路径长度或最坏情形下的长度（子网直径）&lt;/li&gt;
&lt;li&gt;分组头包含序列号，让路由记录已经被扩散过的分组&lt;/li&gt;
&lt;li&gt;选择性扩散：只输出到大概方向正确的线路上&lt;/li&gt;
&lt;li&gt;扩散法并不实用，但其高度健壮性可用于军事用途&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;距离矢量路由&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;属于动态的路由算法&lt;/li&gt;
&lt;li&gt;每个路由器维护一张表（即一个矢量），列出已知目标的最佳距离及线路，通过与邻居交换信息不断更新&lt;/li&gt;
&lt;li&gt;Bellman-Ford 路由算法、Ford-Fulkerson算法&lt;/li&gt;
&lt;li&gt;无穷计算问题：X告诉Y它有一条路径的时候，Y无法知道自己是否在这条路径上。每次更新列表，坏消息扩散一步，直至无穷大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;链路状态路由&lt;/h3&gt;
&lt;p&gt;路由器的工作分为5个部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发现邻居节点：启动时发送HELLO分组给邻居，邻居以其网络地址应答&lt;/li&gt;
&lt;li&gt;测量线路开销：发送ECHO分组，得到邻居节点的延迟&lt;/li&gt;
&lt;li&gt;创建链路状态分组：包括发送方标识、序列号、年龄、邻居及其延迟列表&lt;/li&gt;
&lt;li&gt;发布链路状态分组：扩散法&lt;/li&gt;
&lt;li&gt;序列号回转，采用32位序列号&lt;/li&gt;
&lt;li&gt;路由器崩溃，从0开始的下一分组将被作为重复分组而拒绝&lt;/li&gt;
&lt;li&gt;序列号破坏，将作为过时分组而拒绝&lt;/li&gt;
&lt;li&gt;计算新的路由路径：获得所有链路状态分组后，运行Dijkstra算法构建出到所有可能目标的最短路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一路由状态协议是IS-IS（intermediate system-intermediate system，中间系统对中间系统），原用于DECnet、NSFNET骨干网、CDPD、Novell Netware（使用变种NLSP来路由IPX分组），后被ISO采纳为无连接网络层协议CLNP，后被多次修改，如IP协议。&lt;/p&gt;
&lt;p&gt;OSPF采纳了IS-IS，但IS-IS编码方法支持携带多个网络层协议的信息，二OSPF不具备这样的特性。&lt;/p&gt;
&lt;h3&gt;分级路由&lt;/h3&gt;
&lt;p&gt;路由器被划分为区域（region），区域被组织为群（cluster），群被组织为区（zone），区被组织为组（group）。路由器只知道自己所在区域的目标地址。&lt;/p&gt;
&lt;h3&gt;广播路由&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;广播：同时将所有目标发送一个分组&lt;/li&gt;
&lt;li&gt;实现方法&lt;/li&gt;
&lt;li&gt;源机器给每一目标单独发送&lt;/li&gt;
&lt;li&gt;扩散法&lt;/li&gt;
&lt;li&gt;多目标路由：只给必要的路线发送&lt;/li&gt;
&lt;li&gt;汇集树&lt;/li&gt;
&lt;li&gt;逆向路径转发：如果通过常用发送分组的线路到达，则认为是第一份副本并转发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;多播路由&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;只给一组目标发送，而不是发送给所有目标&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;移动主机路由&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主场所：主机的永久性地址&lt;/li&gt;
&lt;li&gt;外部代理：记录当前访问该区域的移动主机&lt;/li&gt;
&lt;li&gt;本地代理：记录主场所在这个区域，当前正在访问其他区域的主机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Ad Hoc 网络中的路由&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个节点包含一个主机和一个路由器，节点两两相邻，则成为Ad Hoc网络或MANET（mobile ad hoc networks，移动Ad Hoc 网络）&lt;/li&gt;
&lt;li&gt;AODV（ad hoc on-demand distance vector）路由算法：类似Bellman-Ford距离矢量算法&lt;/li&gt;
&lt;li&gt;路径发现&lt;/li&gt;
&lt;li&gt;路径维护：活动邻居&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;对等网络中的节点查询&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;节点标识符：IP地址的160位散列值&lt;/li&gt;
&lt;li&gt;键：记录名字的160位散列值，该记录的索引关联信息保存在对应标识符的节点上&lt;/li&gt;
&lt;li&gt;successor(i)返回从i开始第一个实际节点的标识符&lt;/li&gt;
&lt;li&gt;指取表：加快了搜索目标节点IP的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;拥塞控制算法&lt;/h2&gt;
&lt;h3&gt;通用原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;监视系统，检测何时何地发送了拥塞&lt;/li&gt;
&lt;li&gt;将该信息传递到能够采取行动的地方&lt;/li&gt;
&lt;li&gt;调整系统运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;拥塞预防策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;传输层：重传、乱序缓存、确认、流控制、确认超时&lt;/li&gt;
&lt;li&gt;网络层：子网内部的虚电路与数据报、分组排队和服务、分组丢弃、路由算法、分组生存期管理&lt;/li&gt;
&lt;li&gt;数据链路层：重传、乱序缓存、确认、流控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;虚电路子网中的拥塞控制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;准入控制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据报子网中的拥塞控制&lt;/h3&gt;
&lt;p&gt;每条线路关联一个变量 u新 = a u旧 + (1-a)f，a表示了路由器忘记历史有多快&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;警告位：位于分组头，分组到达目标端后，传输实体将警告位复制到下一确认分组，源主机因此削减流量&lt;/li&gt;
&lt;li&gt;抑制分组：路由器直接给源主机送回一个抑制分组 （choke packet）&lt;/li&gt;
&lt;li&gt;逐跳（hop-by-hop）抑制分组：影响沿途的每一跳，收到抑制分组的路由立即减慢该方向的分组（要求分配更多的缓冲区）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;负载丢弃&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;随机的早期检测：RED（random early detection，随机的早期检测）算法，在恶化之前开始丢弃分组&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;抖动控制&lt;/h3&gt;
&lt;p&gt;每一跳都记录期望传输时间，到达晚了就尽快转发，否则多停留一段时间&lt;/p&gt;
&lt;h2&gt;服务质量&lt;/h2&gt;
&lt;h3&gt;好的服务质量所使用的技术&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;过度提供资源&lt;/li&gt;
&lt;li&gt;缓冲能力：接收方在递交数据前缓存起来&lt;/li&gt;
&lt;li&gt;流量整形：在服务器段进行平滑处理；服务等级协定（承运商与顾客）、流量监管（对业务流进行监视）&lt;/li&gt;
&lt;li&gt;漏桶算法：Turner（1986），常数服务时间的单服务器排队系统&lt;/li&gt;
&lt;li&gt;令牌桶：每隔一段时间产生令牌，每送出去一个分组，计数器减一，到零时不再发送分组。令牌足够时以最大速度输出，此后为令牌产生速度&lt;/li&gt;
&lt;li&gt;资源预留：带宽、缓冲区空间、CPU周期&lt;/li&gt;
&lt;li&gt;准入控制&lt;/li&gt;
&lt;li&gt;比例路由：分散流量到多条路径&lt;/li&gt;
&lt;li&gt;分组调度：流之间公平排队、加权的公平排队&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;综合服务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基于流的算法或综合服务（RFC2205~2210）：流式多媒体的体系结构&lt;/li&gt;
&lt;li&gt;资源预留协议（resource reservation protocol，RSVP）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;区分服务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基于类别的服务质量（相对于基于流的服务质量）&lt;/li&gt;
&lt;li&gt;快速型转发：另外的通道&lt;/li&gt;
&lt;li&gt;确保行转发：确保不会丢弃分组&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;标签交换和MPLS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MPLS（multiprotocol label switching，多协议标签交换）：RFC 3031，在数据链路层之上添加MPLS头&lt;/li&gt;
&lt;li&gt;MPLS与VC（虚电路）区别&lt;/li&gt;
&lt;li&gt;MPLS 将多个发往同一目标的分组组合起来（虚电路做不到）&lt;/li&gt;
&lt;li&gt;建立转发表&lt;/li&gt;
&lt;li&gt;虚电路：在建立连接时发送setup packet到网络中建立转发表&lt;/li&gt;
&lt;li&gt;MPLS：&lt;/li&gt;
&lt;li&gt;数据驱动：分组到来时，联系下一跳生成这一分组流（FEC，forwarding equivalence class，转发等价类）的标签；使用有色绳索来避免环&lt;/li&gt;
&lt;li&gt;控制驱动：路由启动时，检查哪些路由路径中自己是最终目标，然后为该路径建立FEC（forwarding equivalence class，转发等价类）并分配标签，将标签传递给邻居，传给所有的路由器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;网络互联&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;多协议路由器&lt;/li&gt;
&lt;li&gt;面向连接的网络互联：级联虚电路&lt;/li&gt;
&lt;li&gt;无连接的网络互联：数据报模型&lt;/li&gt;
&lt;li&gt;隧道技术：将IP分组插入WAN网络层分组净荷域中发送&lt;/li&gt;
&lt;li&gt;互联网路由：内部网关协议、外部网关协议、自治系统（AS，autonomous system）&lt;/li&gt;
&lt;li&gt;分段：每个网络会限制分组的最大长度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Internet上的网络层&lt;/h2&gt;
&lt;p&gt;原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证它能够工作&lt;/li&gt;
&lt;li&gt;尽可能使它简单&lt;/li&gt;
&lt;li&gt;作出明确的选择&lt;/li&gt;
&lt;li&gt;尽可能做到模块化&lt;/li&gt;
&lt;li&gt;期望具备异构性&lt;/li&gt;
&lt;li&gt;避免使用固定不变的选择和参数&lt;/li&gt;
&lt;li&gt;寻找一个好的设计，它不必是最完美的&lt;/li&gt;
&lt;li&gt;对于发送操作一定要严格，而对于接收操作要有一定的容忍度&lt;/li&gt;
&lt;li&gt;要考虑伸缩性&lt;/li&gt;
&lt;li&gt;要考虑性能和代价&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IP协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IPV4头：版本、IHL、服务类型、总长度、标识、DF、MF、分段偏移、生命期、协议、头部校验和、源地址、目的地址、选项&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IP地址&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分类的编制方案（classful addressing）&lt;/li&gt;
&lt;li&gt;A类：0+网络+主机；1.0.0.0~127.255.255.255&lt;/li&gt;
&lt;li&gt;B类：10+网络+主机；128.0.0.0~191.255.255.255&lt;/li&gt;
&lt;li&gt;C类：110+网络+主机；192.0.0.0~223.255.255.255&lt;/li&gt;
&lt;li&gt;D类：1110+多播地址；224.0.0.0~239.255.255.255&lt;/li&gt;
&lt;li&gt;E类：11110+保留将来使用；240.0.0.0~247.255.255.255&lt;/li&gt;
&lt;li&gt;网络号管理：ICANN（internet corporation for assigned names and numbers）&lt;/li&gt;
&lt;li&gt;点分十进制标记法&lt;/li&gt;
&lt;li&gt;子网：通过子网掩码分别路由&lt;/li&gt;
&lt;li&gt;CIDR-Classless InterDomain Routing（无类别域间路由）：RFC 1519，将剩余的IP地址以可变大小块的方式进行分配，而不管它们所属的类别；聚集表项（用二进制地址与掩码标识一组IP地址）&lt;/li&gt;
&lt;li&gt;NAT-网络地址转换&lt;/li&gt;
&lt;li&gt;为每个公司分配一个IP地址用于传输Internet流量；公司内部用每台计算机唯一的IP地址常用来传输内部流量。&lt;/li&gt;
&lt;li&gt;三段保留的IP地址范围如下，包含这些地址的分组不应出现在Internet上&lt;/li&gt;
&lt;li&gt;10.0.0.0-10.255.255.255/8&lt;/li&gt;
&lt;li&gt;172.16.0.0-172.31.255.255/12&lt;/li&gt;
&lt;li&gt;192.168.0.0-192.168.255.255/16&lt;/li&gt;
&lt;li&gt;操作方式：IP分组大多携带UDP或TCP净荷，从中提出目标端口和源端口进行一次转换，以TCP为例&lt;/li&gt;
&lt;li&gt;请求建立TCP连接时，替换TCP的源地址与源端口，替换IP与TCP头部校验和，建立源地址与源端口的表项（共65535个）&lt;/li&gt;
&lt;li&gt;IP分组到达时，取出TCP的目标端口，查找对应的内部IP表项，替换目标端口与目标地址，替换IP与TCP头部校验和，转发给内部主机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Internet 控制协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Internet 控制消息协议（ICMP，internet control message protocol）：报告Internet有关事件&lt;/li&gt;
&lt;li&gt;ARP-地址解析协议（address resolution protocol）&lt;/li&gt;
&lt;li&gt;要发送分组的主机首先发送一个广播分组到以太网络，询问IP对应的以太网地址，只有拥有该IP的主机以其以太网地址应答&lt;/li&gt;
&lt;li&gt;优化：1.缓存结果；2.机器启动时广播地址映射，请求查询自己的IP，检测有无冲突（应答）&lt;/li&gt;
&lt;li&gt;RARP（reverse address resolution protocol，反向地址解析协议）：机器启动时询问自己IP，RARP服务器送回它的IP。因受限的广播（全1的目标地址）不会被路由转发，每个网络都需要一个RARP服务器。&lt;/li&gt;
&lt;li&gt;BOOTP：RFC951、1048、1084，机器启动时使用UDP分组来询问自己IP。新加入的主机要系统管理员为它分配IP地址并加入BOOTP配置文件。&lt;/li&gt;
&lt;li&gt;DHCP（dynamic host configuration protocol，动态主机配置协议）：RFC 2131、2132，允许手工分配IP，也允许自动分配。也通过广播发送请求，每一网络有一DHCP中继代理（relay agent），主机先广播DHCP DISCOVER分组，DHCP中继代理单播给DHCP服务器，进而获得IP地址。租用：主机需在租用期到达之前申请续租，否则将释放其IP。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;OSPF-内部网关路由协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OSPF（open shortest path first）将每个AS划分为编号的区域（area），每个AS有一骨干网络（backbone area），编号为0.&lt;/li&gt;
&lt;li&gt;OSPF区分4种路由器：&lt;/li&gt;
&lt;li&gt;内部路由器：完全在一个区域内部&lt;/li&gt;
&lt;li&gt;区域边界路由器：连接两个或多个区域&lt;/li&gt;
&lt;li&gt;骨干路由器：位于骨干区域上&lt;/li&gt;
&lt;li&gt;AS边界路由器：与其他AS中的路由器进行通信&lt;/li&gt;
&lt;li&gt;邻接的：OSPF要求每个LAN中选举出一台指派路由器（designated router），该路由器与该LAN上所有其他路由器都是邻接的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;BGP-外部网关路由协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BGP（border gateway protocol）将网络分为三种：末端网络（与BGP图只有一个连接）、多连接网络（一般可用来传输中转流量）、穿越网络（愿意处理第三方分组，不过有限制条件）&lt;/li&gt;
&lt;li&gt;BGP路由间通过TCP连接通信&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Internet 多播&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IP通过D类地址来支持多播，要通过特殊的多播路由器&lt;/li&gt;
&lt;li&gt;IP支持两种组地址&lt;/li&gt;
&lt;li&gt;永久地址&lt;/li&gt;
&lt;li&gt;224.0.0.1 一个LAN上的所有系统&lt;/li&gt;
&lt;li&gt;224.0.0.2 一个LAN上的所有路由器&lt;/li&gt;
&lt;li&gt;224.0.0.5 一个LAN上的所有OSPF路由器&lt;/li&gt;
&lt;li&gt;224.0.0.6 一个LAN上的所有指派路由器&lt;/li&gt;
&lt;li&gt;临时组：进程要求主机加入或离开某个组，主机记录它的进程属于哪个组&lt;/li&gt;
&lt;li&gt;查询和应答分组使用IGMP（internet group management protocol）协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;移动IP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可通过主动ARP（gratuitous ARP）更新路由器的映射缓存&lt;/li&gt;
&lt;li&gt;外部代理通过定时发送广告分组（advertisement）来通知新进入的主机&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IPv6&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IPv6为IEEE Network发表的SIPP（simple internet protocol plus，增强的简单Internet协议）&lt;/li&gt;
&lt;li&gt;IPv6头部：版本、流量类别、流标签、净荷长度、下一个头、跳数限制、源地址、目标地址&lt;/li&gt;
&lt;li&gt;扩展头部：为兼容IPv4，跟在固定头部的后面（可以有多个）&lt;/li&gt;
&lt;li&gt;16字节固定长度编址&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;传输层&lt;/h1&gt;
&lt;h2&gt;传输服务&lt;/h2&gt;
&lt;h3&gt;向上层提供的服务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;传输实体：传输层内部，利用网络层提供的服务，向它的用户提供高效、可靠和性价比合理的服务的硬件/软件&lt;/li&gt;
&lt;li&gt;传输服务提供者、传输服务用户&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;传输服务原语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;LISTEN、CONNECT、SEND、RECEIVE、DISCONNECT&lt;/li&gt;
&lt;li&gt;TPDU（transport protocol data unit，传输协议数据单元）：从传输实体发送到另一个传输实体的消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;伯克利套接字（berkeley socket）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Berkeley UNIX使用的TCP socket原语：SOCKET、BIND、LISTEN、ACCEPT、CONNECT、SEND、RECV、CLOSE&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;传输协议的要素&lt;/h2&gt;
&lt;h3&gt;编址&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为监听连接请求的进程定义相应的传输地址，Internet：端口（port）；ATM：AAL-SAP；一般术语：TSAP（transport service access point，传输服务访问点）&lt;/li&gt;
&lt;li&gt;同样，网络层的端点称为NSAP（network service access point，网络服务访问点），IP为一个特例。&lt;/li&gt;
&lt;li&gt;初始连接协议：采用进程服务器为那些较少使用的服务器提供代理功能（监听一组端口），请求到达时启动相应的服务器，继承与客户的连接。&lt;/li&gt;
&lt;li&gt;名字服务器（目录服务器）：在特殊硬件运行，不能在用户通话时临时创建&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;建立连接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分组生存周期：受限制的子网设计、分组设置跳计数器、分组时间戳&lt;/li&gt;
&lt;li&gt;TPDU编号，相等编号的TPDU不会同时有效，序列号空间应足够大，序列号回绕时同样编号的TPDU都已经消失&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;释放连接&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;两军队问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;流控制和缓冲&lt;/h3&gt;
&lt;h3&gt;多路复用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;向上多路复用：传输实体将TPDU交给上层指定的进程&lt;/li&gt;
&lt;li&gt;向下多路复用：将流量分布到多个网络连接&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;崩溃恢复&lt;/h3&gt;
&lt;h2&gt;有限状态机描述传输协议&lt;/h2&gt;
&lt;h2&gt;Internet 传输协议-UDP&lt;/h2&gt;
&lt;h3&gt;UDP介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;UDP（User Datagram Protocol，用户数据报协议）数据段由8字节头和净荷域构成。&lt;/li&gt;
&lt;li&gt;UDP头：源端口、目标端口、UDP长度、UDP校验和&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;远过程调用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RPC（remote procedure call，远过程调用）：让远程调用像本地过程调用一样，客户程序需要绑定一个小的库过程（客户存根），服务器程序绑定一个服务器存根。&lt;/li&gt;
&lt;li&gt;参数包装：列集（marshaling）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;实时传输协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RTP（real-time transport protocol，实时传输协议）：RFC 1889&lt;/li&gt;
&lt;li&gt;用户空间（多媒体应用-&amp;gt;RTP）-&amp;gt;套接字接口-&amp;gt;操作系统内核（UDP-&amp;gt;IP-&amp;gt;以太网）&lt;/li&gt;
&lt;li&gt;RTCP（realtime transport control protocol，实时传输控制协议）：处理反馈、同步和用户界面等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Internet 传输协议-TCP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TCP（transport control protocol，传输控制协议）：在不可靠的互联网络提供一个可靠的端到端字节流。&lt;/li&gt;
&lt;li&gt;TCP服务模型：16位端口，1024以下为知名端口&lt;/li&gt;
&lt;li&gt;守护进程（unix中称inetd，internet daemon）：同时关联到多个端口，连接进入时fork出新的进程&lt;/li&gt;
&lt;li&gt;紧急数据：URGENT标记&lt;/li&gt;
&lt;li&gt;TCP数据段（TCP segment）；MTU（maximum transfer unit，最大传输单元），以太网通常为1500字节净荷。&lt;/li&gt;
&lt;li&gt;TCP数据段（包括20字节的头）：源端口、目标端口、序列号、确认号、TCP长度、URG、ACK、PSH、PST、SYN、FIN、窗口大小、校验和、紧急指针、可选项、数据&lt;/li&gt;
&lt;li&gt;TCP连接的建立：SYN(SEQ=x)-&amp;gt;SYN(SEQ=y, ACK=x+1)-&amp;gt;SYN(SEQ=x+1, ACK=y+1)&lt;/li&gt;
&lt;li&gt;TCP传输策略：Nagle算法，数据进入发送方后只发送第一字节，其后的字节缓冲起来，直到第一字节被确认为止。&lt;/li&gt;
&lt;li&gt;TCP拥塞控制：网络容量（拥塞窗口）、接收方容量（接收方准许窗口）、慢启动法、阈值&lt;/li&gt;
&lt;li&gt;TCP定时器管理：重传定时器、持续定时器（确认超时的探询消息）、保活定时器（一段时间后发送，对方不应答则终止连接）&lt;/li&gt;
&lt;li&gt;无线TCP和UDP：间接TCP、同质的网络&lt;/li&gt;
&lt;li&gt;事务型TCP：用UDP来实现RPC的高效率，用TCP实现可靠性，T/TCP（transaction TCP，事务型TCP）；SCTP（stream control transmission protocol，流控制传输协议）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;性能问题&lt;/h2&gt;
&lt;p&gt;广播风暴、带宽-延迟乘积&lt;/p&gt;
&lt;h3&gt;网络性能的测量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;确保样本空间足够大&lt;/li&gt;
&lt;li&gt;确保样本具有代表性&lt;/li&gt;
&lt;li&gt;使用粗粒度时钟时要谨慎&lt;/li&gt;
&lt;li&gt;确保在测试过程中不会发生不可预知的事情&lt;/li&gt;
&lt;li&gt;缓存机制可能会破坏测量的正确性&lt;/li&gt;
&lt;li&gt;理解所测量的指标&lt;/li&gt;
&lt;li&gt;在往外推广结果时要谨慎&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;具有更好性能的系统设计&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CPU速度比网络速度更加重要&lt;/li&gt;
&lt;li&gt;减少分组的数量可以减少软件开销&lt;/li&gt;
&lt;li&gt;使环境切换的次数减到最少&lt;/li&gt;
&lt;li&gt;使复制操作的次数减到最少&lt;/li&gt;
&lt;li&gt;可以购买更多的带宽，但无法要求更低的延迟&lt;/li&gt;
&lt;li&gt;应该想办法避免拥塞，而不是从拥塞中恢复&lt;/li&gt;
&lt;li&gt;避免超时&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;快速的TPDU处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分离出正常的发送操作病对它们作特殊处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;针对千兆网络的协议&lt;/h3&gt;
&lt;p&gt;旧的协议面临的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32位序列号：对于1Gbps的以太网，一轮序列号回绕时间为34s，大于internet上最大分组生存周期120s&lt;/li&gt;
&lt;li&gt;通信速度的提高比计算速度的提高快得多&lt;/li&gt;
&lt;li&gt;如果一条线路的带宽-延迟乘积非常大，则回退n步协议的性能会非常差&lt;/li&gt;
&lt;li&gt;千兆位线路本质上不同于1兆位线路，因为长的千兆位线路的主要制约因素是延迟，而不是带宽&lt;/li&gt;
&lt;li&gt;对于许多千兆位应用，分组到达时间的偏差与平均延迟本身一样重要&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;应用层&lt;/h1&gt;
&lt;h2&gt;DNS-域名系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;DNS（Domain name system）：RFC 1034、1035，调用解析器（resolver）将名字映射成IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DNS名字空间&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DNS名字空间：internet被分为200多个顶级域，每个域被分为若干子域，子域又被进一步划分，以此类推。&lt;/li&gt;
&lt;li&gt;顶级域有两种：通用域和国家域&lt;/li&gt;
&lt;li&gt;通用域包括com（商业的）、edu（教育性机构）、int（国际性组织）、mil（美国军队）、net（网络供应商）、org（非营利性组织）、biz（商贸）、info（信息）、name（人们的名字）、pro（职业）、aero（航空业）、coop（合作社）、museum（博物馆）&lt;/li&gt;
&lt;li&gt;国家域定义在ISO 3166中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;资源记录&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每个域都有一组与它相关联的资源记录；当解析器把域名传递给DNS时，DNS所返回的是与该域名相关联的资源记录。&lt;/li&gt;
&lt;li&gt;每条资源记录是一个5元组：Domain_name（域名）、Time_to_live（生存期）、class（类别）、type（类型）、value（值）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;名字服务器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;权威记录：来自于管理该记录的权威机构，因此总是正确的&lt;/li&gt;
&lt;li&gt;递归查询：当解析器接收到一个域名查询时，它将该查询传递给本地的一个名字服务器，如果被查询域名落在该名字服务器的管辖范围内，那么返回权威的资源记录；如果本地没有关于它的信息，那么本地名字服务器向顶级名字服务器发送一条查询此域的消息。&lt;/li&gt;
&lt;li&gt;LDAP（lightweight directory access protocol，轻量级目录访问协议）：RFC 2251，定位到一般的对象，如人员、资源、服务等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;电子邮件&lt;/h2&gt;
&lt;h3&gt;结构与服务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户代理：阅读和发送电子邮件&lt;/li&gt;
&lt;li&gt;消息传输代理：将消息从源端传送到目标端&lt;/li&gt;
&lt;li&gt;电子邮件基本功能 &lt;/li&gt;
&lt;li&gt;撰写&lt;/li&gt;
&lt;li&gt;传输&lt;/li&gt;
&lt;li&gt;报告&lt;/li&gt;
&lt;li&gt;显示&lt;/li&gt;
&lt;li&gt;处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;消息格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RFC 822：基本ASCII电子邮件&lt;/li&gt;
&lt;li&gt;头域：To、Cc、Bcc、From、Sender、Received、Return-Path、Data、Reply-To、Message-Id、In-Reply-To、References、Keywords、Subject&lt;/li&gt;
&lt;li&gt;MIME-多用途Internet邮件扩展&lt;/li&gt;
&lt;li&gt;头域：MIME-Version、Content-Description、Content-Id、Content-Transfer-Encoding、Content-Type&lt;/li&gt;
&lt;li&gt;二进制消息编码（base64编码，又称ASCII盔甲）：0-63分别为A-Z、a-z、0-9、+、/；==与=分别代表一个组只含8位或者16位；对少量非ASCII字符的消息编码效率较低&lt;/li&gt;
&lt;li&gt;可打印的引用编码（quoted-printable encoding）：7位的ASCII编码，所有超过127的字符被编码为等号+2个用16进制数字表示的字符值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;消息传输&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SMTP（simple mail transfer protocol，简单邮件传输协议） &lt;/li&gt;
&lt;li&gt;在25号端口建立TCP连接&lt;/li&gt;
&lt;li&gt;命令：HELLO、MAIL FROM、RCPT TO、DATA等&lt;/li&gt;
&lt;li&gt;ISP服务器上运行消息传输代理，接收邮件&lt;/li&gt;
&lt;li&gt;POP3（post office protocol version 3，邮局协议第三版）&lt;/li&gt;
&lt;li&gt;在110端口建立TCP连接&lt;/li&gt;
&lt;li&gt;RFC 1939，用户从ISP的消息传输代理获得电子邮件&lt;/li&gt;
&lt;li&gt;假设用户每次交互后清除邮箱后脱机工作&lt;/li&gt;
&lt;li&gt;IMAP（internet message access protocol，Internet 消息访问协议）&lt;/li&gt;
&lt;li&gt;在143端口建立TCP连接&lt;/li&gt;
&lt;li&gt;假设用户的邮件会永久地保存在服务器上&lt;/li&gt;
&lt;li&gt;投递特性：过滤器、假期守护程序（自动回复）&lt;/li&gt;
&lt;li&gt;webmail&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;万维网&lt;/h2&gt;
&lt;h3&gt;结构概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;URL（unform resource locator，统一资源定位符）：命名web页面&lt;/li&gt;
&lt;li&gt;组成：协议（也称方案，scheme）+页面所在机器的DNS名字，唯一指定特定页面的本地名字&lt;/li&gt;
&lt;li&gt;协议类型：http（hypertext transfer protocol，超文本传输协议）、ftp、file、news（NNTP，network news transfer protocol，网络新闻传输协议）、gopher、mailto、telnet&lt;/li&gt;
&lt;li&gt;URN（universal resource name，通用资源名）：RFC 2141，不指定页面所在位置就能够引用页面，可减轻服务器负载&lt;/li&gt;
&lt;li&gt;客户端&lt;/li&gt;
&lt;li&gt;浏览器运行步骤&lt;/li&gt;
&lt;li&gt;确定URL&lt;/li&gt;
&lt;li&gt;查询DNS以确定IP&lt;/li&gt;
&lt;li&gt;与IP的80端口建立TCP连接&lt;/li&gt;
&lt;li&gt;发送请求以获取URL指向的文件&lt;/li&gt;
&lt;li&gt;服务器发送文件，释放TCP连接&lt;/li&gt;
&lt;li&gt;浏览器显示文件中的文本，取回并显示图片&lt;/li&gt;
&lt;li&gt;浏览器扩展&lt;/li&gt;
&lt;li&gt;插件：代码模块，浏览器从磁盘取出，安装称自己的一个扩展模块，运行在浏览器内部，完成工作后从浏览器内存中移除掉&lt;/li&gt;
&lt;li&gt;辅助应用程序：完整的应用程序，作为独立的进程来运行，接受临时文件的名字来打开文件&lt;/li&gt;
&lt;li&gt;服务器端&lt;/li&gt;
&lt;li&gt;服务器运行步骤 &lt;/li&gt;
&lt;li&gt;接收来自客户（浏览器）的TCP连接&lt;/li&gt;
&lt;li&gt;获取所需文件名&lt;/li&gt;
&lt;li&gt;从磁盘获取文件&lt;/li&gt;
&lt;li&gt;将文件返回给客户&lt;/li&gt;
&lt;li&gt;释放TCP连接&lt;/li&gt;
&lt;li&gt;服务器场（server farm）&lt;/li&gt;
&lt;li&gt;组织：前端连接到一个LAN中，LAN中有一个路由器和若干处理节点（独立的计算机）&lt;/li&gt;
&lt;li&gt;TCP移交（TCP handoff）：避免所有请求与回复都通过前端&lt;/li&gt;
&lt;li&gt;无状态特性与cookie&lt;/li&gt;
&lt;li&gt;RFC 2109：当用户请求web页面时，可以提供附加信息cookie（最大4k）&lt;/li&gt;
&lt;li&gt;cookie域：域名、路径、内容、过期时间、安全&lt;/li&gt;
&lt;li&gt;非持久的cookie：没有包含过期时间域，浏览器退出时丢弃&lt;/li&gt;
&lt;li&gt;持久的cookie：包含过期时间域&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;静态web文档&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HTML（hypertext markup language，超文本标记语言）&lt;/li&gt;
&lt;li&gt;表单&lt;/li&gt;
&lt;li&gt;XML（extensible markup language，可扩展标记语言）&lt;/li&gt;
&lt;li&gt;XSL（extensible style language，可扩展样式语言）&lt;/li&gt;
&lt;li&gt;SOAP（simple object access protocol，简单对象访问协议）：应用之间执行RPC（远过程调用）的方法，以XML构造请求，以HTTP发送&lt;/li&gt;
&lt;li&gt;XHTML（extended hypertext markup language，扩展的超文本标记语言）：用于小型移动设备，语法更挑剔&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;动态web文档&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;服务器端动态web页面生成（动态html）：CGI（common gateway interface，公共网关接口）、PHP（hypertext preprocessor，超文本预处理器）、JSP（javaserver pages，java服务器页面）、ASP（active server page，活动的服务器页面，ms版的php和jsp）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端动态网页生成：javascript、applet（jvm上运行的java小程序）、activeX控件（ms）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;HTTP-超文本传输协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;连接：HTTP1.0服务器回应后关闭TCP连接；HTTP1.1支持持续连接&lt;/li&gt;
&lt;li&gt;方法：GET、PUT、HEAD、POST、DELETE、TRACE、CONNECT、OPTIONS&lt;/li&gt;
&lt;li&gt;消息头：请求头、回应头&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;性能增强&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;缓存、代理（维护缓存）&lt;/li&gt;
&lt;li&gt;服务器复制：镜像、瞬间拥挤&lt;/li&gt;
&lt;li&gt;内容分发网络：CDN（content delivery network），图像、音频等大文件存储在CDN上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;无线web&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;WAP（wireless application protocol，无线应用协议）使用新的HTML标准，9600bps，协议层&lt;/li&gt;
&lt;li&gt;无线应用环境（WAE)&lt;/li&gt;
&lt;li&gt;无线会话协议（WSP）&lt;/li&gt;
&lt;li&gt;无线传输协议（WTP）：代替TCP，效率原因&lt;/li&gt;
&lt;li&gt;无线传输层安全（WTLS）&lt;/li&gt;
&lt;li&gt;无线数据包协议（WDP）：类似UDP&lt;/li&gt;
&lt;li&gt;承载层（GSM、CDMA、D-AMPS、GPRS等）&lt;/li&gt;
&lt;li&gt;I-Mode（information-mode，信息模式）&lt;/li&gt;
&lt;li&gt;对语音信号使用电路交换网络，对数据信号使用分组交换网络&lt;/li&gt;
&lt;li&gt;数字网络基于CDMA，手持机使用LTP（lightweight transport protocol，轻量级传输协议）并通过空中链路与协议转换网管通话&lt;/li&gt;
&lt;li&gt;软件结构&lt;/li&gt;
&lt;li&gt;用户交互模块&lt;/li&gt;
&lt;li&gt;插件+cHTML（compact HTML，紧凑的HTML）解释器+Java&lt;/li&gt;
&lt;li&gt;简单的窗口管理器&lt;/li&gt;
&lt;li&gt;网络通信&lt;/li&gt;
&lt;li&gt;实时操作系统&lt;/li&gt;
&lt;li&gt;第二代无线web&lt;/li&gt;
&lt;li&gt;新特新&lt;/li&gt;
&lt;li&gt;推模型和拉模型&lt;/li&gt;
&lt;li&gt;运行将电话集成到应用中&lt;/li&gt;
&lt;li&gt;多媒体信息&lt;/li&gt;
&lt;li&gt;264个象形文字&lt;/li&gt;
&lt;li&gt;存储设备接口&lt;/li&gt;
&lt;li&gt;浏览器插件&lt;/li&gt;
&lt;li&gt;wap2.0支持两种协议栈&lt;/li&gt;
&lt;li&gt;XHTML&lt;/li&gt;
&lt;li&gt;WSP HTTP&lt;/li&gt;
&lt;li&gt;WTP TLS&lt;/li&gt;
&lt;li&gt;WTLS TCP&lt;/li&gt;
&lt;li&gt;WDP IP&lt;/li&gt;
&lt;li&gt;承载层 承载层&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多媒体&lt;/h2&gt;
&lt;h3&gt;音频压缩&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MP3（mpeg audio layer 3，MPEG音频层3）&lt;/li&gt;
&lt;li&gt;波形编码：使用较少的傅里叶分量重现波形&lt;/li&gt;
&lt;li&gt;感知编码：利用心理声学的频率屏蔽和暂时屏蔽去掉某些分量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;流式音频&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;元文件：将整个音频分为很多元文件，减少缓冲时间&lt;/li&gt;
&lt;li&gt;RTSP（real time streaming protocol，实时流协议）：管理用户界面、处理传输错误、解压缩音乐、消除抖动&lt;/li&gt;
&lt;li&gt;拉式服务器、推式服务器、低水印标记和高水印标记&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;IP 语音&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;H.323：ITU在1996年发布，终端、网守、区域。、H.245（新的压缩算法）、H.225（与网守通信）&lt;/li&gt;
&lt;li&gt;SIP（session initiation protocol，会话发起协议）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;视频简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一帧：一次扫描&lt;/li&gt;
&lt;li&gt;隔行扫描与逐行扫描&lt;/li&gt;
&lt;li&gt;彩色电视系统：SECAM（SEquentiel couleur avec memire，顺序与存储彩色电视系统）、PAL（phase alternating line，逐行倒相制式）、NTSC（national television standards committee，国家电视标准委员会）；亮度、色度&lt;/li&gt;
&lt;li&gt;HDTV（high definition television，高清晰度电视）&lt;/li&gt;
&lt;li&gt;数字系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;视频压缩&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;JPEG（joint photographic experts group，联合图像专家族）标准&lt;/li&gt;
&lt;li&gt;块准备：四像素取平均值（亮度比色度更敏感）&lt;/li&gt;
&lt;li&gt;对每一块作DCT（discrete cosine transformation，离散余弦变换）&lt;/li&gt;
&lt;li&gt;量化：将上一步的每个格点乘以对应的权值&lt;/li&gt;
&lt;li&gt;减小每一块的(0,0)元素值（DC分量），其他元素称为AC分量&lt;/li&gt;
&lt;li&gt;行程编码：同样的值用计数值表示&lt;/li&gt;
&lt;li&gt;MPEG（motion picture experts group，运动图像专家组）标准，MPEG-1与JPEG的区别在于运动补偿，包括四种帧&lt;/li&gt;
&lt;li&gt;I（帧内编码，intracoded）：JPEG编码的静止图片&lt;/li&gt;
&lt;li&gt;P（预测，predictive）：与前一帧之间的逐块差值&lt;/li&gt;
&lt;li&gt;B（双向，bidirectional）：与前一帧和后一帧之间的差值&lt;/li&gt;
&lt;li&gt;D（DC编码，DC-coded）：用于快进的快平均值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;视频点播&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;准视频点播：在多个频道以某种时差播放同样的视频&lt;/li&gt;
&lt;li&gt;线路：视频服务器-&amp;gt;光纤-&amp;gt;ATM或SONET骨干网络-&amp;gt;光纤-&amp;gt;交换机-&amp;gt;区域分布式网络-&amp;gt;消费者房子-&amp;gt;机顶盒&lt;/li&gt;
&lt;li&gt;视频服务器&lt;/li&gt;
&lt;li&gt;Zipf定律：最受欢迎的那部电影，它的受欢迎程度是第七受欢迎电影的7倍&lt;/li&gt;
&lt;li&gt;分层存储：RAM-&amp;gt;磁盘-&amp;gt;DVD-&amp;gt;磁带&lt;/li&gt;
&lt;li&gt;磁盘存储&lt;/li&gt;
&lt;li&gt;磁盘场（disk farm）：每个驱动器存储一定数量的电影，有重复&lt;/li&gt;
&lt;li&gt;磁盘阵列（disk array）或RAID（redundant array of inexpensive disks，廉价磁盘冗余阵列）：每部电影分布在多个驱动器上（条状化，striping）&lt;/li&gt;
&lt;li&gt;分发网络：数据源与目标之间交换机和线路的集合&lt;/li&gt;
&lt;li&gt;ADSL&lt;/li&gt;
&lt;li&gt;FTTC（fiber to the curb，光纤到路边）&lt;/li&gt;
&lt;li&gt;FTTH（fiber to the home，光纤到户）&lt;/li&gt;
&lt;li&gt;HFC（hybrid fiber coax，混合光纤同轴电缆）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Mbone（multicast backbone，多播骨干网）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mbone是internet之上的一个虚拟层叠网络&lt;/li&gt;
&lt;li&gt;由隧道连接的多个多播岛组成，每个岛有至少一个mrouter（multicast router，多播路由器）&lt;/li&gt;
&lt;li&gt;使用基于Bellman-Ford距离矢量算法的路由算法DVMRP（distance vector multicast routing protocol，距离矢量多播路由协议）&lt;/li&gt;
&lt;li&gt;PIM（protocol independent multicast，协议无关多播）：AS间的路由，IETF工作组开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;网络安全&lt;/h1&gt;
&lt;h2&gt;密码学简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;加密：明文经密钥为参数的函数变换，输出密文&lt;/li&gt;
&lt;li&gt;密码编码学、密码分析学、密码术&lt;/li&gt;
&lt;li&gt;Kerckhoff原则：所有算法必须是公开的，只有密钥是保密的&lt;/li&gt;
&lt;li&gt;含糊的安全性（security by obscurity）：使算法保持秘密&lt;/li&gt;
&lt;li&gt;工作因子：密码分析者面对的密钥的复杂性，对于穷举搜索，为密钥长度的指数量级&lt;/li&gt;
&lt;li&gt;密码分析问题&lt;/li&gt;
&lt;li&gt;只有密文&lt;/li&gt;
&lt;li&gt;已知明文（有了一些相匹配的密文和明文）&lt;/li&gt;
&lt;li&gt;选择明文（能够加密一些自己选择的明文）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;置换密码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;保留明文字符顺序，进行明文伪装&lt;/li&gt;
&lt;li&gt;凯撒密码（单字母表置换）&lt;/li&gt;
&lt;li&gt;字符频率猜测&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;转置密码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重新排序，不伪装明文&lt;/li&gt;
&lt;li&gt;字符频率不变&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;一次一密&lt;/h3&gt;
&lt;p&gt;优点，不可能被破解；缺点，密钥数量限制、密钥流失、丢失字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;量子密码系统：BB84协议&lt;/li&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;li&gt;直线基：垂直和水平滤波器&lt;/li&gt;
&lt;li&gt;对角基：上述基旋转45度&lt;/li&gt;
&lt;li&gt;0与1：每一组基任意分配两个偏振方向为0和1&lt;/li&gt;
&lt;li&gt;过程&lt;/li&gt;
&lt;li&gt;A与B通信，T在监听&lt;/li&gt;
&lt;li&gt;A传送一次性密钥（长度略超过期望长度的2倍）给B，每一位随机选择一个基。&lt;/li&gt;
&lt;li&gt;B使用随机的基接收每一位；&lt;/li&gt;
&lt;li&gt;B告诉A自己使用的基。&lt;/li&gt;
&lt;li&gt;A告诉B哪些是正确的；&lt;/li&gt;
&lt;li&gt;A与B使用正确传输的位序作为密钥；&lt;/li&gt;
&lt;li&gt;反监听&lt;/li&gt;
&lt;li&gt;监听者的密钥不完整。监听者T，对于B基序列中能正确接收的部分，若T与B恰好使用相同的基，则T可以知道该位的密钥；否则T将丢失该位。可经过秘密放大进一步减少T知道的内容。&lt;/li&gt;
&lt;li&gt;监听检测。T必须将A的内容转发给B，却不能正确告知B的哪些基是正确的；一位密钥错误相当与B眼中的一位传输错误；A与B使用前向纠错码进行纠错，发现错误率大大超过设备的期望；得知T的存在。&lt;/li&gt;
&lt;li&gt;本质&lt;/li&gt;
&lt;li&gt;光子遇到与自己偏振方向成45度的滤波器，会随机跳到其中一个且概率相等。&lt;/li&gt;
&lt;li&gt;光子不可复制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;基本的密码学原则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;消息必须包含一定的冗余度：区分有效消息、检测信道&lt;/li&gt;
&lt;li&gt;需要采取某种方法对抗重放攻击：新鲜度、时间戳&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;对称密钥算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;块密码：接受一个n位的明文块作为输入，利用密钥把它变换成n为的密文块&lt;/li&gt;
&lt;li&gt;P盒：转置操作，混淆&lt;/li&gt;
&lt;li&gt;S盒：置换操作，扩散&lt;/li&gt;
&lt;li&gt;乘积密码：一系列的S盒和P盒叠加起来&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;DES（data encryption standard，数据加密标准）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;明文按64位数据块的单元加密，生成64位密文，接受56位密钥，共19个步骤，16次迭代&lt;/li&gt;
&lt;li&gt;三重DES：EDE（K1, K2, K1）模式，兼容了DES算法（只需让K1=K2）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;AES（advanced encryption standard，高级加密标准）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;NIST（national institute of standards and technology，美国标准和技术委员会）在1997年1月发起了密码学竞赛，新标准称为AES，要求&lt;/li&gt;
&lt;li&gt;必须是对称的快密码算法&lt;/li&gt;
&lt;li&gt;公开所有设计&lt;/li&gt;
&lt;li&gt;支持128位、192和256位密钥长度&lt;/li&gt;
&lt;li&gt;软件、硬件实现都是可能的&lt;/li&gt;
&lt;li&gt;算法必须是公有的&lt;/li&gt;
&lt;li&gt;Rijndael：与DES相同，仍使用置换和转置，多轮策略（轮数取决于密钥和块长度）；另外，所有操作都涉及整个字节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;密码算法的使用模式&lt;/h3&gt;
&lt;p&gt;AES和DES本质上都是置换和转置操作，同样的明文会得到同样的密文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ECB模式（electronic code book mode，电子代码薄模式）：分割明文，逐块加密。容易被替换某一块。&lt;/li&gt;
&lt;li&gt;密码块链接模式：第一个块与随机IV（initialization vector，初始向量）异或，之后的明文块与前一密文块异或后加密，IV一起传输&lt;/li&gt;
&lt;li&gt;密码反馈模式：逐字节加密，不必等64位数据块；密文只有一位偶然翻转，会波及到坏字节在寄存器中时的8个字节&lt;/li&gt;
&lt;li&gt;流密码模式&lt;/li&gt;
&lt;li&gt;过程：用一个密钥加密一个初始向量生成一个输出块，同样的密钥加密这个输出块产生第二个输出块，以此类推；然后将明文与该密钥流异或得到密文&lt;/li&gt;
&lt;li&gt;优点：密钥流仅仅依赖于IV和密钥，不会受到传输错误的影响。&lt;/li&gt;
&lt;li&gt;缺点：重复使用（密钥，IV）对，会产生同样的密钥流，会导致密文受到密钥流重用攻击（keystream resuse attack）&lt;/li&gt;
&lt;li&gt;计数器模式：除密码薄模式以外的模式中，要想随机访问密文是不可能的&lt;/li&gt;
&lt;li&gt;过程：初始向量加常数后进行加密，再与明文异或；每个新的数据块使初始向量递增1&lt;/li&gt;
&lt;li&gt;优点：文件中任何地方的块都可以直接解密&lt;/li&gt;
&lt;li&gt;缺点：重复使用（密钥，IV）对，会导致密文受到密钥流重用攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;密码分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;差分密码分析（differential cryptanalysis）：观察少量位差异的明文产生的密文，有些位模式可能比其他位模式更容易出现，这种现象可以导致概率攻击。可用于攻击任何一种块密码算法。&lt;/li&gt;
&lt;li&gt;线性密码分析（linear cryptanalysis）：将明文与密文特定位异或，应该一半为0一半为1，而加密过程会引入偏差，这样的偏差总可以降低工作量。只需2^43个已知密文就可以破解DES。&lt;/li&gt;
&lt;li&gt;电子功率消耗分析：计算机高电压表示1，低电压表示0，减慢时钟，记录CPU功率&lt;/li&gt;
&lt;li&gt;时间分析：if语句的then和else执行时间不同时，减慢时钟可以推断出轮密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;公开密钥算法&lt;/h2&gt;
&lt;p&gt;加密算法E与解密算法D满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D(E(P)) = P&lt;/li&gt;
&lt;li&gt;从E推断出D极其困难&lt;/li&gt;
&lt;li&gt;用选择明文攻击不可能破解E&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;RSA&lt;/h3&gt;
&lt;p&gt;RSA算法建立在分解大素数的基础上，RSA分别为三位发现者名字的首字母&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算参数&lt;/li&gt;
&lt;li&gt;选择两个大素数p、q（典型情况为1024位）&lt;/li&gt;
&lt;li&gt;计算n=p&lt;em&gt;q和z=(p-1)&lt;/em&gt;(q-1)&lt;/li&gt;
&lt;li&gt;选择一个与z互素的数d&lt;/li&gt;
&lt;li&gt;找到e使其满足e*d=1%z&lt;/li&gt;
&lt;li&gt;加密&lt;/li&gt;
&lt;li&gt;公钥对为(e, n)&lt;/li&gt;
&lt;li&gt;将明文分块，每个明文P落在0&amp;lt;=P&amp;lt;n中&lt;/li&gt;
&lt;li&gt;计算C=P^e(mod n)&lt;/li&gt;
&lt;li&gt;解密&lt;/li&gt;
&lt;li&gt;私钥对为(d, n)&lt;/li&gt;
&lt;li&gt;计算P=C^d(mod n)&lt;/li&gt;
&lt;li&gt;使用：所有人公开自己的加密密钥E，B给A发送Ea(P)，A获得后进行解密P=DaEa(P)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他的公开密钥算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主要有两方面的算法&lt;/li&gt;
&lt;li&gt;分解大数的困难度&lt;/li&gt;
&lt;li&gt;以大素数为模来计算离散对数的困难度&lt;/li&gt;
&lt;li&gt;背包算法：“根据给定的总重量找出可能的物品明细列表”被认为是计算上不可行的。该算法与其加强算法相继被S和R破解。&lt;/li&gt;
&lt;li&gt;其他：计算离散对数的困难度、基于圆锥曲线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数字签名&lt;/h2&gt;
&lt;p&gt;数字签名应满足条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收方可以验证发送方所宣称的身份&lt;/li&gt;
&lt;li&gt;发送方以后不能否认该消息的内容&lt;/li&gt;
&lt;li&gt;接收方不可能编造这样的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;对称密钥签名&lt;/h3&gt;
&lt;p&gt;选择一个中心权威机构BB，每个用户选择一个秘密密钥亲手交给BB。A发送A, Ka(B, Ra, t, P)给BB，BB将Kb(A, Ra, t, P, K_BB(A, t, P))给B&lt;/p&gt;
&lt;h3&gt;公开密钥数字签名&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;假设公开密钥算法不仅满足D(E(P))=P，还满足E(D(P))=P&lt;/li&gt;
&lt;li&gt;A向B发送 C=Eb(Da(P))&lt;/li&gt;
&lt;li&gt;B得到明文 P=Ea(Db(C))&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;消息摘要&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;特性&lt;ul&gt;
&lt;li&gt;给定P，很容易计算MD(P)&lt;/li&gt;
&lt;li&gt;给定MD(P)，想得到P是不可能的&lt;/li&gt;
&lt;li&gt;给定P的情况下，没有人能得到满足 MD(P&amp;#39;)=MD(P) 的P&amp;#39;&lt;/li&gt;
&lt;li&gt;输入明文即使只有1位变化，也会导致不同输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;加密摘要比明文快的多，可以加速数字签名算法&lt;/li&gt;
&lt;li&gt;MD5&lt;ul&gt;
&lt;li&gt;将明文填补到448位&lt;/li&gt;
&lt;li&gt;消息后追加其消息长度（64位整数），此时共512位&lt;/li&gt;
&lt;li&gt;取出一个512字节的输入块，通过正弦函数与128位的缓冲区混合，每个输入块执行4轮&lt;/li&gt;
&lt;li&gt;128位的缓冲区即为最终的消息摘要&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SHA-1（secure hash algorithm 1）：同样按照512字节块处理数据，唯一不同的是生成160位的消息摘要&lt;ul&gt;
&lt;li&gt;利用SHA-1和RSA对非保密的消息进行签名：Alice-&amp;gt;明文P-&amp;gt;SHA-1-&amp;gt;P的散列值H-&amp;gt;RSA(私钥Da)-&amp;gt;签过名的散列值Da(H)-&amp;gt;Bob&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;生日攻击&lt;/h3&gt;
&lt;p&gt;n个输入和k个可能的输出之间存在某种映射关系，公有n(n-1)/2个可能的输入对，若n(n-1)/2&amp;gt;k，则至少有一个匹配的机会是非常大的&lt;/p&gt;
&lt;h2&gt;公钥的管理&lt;/h2&gt;
&lt;h3&gt;证书&lt;/h3&gt;
&lt;p&gt;CA（certification authority，证书权威机构），避免了24小时在线的密钥分发中心&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成证书&lt;/li&gt;
&lt;li&gt;Alice到CA，出示其公钥和身份，请求证明他的公钥&lt;/li&gt;
&lt;li&gt;CA给Alice一个证书，其中包括Alice的身份、CA的私钥对身份散列值的签名&lt;/li&gt;
&lt;li&gt;证书验证&lt;/li&gt;
&lt;li&gt;Bob计算Alice身份的散列值，与CA的公钥应用在Alice证书的签名上得到的散列值进行比对，因Trudy无法得知CA的私钥，所以他不能对散列值正确地签名&lt;/li&gt;
&lt;li&gt;证书格式标准 X.509：ITU1988年通过，采用OSI ASN.1（abstract syntax notation 1，抽象语法标记1）编码&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;PKI（public key infrastructure，公开密钥基础设施）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;信任链（证书路径）：分层的CA，顶级CA负责证明次级CA（又称RA，regional authority，区域权威机构），次级CA负责证明第三级CA，以此类推&lt;/li&gt;
&lt;li&gt;信任锚：浏览器预先安装100多个根的公钥&lt;/li&gt;
&lt;li&gt;目录（在哪里存放证书）：用户自己存放、DNS服务器存放&lt;/li&gt;
&lt;li&gt;撤销：CA定期发布CRL（certificate revocation list，证书撤销列表）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;通信安全&lt;/h2&gt;
&lt;h3&gt;IPSec&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RFC 2401、2402和2406，总是要求加密功能，但允许空算法&lt;/li&gt;
&lt;li&gt;IPSec是一个多服务、多算法和多粒度的框架&lt;/li&gt;
&lt;li&gt;两种模式&lt;/li&gt;
&lt;li&gt;传输模式：直接插在IP头的后面&lt;/li&gt;
&lt;li&gt;隧道模式：整个IP分组封装到一个新的新的IP分组中，新分组具有全新的IP头&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;防火墙&lt;/h3&gt;
&lt;p&gt;防火墙包括两部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分组过滤器（网络层）：配置了某些额外功能的标准路由器，负责检查进入和出去的所有分组&lt;/li&gt;
&lt;li&gt;应用网关（应用层）：根据头、消息长度，甚至内容决定转发或丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DoS（denial of service）攻击：向目标机器发送大量合法的分组，防火墙不能处理；DDoS（distributed denial of service）攻击：大量普通用户的机器被控制而进行DoS攻击&lt;/p&gt;
&lt;h3&gt;VPN（virtual private network，虚拟私有网络）&lt;/h3&gt;
&lt;p&gt;建立在公共网络上的层叠网络，可利用IPSec实现隧道，将任意两个办公室的流量聚集到一个支持认证和加密功能的SA上&lt;/p&gt;
&lt;h3&gt;无线网络安全&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;802.11安全性：WEP（wired equivalent privacy，相当于有线网络的保密性）为数据链路层安全协议，使用基于RC4的流密码算法&lt;/li&gt;
&lt;li&gt;蓝牙安全性：物理层的调频机制提供了一定程度的安全性；设备预先建立好的共享的秘密密钥（passkey，总密钥）；蓝牙的加密算法使用叫做E0的流密码，完整性控制使用SAFER+，两者都是对称密钥快密码算法&lt;/li&gt;
&lt;li&gt;WAP2.0安全性：它是基于IP的，可以使用IPSec；传输层可以使用TLS提供保护。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;认证协议&lt;/h2&gt;
&lt;h3&gt;基于共享秘密密钥的认证&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;质询-回应协议：容易受到反射攻击&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;建立一个共享密钥：Diffie-Hellman密钥交换协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基于大素数分解的困难度，容易受到水桶队列攻击（又称中间人攻击）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用密钥分发中心的认证协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重放攻击&lt;/li&gt;
&lt;li&gt;Needham-Schroeder认证协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用Kerberos的认证协议&lt;/h3&gt;
&lt;p&gt;应用在许多实际系统中，如windows2000&lt;/p&gt;
&lt;h3&gt;使用公开密钥密码学的认证协议&lt;/h3&gt;
&lt;h2&gt;电子邮件安全&lt;/h2&gt;
&lt;h3&gt;PGP（pretty good privacy，相当好的隐私）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PGP使用一个称为IDEA（international data encryption algorithm）的块密码算法来加密数据&lt;/li&gt;
&lt;li&gt;私钥环：一个或多个本人的公-私钥对&lt;/li&gt;
&lt;li&gt;公钥环：与当前用户进行通信的其他用户的公钥&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;PEM（privacy enhanced mail，增强隐私的邮件）&lt;/h3&gt;
&lt;p&gt;像PGP一样，每条消息都使用一次性密钥进行加密，密钥（被RSA或三重DES保护）也被包装到消息中&lt;/p&gt;
&lt;h3&gt;S/MIME（Secure/MIME，安全的MIME）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IETF提出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Web 安全&lt;/h2&gt;
&lt;h3&gt;安全的命名机制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DNS欺骗&lt;/li&gt;
&lt;li&gt;安全的DNS&lt;/li&gt;
&lt;li&gt;自证明的名字&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;SSL（secure sockets layer，安全套接字层）&lt;/h3&gt;
&lt;p&gt;在两个套接字之间建立安全的连接，位于应用层与传输层之间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户与服务器之间的参数协商&lt;/li&gt;
&lt;li&gt;客户与服务器的双向认证&lt;/li&gt;
&lt;li&gt;保密的通信&lt;/li&gt;
&lt;li&gt;数据完整性保护&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;移动代码安全&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;java applet安全：解释器将其封装到沙箱一边限制它的行为&lt;/li&gt;
&lt;li&gt;Active控件：代码签名，认证码&lt;/li&gt;
&lt;li&gt;javascript：没有正式的安全模型&lt;/li&gt;
&lt;li&gt;病毒：具有繁殖能力，不断复制自己&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;社会问题&lt;/h2&gt;
&lt;h3&gt;隐私&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;clipper chip（剪切芯片）&lt;/li&gt;
&lt;li&gt;key escrow（密钥托管）&lt;/li&gt;
&lt;li&gt;电子边境基金会（electronic frontier foundation）&lt;/li&gt;
&lt;li&gt;匿名邮件中继器（anonymous remailer）&lt;/li&gt;
&lt;li&gt;翻译型的邮件中继器（cypherpunk remailer）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;言论自由&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;信息隐藏学（steganography）&lt;/li&gt;
&lt;li&gt;数字水印&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;　版权&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;版权（copyright）是对IP（intellectual property，知识产权）的创造者的一种授权&lt;/li&gt;
&lt;li&gt;合理使用原则（fair use doctrine）&lt;/li&gt;
&lt;li&gt;TCPA（trusted computing platform alliance，可信计算平台联盟）&lt;/li&gt;
&lt;/ul&gt;

</description>
				<pubDate>Mon, 28 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/%E8%AF%BB%E4%B9%A6/computer-network.html</link>
				<guid isPermaLink="true">http://harttle.github.io/%E8%AF%BB%E4%B9%A6/computer-network.html</guid>
			</item>
		
			<item>
				<title>Linux下的触摸板设置</title>
				<description>&lt;h1&gt;软件安装&lt;/h1&gt;
&lt;h2&gt;安装 Synaptics 驱动&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# arch linux:&lt;/span&gt;
pacman -S xf86-input-synaptics&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;管理工具&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# 命令行管理工具：Synclient &lt;/span&gt;
pacman -S xf86-input-synaptics    

&lt;span class=&quot;hljs-comment&quot;&gt;# 图形管理工具：GPointing Device Settings&lt;/span&gt;
yaourt -S gpointing-device-settings

&lt;span class=&quot;hljs-comment&quot;&gt;# KDE 触摸板控制模块&lt;/span&gt;
yaourt -S kcm_touchpad&lt;/code&gt;&lt;/pre&gt;&lt;!--more--&gt;

&lt;h1&gt;环境配置&lt;/h1&gt;
&lt;p&gt;一般的设置工作可通过图形管理工具完成，如单击、双击、右键的识别，横向和纵向滚动、双指滚动。下面介绍一些高级配置。&lt;/p&gt;
&lt;h2&gt;基本触摸板配置&lt;/h2&gt;
&lt;p&gt;可通过修改 synaptics 的配置文件，修改触摸板配置。包括多指敲击、滚动、避免手掌触摸、精确度与快速滚动。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#file: /etc/X11/xorg.conf.d/50-synaptics.conf&lt;/span&gt;
Section &lt;span class=&quot;hljs-string&quot;&gt;&quot;InputClass&quot;&lt;/span&gt;
        Identifier &lt;span class=&quot;hljs-string&quot;&gt;&quot;touchpad catchall&quot;&lt;/span&gt;
        Driver &lt;span class=&quot;hljs-string&quot;&gt;&quot;synaptics&quot;&lt;/span&gt;
        MatchIsTouchpad &lt;span class=&quot;hljs-string&quot;&gt;&quot;on&quot;&lt;/span&gt;

        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;TapButton1&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;#单指敲击产生左键事件&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;TapButton2&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;#双指敲击产生中键事件&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;TapButton3&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;3&quot;&lt;/span&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;#三指敲击产生右键事件&lt;/span&gt;

        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;VertEdgeScroll&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;on&quot;&lt;/span&gt;       &lt;span class=&quot;hljs-comment&quot;&gt;#滚动操作：横向、纵向、环形&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;VertTwoFingerScroll&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;on&quot;&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;HorizEdgeScroll&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;on&quot;&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;HorizTwoFingerScroll&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;on&quot;&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;CircularScrolling&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;on&quot;&lt;/span&gt;  
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;CircScrollTrigger&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;2&quot;&lt;/span&gt;

        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;EmulateTwoFingerMinZ&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;40&quot;&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;#精确度&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;EmulateTwoFingerMinW&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;8&quot;&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;CoastingSpeed&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;20&quot;&lt;/span&gt;        &lt;span class=&quot;hljs-comment&quot;&gt;#触发快速滚动的滚动速度&lt;/span&gt;

        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;PalmDetect&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;#避免手掌触发触摸板&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;PalmMinWidth&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;3&quot;&lt;/span&gt;          &lt;span class=&quot;hljs-comment&quot;&gt;#认定为手掌的最小宽度&lt;/span&gt;
        Option &lt;span class=&quot;hljs-string&quot;&gt;&quot;PalmMinZ&quot;&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;200&quot;&lt;/span&gt;            &lt;span class=&quot;hljs-comment&quot;&gt;#认定为手掌的最小压力值&lt;/span&gt;
EndSection&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;code&gt;man synaptics&lt;/code&gt; 了解更多信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：同时安装 &lt;code&gt;kcm_synaptics&lt;/code&gt; 会覆盖掉该配置信息。&lt;/p&gt;
&lt;h2&gt;输入时禁止触摸板敲击&lt;/h2&gt;
&lt;p&gt;这样可以避免焦点变化，影响当前的输入。&lt;/p&gt;
&lt;p&gt;对于使用 &lt;code&gt;startx&lt;/code&gt; 来启动的桌面系统，可以修改其 &lt;code&gt;.xinitrc&lt;/code&gt; 初始化配置文件来完成：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;syndaemon -t -k -i &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;hljs-operator&quot;&gt;-d&lt;/span&gt; &amp;amp;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中的 &lt;code&gt;-i 2&lt;/code&gt; 表示两秒空闲，即键盘事件后的两秒内不允许响应触摸板 Tap。更多信息请参照手册页：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;man syndaemon&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;外接鼠标时禁用触摸板&lt;/h2&gt;
&lt;p&gt;在 arch linux 中，使用 udev 监测硬件的热拔插，通过修改其规则文件，来响应外接鼠标事件，从而禁用和启用触摸板。如下的规则文件，调用了 synclient。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;#file: /etc/udev/rules.d/01-touchpad.rules&lt;/span&gt;
ACTION==&lt;span class=&quot;hljs-string&quot;&gt;&quot;add&quot;&lt;/span&gt;, SUBSYSTEM==&lt;span class=&quot;hljs-string&quot;&gt;&quot;input&quot;&lt;/span&gt;, KERNEL==&lt;span class=&quot;hljs-string&quot;&gt;&quot;mouse[0-9]&quot;&lt;/span&gt;, ENV{DISPLAY}=&lt;span class=&quot;hljs-string&quot;&gt;&quot;:0.0&quot;&lt;/span&gt;, ENV{XAUTHORITY}=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/home/harttle/.Xauthority&quot;&lt;/span&gt;, ENV{ID_CLASS}=&lt;span class=&quot;hljs-string&quot;&gt;&quot;mouse&quot;&lt;/span&gt;, RUN+=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/bin/synclient TouchpadOff=1&quot;&lt;/span&gt;
ACTION==&lt;span class=&quot;hljs-string&quot;&gt;&quot;remove&quot;&lt;/span&gt;, SUBSYSTEM==&lt;span class=&quot;hljs-string&quot;&gt;&quot;input&quot;&lt;/span&gt;, KERNEL==&lt;span class=&quot;hljs-string&quot;&gt;&quot;mouse[0-9]&quot;&lt;/span&gt;, ENV{DISPLAY}=&lt;span class=&quot;hljs-string&quot;&gt;&quot;:0.0&quot;&lt;/span&gt;, ENV{XAUTHORITY}=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/home/harttle/.Xauthority&quot;&lt;/span&gt;, ENV{ID_CLASS}=&lt;span class=&quot;hljs-string&quot;&gt;&quot;mouse&quot;&lt;/span&gt;, RUN+=&lt;span class=&quot;hljs-string&quot;&gt;&quot;/usr/bin/synclient TouchpadOff=0&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：该文件中每个操作必须单独一行，可以使用 &lt;code&gt;\&lt;/code&gt; 来折行；&lt;code&gt;SUBSYSTEM&lt;/code&gt; 与 &lt;code&gt;KERNEL&lt;/code&gt; 指定了设备 &lt;code&gt;/dev/input/mouse[0-9]&lt;/code&gt;（archwiki的中文页面中此处有误，我会找时间去修改）。了解更多 udev rules 语法：&lt;a href=&quot;https://wiki.archlinux.org/index.php/Udev&quot;&gt;https://wiki.archlinux.org/index.php/Udev&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;开机时鼠标检测&lt;/h3&gt;
&lt;p&gt;PS/2 鼠标在开机时不会出发 udev 规则。我们做一个桌面环境的启动脚本，在 .xinitrc，profile 中调用，或者放在  KDE 的 Autostart 中：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-shebang&quot;&gt;#!/bin/bash&lt;/span&gt;
ids=`ls /dev/input/by-id | grep -E &lt;span class=&quot;hljs-string&quot;&gt;&#39;.*-mouse&#39;&lt;/span&gt;`
[ &lt;span class=&quot;hljs-string&quot;&gt;&quot;&lt;span class=&quot;hljs-variable&quot;&gt;$ids&lt;/span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; synclient TouchpadOff=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;触摸板识别错误&lt;/h2&gt;
&lt;p&gt;对于某些型号的机器，Arch 下触摸板识别会有问题（内核bug），官方建议从 AUR 安装 &lt;code&gt;psmouse-alps-driver&lt;/code&gt;。&lt;br&gt;受影响的机器有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Acer Aspire 7750G&lt;/li&gt;
&lt;li&gt;Dell Latitude E6230, E6520, E6430 and E6530 (ALPS DualPoint TouchPad), Inspiron N5110 (ALPS GlidePoint),  Inspiron 14R Turbo SE7420/SE7520 (ALPS GlidePoint)&lt;/li&gt;
&lt;li&gt;Samsung NC110/NF210/QX310/QX410/QX510/SF310/SF410/SF510/RF410/RF510/RF710/RV515&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果问题还没有解决，可以手动编译该模块载入内核。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;卸载原有 Alps 触摸板驱动&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; pacman -R psmouse-alps-driver&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从这里下载：&lt;a href=&quot;http://www.dahetral.com/public-download&quot;&gt;http://www.dahetral.com/public-download&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解压缩，并拷贝至 &lt;code&gt;/usr/src&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; tar -xvf alps-xxx.tar
 &lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; cp -r usr /&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加入编译树，并进行编译&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; dkms add psmouse/alps-xxx
 &lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; dkms autoinstall&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;卸载原有模块并载入新的内核模块&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; rmmod psmouse || &lt;span class=&quot;hljs-built_in&quot;&gt;sudo&lt;/span&gt; modprobe psmouse&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
				<pubDate>Sun, 27 Oct 2013 00:00:00 +0800</pubDate>
				<link>http://harttle.github.io/linux/synaptics-settings-linux.html</link>
				<guid isPermaLink="true">http://harttle.github.io/linux/synaptics-settings-linux.html</guid>
			</item>
		
	</channel>
</rss>
