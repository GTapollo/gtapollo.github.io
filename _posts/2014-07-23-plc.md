---
layout: blog
categories: reading
title: 可编程控制器编程语言
subtitle: IEC 61131-3 阅读笔记
tags: plc
---

IEC 61131-3 specifies *syntax* and *semantics* of programming languages for programmable controllers.

> **A Programmable Logic Controller**, **PLC** or **Programmable Controller** is a digital computer used for automation of typically industrial electromechanical processes, such as control of machinery on factory assembly lines, amusement rides, or light fixtures.

This part(part 3) of IEC 61131 specifies the syntax and semantics of a unified suite of programming languages for *programmable controllers (PCs)*:

1. Two textual languages, *IL (Instruction List)* and *ST (Structured Text)*
2. Two graphical languages, *LD (Ladder Diagram)* and *FBD (Function Block Diagram)*

> *Sequential Function Chart (SFC) elements* are defined for structuring the internal organization of programmable controller programs and function blocks. 

> Also, *configuration* elements are defined which support the installation of programmable controller programs into programmable controller systems.

A programmable controller program *complying* with the requirements of IEC 61131-3:

1. shall use only those features specified in this standard for the particular language used;
2. shall not use any features identified as extensions to the language;
3. shall not rely on any particular interpretation of *implementation-dependent* features.


<!--more-->


# General

## Definitions

**aggregate**: structured collection of data objects forming a data type.

**assignment**: mechanism to give a value to a variable or to an aggregate.

**data type**: set of values together with a set of permitted operations.

**declaration**: the mechanism for establishing the definition of a language element.

**delimiter**: character or combination of characters used to separate program language elements.

**evaluation**: the process of establishing a value for an expression or a function, or for the outputs of a network or function block, during program execution.

**literal**: lexical unit that directly represents a value.

**retentive data**: data stored in such a way that its value remains unchanged after a power down / power up sequence.

**semantics**: the relationships between the symbolic elements of a programming language and their meanings, interpretation and use.

## Software Model

In PC software model, a **configuration** is the language element which corresponds to a programmable controller system. A **resource** corresponds to a "signal processing function" and its "man-machine interface" and "sensor and actuator interface" function (if any).

A *configuration contains* one or more *resources*, each of which contains one or more *programs* executed under the control of zero or more **tasks**. A **program** may contain zero or more **function blocks** or other language elements.

![](/assets/img/blog/software-model.png)

## Communication Model

1. Variable values *within a program* can be communicated directly by connection of the output of one program element to the input of another.
2. Variable values can be communicated *between programs in the same configuration* via global variables.
3. Values of variables can be communicated between different parts of a program, between programs in the same or different configurations, or between a programmable controller program and a non-programmable controller system, using the communication function blocks.
4. In addition, *programmable controllers or non-programmable controller systems* can transfer data which is made available by *access paths*.


## Programming Model

![](/assets/img/blog/programming-model.png)


# Common Elements

This clause defines textual and graphic elements which are common to all the 4 languages.


## Use of Printed Characters

Textual/graphic language **character set** are defined in IOS-646 IRV, with extensions such as Latin-1 Supplement(IOS 10646-1).


An **identifier** is a string of letters, digits, and underline characters which shall begin with a letter or underline character.

* PC programming languages are case-insensitive. 
* Underlines are significant in identifiers, while multiple underlines are not allowed. 
* At least 6 chars shall be supported

A **commonts** is a language construct for the inclusion of text in a program and having no impact on the execution of the program. *Comments* are delimited by `(*` and `*)`.

> Nested comments shall be treated as an **error**.


A **pragma** is a language construct for the inclusion of text in a program organization unit which may affect the preparation of the program for execution. *Pragmas* are delimited by `{` and `}`.

## External Representation of Data

### Numeric Literals

There are two classes of numeric literals: integer and real. A numeric literal is defined as a decimal number of a based number.

> Single `_` between the digits of a numeric literal shall not be significant. No other use of `_` in numeric literals is allowed.

Literal examples:

```
-12 0 123_456 +986
-12.0 0.0 0.4560 3.14159_26
-1.34E-12 or -1.34e-12
16#FF or 16#ff (255 decimal)
FALSE TRUE
UINT#16#9AF DINT#5
```

### Character String Literals

Character string literals include single-byte or double-byte encoded characters.

A **single-byte** character string is delimited by `'`, `$` followed by 2 hex digits shall be interpreted as 8-bit character code. A **double-byte** character string is delimited by `"`, `$` followed by 4 hex digits shall be interpreted as 16-bit character code. `$` followed by one character shall be interpreted as escape.

Syntax examples:

```
''  'A' '$''    'Ä Ë' == '$C4$CB'
""  "A" "$""    "Ä Ë" == "$00C4$00CB"
STRING#'OK' == WSTRING#'OK'
```

Escaping:

Combination     |   Interpretation
---             |   ---
`$$`            |   Dollar sign
`$'` or `$"`    |   Quotes
`$L` or `$l`    |   Line feed
`$N` or `$n`    |   Newline
`$P` or `$p`    |   Form feed(page)
`$R` or `$r`    |   Carriage return
`$T` or `$t`    |   Tab

### Time Literals

There are two classes of time literals:

1. **duration** data for measuring or controlling the elapsed time of a control event.
2. **time of day** data (which may also include date information) for synchronizing the beginning or end of a control event to an absolute time reference.

* Optional single `_` can be used to separate different time units. 
* "Overflow" of the most significant unit of a duration is permitted.
* The least significant unit can be real without exponent.

Keywords    |   Duration    |   Time
---         |   ---         |   ---
Full        | `TIME`        |   `DATE` `TIME_OF_DAY` `DATE_AND_TIME`
Abbr        |   `T`         |   `D` `TOD` `DT`

Syntax examples:

```
T#14.7h t#5d14h12m18s3.5ms  TIME#-14ms
DATE#1984-06-25 tod#15:36:55.36
date_and_time#1984-06-25-15:36:55.36
```

## Data Types

### Elementary Data Types

No. |   Keyword | Data type |   N
--- |   ---     |   ---     |   ---
1 | `BOOL` | Boolean | 1 
2 | `SINT` | Short integer | 8
3 | `INT` | Integer | 16 
4 | `DINT` | Double integer | 32
5 | `LINT` | Long integer | 64
6 | `USINT` | Unsigned short integer | 8
7 | `UINT` | Unsigned integer | 16
8 | `UDINT` | Unsigned double integer | 32
9 | `ULINT` | Unsigned long integer | 64
10 | `REAL` | Real numbers | 32
11 | `LREAL` | Long reals | 64
12 | `TIME` | Duration | --
13 | `DATE` | Date (only) | --
14 | `TIME_OF_DAY` or `TOD` | Time of day (only) | --
15 | `DATE_AND_TIME` or `DT` | Date and time of Day | --
16 | `STRING` | Variable-length single-byte character string | 8 
17 | `WSTRING` | Variable-length double-byte character string | 16 
18 | `BYTE` | Bit string of length 8 | 8 
19 | `WORD` | Bit string of length 16 | 16 
20 | `DWORD` | Bit string of length 32 | 32 
21 | `LWORD` | Bit string of length 64 | 64 

### Generic Data Types

In addition of *elementari data types*, the **hierarchy of generic data types** can be used in the specification of input/output of functions and function blocks. Generic data types are identified by the prefix `ANY`.

```
ANY
    ANY_DERIVED
    ANY_ELEMENTARY
        ANY_MAGNITUDE
            ANY_NUM
                ANY_REAL 
                    LREAL
                    REAL 
                ANY_INT
                    LINT, DINT, INT, SINT
                    ULINT, UDINT, UINT, USINT 
            TIME
        ANY_BIT
            LWORD, DWORD, WORD, BYTE, BOOL
        ANY_STRING 
            STRING
            WSTRING 
        ANY_DATE
            DATE_AND_TIME 
            DATE, TIME_OF_DAY
```

### Derived Data Types

**Derived data types** are declared using `TYPE...END_TYPE`. A direct derivation from elementary types looks like: `TYPE RU_REAL : REAL ; END_TYPE`.

#### Enumerated

```
TYPE ANALOG_SIGNAL_TYPE : 
    (SINGLE_ENDED, DIFFERENTIAL) := SINGLE_ENDED ; 
END_TYPE
```

Type prefix `ANALOG_SIGNAL_TYPE#` can be used for **enumerated** data to avoid ambiguousity. It's an **error** if sufficient type information is not provided.

The default initial value of *enumerated* data type shall be the first identifier, or a value specified by `:=`.

#### Subrange

```
TYPE ANALOG_DATA : INT (-4095..4095) ; END_TYPE
```

A **subrange** declaration specifies upper and lower limits of data type. It's an **error** if the value falls outside of the specified range of its type.

The default initial value of *subrange* data type shall be the lower limit of the subrange.

#### Struct

```
TYPE 
    ANALOG_CHANNEL_CONFIGURATION :
        STRUCT
            RANGE : ANALOG_SIGNAL_RANGE ; 
            MIN_SCALE : ANALOG_DATA ; 
            MAX_SCALE : ANALOG_DATA ;
        END_STRUCT ; 
    ANALOG_16_INPUT_CONFIGURATION :
        STRUCT
            SIGNAL_TYPE : ANALOG_SIGNAL_TYPE ;
            FILTER_PARAMETER : SINT (0..99) ;
            CHANNEL : ARRAY [1..16] OF ANALOG_CHANNEL_CONFIGURATION ;
        END_STRUCT ; 
END_TYPE
```

For *structs* and *arrays*, the default initial values, unless specified by `:=`, shall be the default value of underlining elementary data types.

> Default initial value for elementary shall be 0, except for `DATE` data type which is `0000-00-01`.

#### Array

```
TYPE ANALOG_16_INPUT_DATA : 
    ARRAY [1..16] OF ANALOG_DATA ; 
END_TYPE
```

The default max length of `STRING` and `WSTRING` are **implementation-dependent** unless specified, such as: `TYPE STR10 : STRING[10] := 'ABCDEF'; END_TYPE`.


## Variables

### Representation

#### Single-element Variables

A **single-element** variable is defined as a variable which represents a single data element of one of the elementary types. This subclause defines the means of representing variables **symbolically**, or **directly** represents the association of the data element with physical/logical locations in PC's input/output/memory structure.

**Direct representation** of a *single-element* variable shall be formed by `%`, a *location prefix*, a *size prefix*, and one or more unsigned integers separated by `.`.

> An `*` shall be used in place of size prefix to indicate that the direct representation is not yet fully specified. The location of the variable shall be fully specified inside the `VAR_CONFIG...END_VAR` construction of the configuration, otherwise it's an **error**.

Location Prefix | Meaning   | Size Prefix           | Meaning
---             |   ---     |   ---                 |   ---
I               | Input     | X/None                | Single bit
Q               | Output    | B                     | Byte (8 bits)
M               | Memory    | W                     | Word (16 bits)
*               | Not yet specified | D             | Double (32 bits)
                |           | L                     | Long (64 bits)

Syntax examples:

```
%QX75 or %Q75   (* Output bit 75 *)
%IW2.5.7.1      (* Input word with physical/logical hierarchy 2.5.7.1 *)
```

> The use of hierarchical addressing to permit accessing data in another PC shall be considered a *language extension*. The hierarchy level is **implementation-dependent**.

#### Multi-element Variables

The **multi-element variable** types defined in this standard are *arrays* and *structures*.

An **array** is an *aggregate* that consists of data objects, with identical attributes, each of which may be uniquely referenced by subscripting.

A **structured variable** is a data type consisting of a collection of named elements.

Syntax examples:

```
OUTARY[%MB6,SYM] := INARY[0] + INARY[7] - INARY[%MB6] * %IW62 ;
MODULE_5_CONFIG.SIGNAL_TYPE := SINGLE_ENDED; 
MODULE_5_CONFIG.CHANNEL[5].RANGE := BIPOLAR_10V;
```

### Initialization

When a *configuration element* is "started", each of the variables associated withe this element can take one of the following initial values:

* the value the variable had when the configuration element was “stopped” (a retained value); 
* a user-specified initial value;
* the default initial value for the variable's associated data type.

> The user can declare that a variable is to be retentive by using the `RETAIN` qualifier.

### Declaration

Variable declaration shall have the textual form of keyword `VAR`(or other var keywords), followed one or zero qualifiers, followed by one or more declarations separated by `;`, terminated by keyword `END_VAR`.

Variable declaration keywords:

| Keyword       |   Variable usage  |
| ---           |   ---             |
| `VAR`         | Internal to organization unit |
| `VAR_INPUT`   | Externally supplied, not modifiable within organization unit |
| `VAR_OUTPUT`  | Supplied by organization unit to external entities |
| `VAR_IN_OUT`  | Supplied by external entities - can be modified within organization unit |
| `VAR_EXTERNAL`| Supplied by configuration via `VAR_GLOBAL` - can be modified within organization unit |
| `VAR_GLOBAL`  | Global variable declaration |
| `VAR_ACCESS`  | Access path declaration |
| `VAR_TEMP`    | Temporary storage for variables in function blocks and programs |
| `VAR_CONFIG`  | Instance-specific initialization and location assignment. |
| `RETAIN`     | Retentive variables |
| `NON_RETAIN` | Non-retentive variables |
| `CONSTANT`   | Constant (variable cannot be modified) |
| `AT`          | Location assignment |

Within *function blocks* and *programs*, variables can be declared in `VAR_TEMP...END_VAR` construction. These variables are initialized at each *invocation* of an instance.

The scope of declarations shall be *local* to the program organization unit in which it's declared. `VAR_GLOBAL...END_VAR` variables are only accessible via a `VAR_EXTERNAL` declaration. The type declaration in `VAR_EXTERNAL` shall agree with that of `VAR_GLOBAL`, otherwise it's an **error**.

#### Type Assignment

The assignment of a physical or logical address to a symbolically represented variable shall be accomplished by the use of the `AT` keyword. Where no such assignment is made, automatic allocation of the variable to an appropriate location in the programmable controller memory shall be provided.

Syntax examples:

```
VAR RETAIN
    AT %IW6.2 : WORD;       
    LIM_SW_S5 AT %IX27 : BOOL;
    INARY AT %IW6 : ARRAY [0..9] OF INT;
    THREE : ARRAY[1..5,1..10,1..8] OF INT;
END_VAR
```

#### Initial Value Assignment

Initial values can also be specified by using the instance-specific initialization feature provided by the `VAR_CONFIG...END_VAR` construct. Instance-specific initial values always override type-specific initial values.

> Initial values cannot be given in `VAR_EXTERNAL` declarations.

Snytax examples:

普通变量

```
VAR
    VALVE_POS AT %QW28 : INT := 100;
    OUTARY AT %QW6 : ARRAY[0..9] OF INT := [10(1)];
    OKAY : STRING[10] := 'OK';
    TBT : ARRAY [1..2,1..3] OF INT := [1,2,3(4),6] ;
END_VAR
```

结构体

```
(* struct declaration *)
TYPE 
    ANALOG_CHANNEL_CONFIGURATION :
        STRUCT
            RANGE : ANALOG_SIGNAL_RANGE ; 
            MIN_SCALE : ANALOG_DATA ; 
            MAX_SCALE : ANALOG_DATA ;
        END_STRUCT ; 
    ANALOG_16_INPUT_CONFIGURATION :
        STRUCT
            SIGNAL_TYPE : ANALOG_SIGNAL_TYPE ;
            FILTER_PARAMETER : SINT (0..99) ;
            CHANNEL : ARRAY [1..16] OF ANALOG_CHANNEL_CONFIGURATION ;
        END_STRUCT ; 
END_TYPE

(* struct initialization *)
VAR MODULE_8_CONFIG: 
    ANALOG_16_INPUT_CONFIGURATION := (
        SIGNAL_TYPE := DIFFERENTIAL, 
        CHANNEL := [
            4(
                (RANGE := UNIPOLAR_1_5V)
            ), 
            (
                RANGE:= BIPOLAR_10_V,
                MIN_SCALE := 0, 
                MAX_SCALE := 500
            )
        ]
    );
END_VAR
```

函数块

```
(* function block initialization *)
VAR TempLoop : 
    PID := (
        PropBand := 2.5, 
        Integral := T#5s
    );
END_VAR
```

## 程序组织单元

IEC 61131-3 定义的 **程序组织单元** 包括：函数、函数块、程序。这些程序组织单元不应是 *递归* 的，即对一个程序组织单元的调用不会再次引发对该类型程序组织单元的调用。

### 函数

**函数** ：执行后产生一个结果数据元素，和任意数量的输出元素的程序组织单元。

> 函数结果可以是多值的，即数组或结构。函数不能包含状态信息，即每次同样参数的调用应得到同样的结果。已声明的函数可以在其他程序组织单元中调用。

函数使用示例-ST语言：

```
VAR X,Y,Z,RES1,RES2 : REAL; EN1,V : BOOL; END_VAR

RES1 := DIV(IN1 := COS(X), IN2 := SIN(Y), ENO => EN1); 
RES2 := MUL (SIN(X), COS(Y));

Z: = ADD(EN := EN1, IN1 := RES1, IN2 := RES2, ENO => V);
```

函数使用示例-FBD语言：

```
       +-----+      +------+     +------+
X ---+-| COS |--+  -|EN ENO|-----|EN ENO|--- V
     | |     |  |   |      |     |      |
     | +-----+  +---| DIV  |-----| ADD  |--- Z
     |              |      |     |      |
     | +-----+      |      |   +-|      |
Y -+---| SIN |------|      |   | +------+
   | | |     |      +------+   |
   | | +-----+                 |
   | |                         | 
   | | +-----+      +------+   |
   | +-| SIN |--+  -|EN ENO|-  | 
   |   |     |  |   |      |   |
   |   +-----+  +- -| MUL  |---+
   |                |      |
   |   +-----+      |      | 
   +---| COS |------|      | 
       |     |      +------+
       +-----+
```

#### 表示法

* 对 `VAR_OUTPUT` 的赋值可以空白，也可以用变量。
* 对 `VAR_IN_OUT` 参数的赋值应该是变量。
* 对 `VAR_INPUT` 的赋值可以为空白、常量、变量和函数调用。对于后者，函数的结果将被作为实参。
* 在图形语言中，函数应表示为矩形块，大小取决于输入参数等信息的多少。函数名应卸载矩形块内部。每个输入输出都用一根线来表示。
* 对于输入输出变量名的规定：
    * 没有指定输入变量名时，默认名为：`IN1`, `IN2`（从上到下顺序）
    * 只有一个未命名输入时，默认名为：`IN`
    * 上述默认名可以出现在函数表示的左边，也可以不出现。
* 还可以使用附加输入 `EN` 和附加输出 `ENO`，它们分别位于左右的最上方。
* 应使用信号线进行参数的连接（包括函数结果）。
* 布尔类型的输入输出可用 `O` 进行翻转。
* `VAR_IN_OUT` 应被适当地连接。
* 参数列表是一系列实参到形参的赋值组成的集合。
    * `VAR_IN` `VAR_IN_OUT` 赋值使用 `:=`
    * `VAR_OUT` 赋值使用 `=>`
* 除`EN` `ENO`外，参数列表中参数的数目、类型和顺序都应与函数定义相符。

#### 执行控制

附加的 `EN`(Enable) 输入、`ENO`(Enable Out) 输出可用于控制函数的执行，规则如下：

1. 如果 `EN` 值为 `FALSE`，函数被调用时不应执行，且 `ENO` 应被PC系统重置为 `FALSE`。否则函数应被执行，且 `ENO` 应被PC系统置为 `TRUE`，函数操作中也可以对`ENO`进行赋值。
2. 当函数执行中发生错误时，`ENO` 应被PC系统置为 `FALSE`，否则制造商应提供的其他的错误处理方式。
3. 当`ENO`值为`FALSE`时，函数所有输出的值均 **实现相关** 。

`EN` `ENO` 使用示例：

```
(* LD语言 *)
         +-------+         |
| ADD_EN |   +   | ADD_OK  |
+---||---|EN  ENO|---( )---+ 
|        |       |         |
|    A---|       |---C     |
|    B---|       |         | 
         +-------+         |

(* FBD语言 *)
         +-----+ 
ADD_EN---|EN   |
     A---|  +  |---C 
     B---|     |
         +-----+

```

#### 声明

文本语言中，函数声明由以下几部分组成：

1. 关键字 `FUNCTION`；
2. `VAR_INPUT...END_VAR` 构造，规定输入变量；
4. `VAR_IN_OUT...END_VAR`构造和`VAR_OUTPUT...END_VAR`构造，分别规定输入-输出和输出变量。
3. `VAR...END_VAR` 构造，规定内部变量；
5. 函数体。规定函数对这些变量的操作，通过对与函数同名的变量赋值来设置返回值。
6. 终止关键字 `END_FUNCTION`

图形语言中，函数声明由以下几部分组成：

1. 关键字 `FUNCTION` `END_FUNCTION`，或等效的图形元素；
2. 函数名，函数结果和函数变量的名称、类型、初始值的图形说明；
3. 内部变量的名称、类型、初始值的图形说明。
4. 函数体，同上。

> 每个 *资源* 中的函数声明数目是一个 **实现相关** 的参数。

函数声明示例-ST语言：

```
FUNCTION SIMPLE_FUN : REAL 
    (* External interface specification *) 
    VAR_INPUT
        A,B : REAL ; 
        C   : REAL := 1.0;
    END_VAR
    VAR_IN_OUT COUNT : INT ; END_VAR 
    VAR COUNTP1 : INT ; END_VAR

    (*Function body specification *) 
    COUNTP1 := ADD(COUNT,1); 
    COUNT   := COUNTP1 ;
        SIMPLE_FUN := A*B/C; 
END_FUNCTION
```

函数声明示例-FBD语言：

```
FUNCTION
        +-------------+ (* External interface specification *)
        | SIMPLE_FUN  | 
REAL----|A            |----REAL
REAL----|B            | 
REAL----|C            | 
INT-----|COUNT---COUNT|----INT
        +-------------+
(* Function body specification *)
       +---+
       |ADD|---         +----+ 
COUNT--|   |---COUNTP1--| := |---COUNT
    1--|   |            +----+
       +---+    +---+
            A---| * |   +---+
            B---|   |---| / |---SIMPLE_FUN
                +---+   |   | 
            C-----------|   | 
                        +---+
END_FUNCTION
```

#### 重载、类型化、类型转换

**重载** ：标准函数、函数块、操作或指令可以通过 *一般数据类型* 标识符操作多种类型的输入。可编程控制器系统支持某个标准函数、函数块、操作符、指令的重载时，应对其给定的一般数据类型可接受的基本数据类型都给与支持。

**类型化** ：即在重载函数名后添加`_`和类型名。此时，该函数的输入/输出将被限制为该类型。

> 例如，采用一般数据类型`ANY_NUM`的函数可操作的数据类型包括：`LREAL`,`REAL`,`DINT`,`INT`,`SINT`。
> 
> 在函数重载中，同样的一般数据类型参数应当具有相同的实际类型。如果需要，类型转换会被执行以满足该要求。

重载函数

```
            +-----+
            | ADD | 
ANY_NUM-----|     |----ANY_NUM
ANY_NUM-----|     |
     . -----|     |
     . -----|     |
ANY_NUM-----|     | 
            +-----+
```

类型化函数

```
        +---------+
        | ADD_INT | 
INT-----|         |----INT
INT-----|         | 
 . -----|         | 
 . -----|         |
INT-----|         |
        +---------+
```

类型转换

```
    +-----------+   +---+ 
A---|INT_TO_REAL|---| + |---C 
    +-----------+   |   |
B-------------------|   | 
                    +---+
C := INT_TO_REAL(A)+B;
```

#### 标准函数

这一章对所有可编程控制器编程语言通用的函数进行了定义。包括一些 *可扩展* 的标准函数，它们可以对两个或者更多的输入进行指定的操作。

> 最大的输入数目则是 **实现相关** 的。对于指定形参方式的函数调用，最后位置的形参名将决定实际的输入数目。

示例：

```
X := ADD(Y1,Y2,Y3);
(* 相当于： *)
X := ADD(IN1 := Y1, IN2 := Y2, IN3 := Y3);

I := MUX_INT(K:=3,IN0 := 1, IN2 := 2, IN4 := 3);
(* 相当于： *)
I := 0;
```

标准函数包括：

1. 类型转换函数。`*_TO_**`,`TRUNC`(截断),`*_BCD_TO_**`,`**_TO_BCD_*`，`*`可以是字符类型，`**`可以是整型。
2. 数值函数。`ABS`,`SQRT`,`LN`,`LOG`,`EXP`,`SIN`,`COS`,`TAN`,`ASIN`,`ACOS`,`ATAN`,`+`,`*`,`-`,`/`,`modulo`,`**`,`:=`
3. 位串函数。`SHL`,`SHR`左右移位；`ROR`,`ROL`左右旋转。
4. 选择和比较函数。
    * 选择函数：`SEL(G:=0,IN0:=X,IN1:=5)`,`MAX`,`MIN`,`MUX`.
    * 比较函数：`>`,`<`,`>=`,`<=`,`=`,`<>`.
    * 布尔运算：`&`,`XOR`,`OR`,`NOT`.
5. 字符串函数。`LEN`,`LEFT`,`RIGHT`,`MID`,`CONCAT`,`INSERT`,`DELETE`,`REPLACE`,`FIND`.
6. 时间函数。`+`,`-`,`*`,`/`,`DT_TO_TOD`,`DT_TO_DATE`.
7. 枚举函数。`SEL`,`MUX`,`=`,`<>`

### 函数块

**函数块** ：执行后产生一个或多个值的程序组织单元。 *函数块* 可创建多个 *实例* ，每个实例拥有对应的标识符（即实例名）与相应的数据结构来保存输出变量、内部变量、输入变量（在某些实现中，只保存输入变量的引用）。

> 输出变量和必要的内部变量在执行后将被保存，于是同样参数的调用可能产生不同的结果。在函数块实例外部，只有输入变量和输出变量是可访问的。

#### 表示法

在文本语言中， *函数块的实例* 可使用`VAR...END_VAR`声明，与 *结构体* 实例的声明相同。

在图形语言中， *函数块的实例* 采用矩形块表示，函数块类型名位于块内部，实例名位于块上方，其他规则同 *函数的图形表示* 。

函数块实例使用示例：

```
(* 图形方式，FBD语言 *)
         FF75 
       +------+
       |  SR  | 
%IX1---|S1  Q1|---%QX3
%IX2---|R     | 
       +------+

(* 文本方式，ST语言 *)
VAR FF75: SR; END_VAR (* 声明 *) 
FF75(S1:=%IX1, R:=%IX2); (* 调用 *) 
%QX3 := FF75.Q1 ; (* 输出赋值 *)
```

函数块变量的读写属性：

* 输入变量在函数块内部是只读的，外部是只写的（或通过通信函数等进行读写，见 IEC 61131-1）。
* 输出变量在函数块内部是读写的，外部是只读的。
* 输入-输出变量在内外都是可读写的。

> 未赋值（或未连接）的输入变量将保持他们的初始值或上次调用（假如曾被调用过）时的值。

对于`EN`,`ENO`在函数块中的用法有如下规则：

1. 当`EN`为`FALSE`时，输入变量是否进行赋值是 **实现相关** 的，同时函数块体不应被执行，且`ENO`应被PC系统设为`FALSE`；否则，函数块将被执行且`ENO`应被PC系统赋为`TRUE`，函数块操作中也可以对`ENO`进行赋值。
2. 当`ENO`为`FALSE`时，函数块的输出变量`VAR_OUTPUT`应保持上次调用的值。


#### 声明

如同 *函数声明* ， *函数块声明* 也可采用文本方式和图形方式，他们之间的区别如下：

1. 函数块的界定关键字为：`FUNCTION_BLOCK`,`END_FUNCTION_BLOCK`；
2. `RETAIN`可用作内部变量和输出变量的限定符；
3. 以`VAR_EXTERNAL`构造传入的变量是可修改的；
4. 以`VAR_INPUT`,`VAR_IN_OUT`,`VAR_EXTERNAL`传入的函数块实例的输出变量是只读的。
5. 以`VAR_IN_OUT`,`VAR_EXTERNAL`传入的函数块实例可以被调用；
6. 在文本方式的声明中，`R_EDGE`,`F_EDGE`限定符将引发对`R_TRIG`,`F_TRIG`函数块实例的隐式声明，该限定符提供边沿检测功能；
7. 边沿检测的图形表示中，用`>`,`<`作为输入变量与函数块的交点；
8. 一般数据类型的使用与实际类型的推导与 *函数声明* 相同，对于这类函数块在调用时应显式地进行输出赋值（`=>`）；
9. `*`可用于内部变量声明。
10. 下列情况中的未赋值将产生 **错误** ：
    * 输入-输出变量
    * 函数块类型的输入变量

> 变量和函数块实例可通过`VAR_IN_OUT`传入函数块，而函数/函数块的输出却不可以。这是为了避免不小心对他们进行的修改。

函数块声明-ST语言

```
FUNCTION_BLOCK DEBOUNCE 
(* 外部接口 *) 
VAR_INPUT IN : BOOL ;   (* 初始值 = 0 *)
    DB_TIME : TIME := t#10ms ; (* 初始值 = t#10ms *)
END_VAR
VAR_OUTPUT OUT : BOOL ; (* 初始值 = 0 *) 
    ET_OFF : TIME ;     (* 初始值 = t#0s *)
END_VAR
VAR DB_ON : TON ;       (* 内部变量 *) 
    DB_OFF : TON        (* 函数块实例 *);
    DB_FF : SR ; 
END_VAR

(* 函数块体 *) 
DB_ON(IN := IN, PT := DB_TIME) ;
DB_OFF(IN := NOT IN, PT:=DB_TIME) ; 
DB_FF(S1 :=DB_ON.Q, R := DB_OFF.Q) ; 
OUT := DB_FF.Q ;
ET_OFF := DB_OFF.ET ;

END_FUNCTION_BLOCK
```

函数块声明-FBD语言

```
FUNCTION_BLOCK
(* 外部接口 *)
       +---------------+
       |    DEBOUNCE   | 
BOOL---|IN          OUT|---BOOL 
TIME---|DB_TIME  ET_OFF|---TIME 
       +---------------+

(* 函数体 *)
              DB_ON       DB_FF 
             +-----+     +----+ 
             |TON  |     | SR |
IN----+------|IN  Q|-----|S1 Q|---OUT 
      |  +---|PT ET|  +--|R   |
      |  |   +-----+  |  +----+
      |  |            |
      |  |    DB_OFF  |
      |  |   +-----+  | 
      |  |   |TON  |  |
      +--|--O|IN  Q|--+
DB_TIME--+---|PT ET|--------------ET_OFF 
             +-----+
END_FUNCTION_BLOCK
```

#### 标准函数块

这一章对所有可编程控制器编程语言通用的函数块进行了定义。有些是重载过的，有些具有 *可扩展* 的输入输出。

标准函数块包括：

1. 双稳态。包括置位主导的和复位主导的两种。
2. 边沿检测。包括上升沿检测和下降沿检测两种。
3. 计数器。包括升计数器、降计数器、升降计数器。
4. 定时器。包括脉冲定时器、接通延时定时器、断开延时定时器。
5. 通信函数块。标准通信函数块在 IEC 61131-5 定义，包括：设备检验、轮询数据获取、程控数据获取、参数控制、互锁控制、程控报警、连接管理和保护。

### 程序

**程序** ：为实现机械控制或PC系统过程需要的信号处理，必要的编程语言元素和构造组成的逻辑组合体。

程序的声明和使用与函数块基本相同，附加的特性和区别如下：

1. 分隔关键字为`PROGRAM...END_PROGRAM`
2. 程序可以包含访问路径的定义：`VAR_ACCESS...END_VAR`，提供了命名变量用于通信服务（IEC 61131-5）。
2. 可以包含全局变量定义：`VAR_GLOBAL...END_VAR`。
2. 可以包含外部变量声明：`VAR_EXTERNAL`。
2. 可以包含临时变量定义：`VAR_TEMP`。
3. *程序* 只能在 *资源* 中实例化，而 *函数块* 只能在 *程序* 或其他 *函数块* 中实例化。
4. 程序的全局和内部变量声明中可以包含地址赋值，而不完整的直接表示的地址赋值只能用于内部变量。


## 顺序功能图（SFC）元素

### 概述

**顺序功能图** 用于结构化描述PC程序组织单元的内部组织，它使用本标准定义的语言之一，用于执行 *顺序控制* 函数。

SFC将PC程序组织单元划分为一系列的 *步* 和 *转换* ，它们之间用 *有向连接* 连起来。每个 *步* 与一组 *动作* 关联，每个 *转换* 与一个 *转换条件* 关联。

如果一个程序组织单元的任何部分被划分为SFC元素，那么整个程序组织单元都应进行划分。如果一个程序组织单元没有划分，那么整个程序组织单元可被视为单个 *动作* 。

> SFC要求保存状态信息，故可以描述的程序组织单元只有 *函数块* 和 *程序* 。

### 步

**步** 表示程序组织单元的状态，该状态描述了程序组织单元对于输入输出的行为特性。这些行为规则由其关联的 **动作** 定义。

*步* 在图形语言中，表示为包含步名称的块；在文本语言中表示为`STEP...END_STEP`构造。 *有向连接* 表示为步上方的垂直线，或使用文本表示为`TRANSITION...END_TRANSITION`构造。

**步运行时间** （指从初始化开始）用`***.T`表示。当步被失效时，步运行时间置为失效时的时间；当步被激活时，步运行时间被置为`T#0s`。

**步的状态** 可以是激活的或未激活的，文本语言中用`***.X`表示，图形语言中用块右侧的连线表示。

**程序组织单元的状态** 由激活的 *步* 和内部、输出变量的值定义。其初始状态表示为 **初始步** （初始为激活状态的步）、内部和输出变量的初始值。每个 *SFC网络* 都有且只有一个初始步。初始步表示为双线边缘的块。

> 步名、步状态、步运行时间的名称的作用域对于其所在的程序组织单元是局部的。
> 每个SFC图可以拥有的 *步* 数上限和 *步运行时间* 的精度是 **实现相关** 的。

图形语言

```
   | 
+-----+
| *** |     (* 步 *)
+-----+
   |
    |
+=======+ 
|| *** || 
||     ||   (* 初始步 *)
+=======+
    |
```

文本语言 

```
(* 步 *)
STEP *** :  
    (* Step body *)
END_STEP

(* 初始步 *)
INITIAL_STEP *** :  
    (* Step body *) 
END_STEP
```

### 转换

**转换** 表示了控制从前面的一个或多个 *步* 沿着相应的 *有向连接* 转移到后面的一个或多个 *步* 。 *转换* 表示为与表示 *有向连接* 的垂直线相交的水平线。

与 *转换* 相关联的 *转换条件* 有如下表示方法：

1. *有向连接* 旁放一个ST语言的布尔表达式。
2. *有向连接* 旁放一个LD语言的网络。
3. *有向连接* 旁放一个FBD语言的网络。
4. 放一个LD或FBD语言的网络，使其输出与 *有向连接* 通过 *连接器* 相交。
5. 在ST语言中，使用`TRANSITION...END_TRANSITION`构造，应包含
    * `TRANSITION FROM`（前面的 *步* ）
    * `TO`（后面的 *步* ）
    * `:=`（指定转换条件）。
6. 在IL语言中，使用`TRANSITION...END_TRANSITION`构造，应包含
    * `TRANSITION FROM`（前面的 *步* ）、
    * `TO`（后面的 *步* ）
    * 另起一行的指令列表（用来计算转换条件）
7. 在 *有向连接* 右边放一个 *转换名* ，该标识符应引用一个`TRANSITIN...END_TRANSITINO`构造。

> 转换条件的名称的作用域对于其所在的程序组织单元是局部的。
> 在计算转换条件时如果产生副作用（如对除转换条件的变量赋值）将会被视为 **错误** 。
> 每个SFC图，每个 *步* 可以拥有的 *转换* 数上限是 **实现相关** 的。

示例：

ST布尔表达式

```
   |
+-----+
|STEP7|
+-----+
   |
   + %IX2.4 & %IX2.3
   |
+-----+
|STEP8|
+-----+
   |
```

图形网络

```
(* LD *)             | 
                  +-----+ 
                  |STEP7| 
                  +-----+
| %IX2.4  %IX2.3     | 
+---||-----||--------+ 
|                    |
                  +-----+ 
                  |STEP8| 
                  +-----+
                     |
(* FBD *)              | 
                    +-----+ 
                    |STEP7|
         +-------+  +-----+
         |   &   |     | 
%IX2.4---|       |-----+ 
%IX2.3---|       |     |
         +-------+  +-----+ 
                    |STEP8| 
                    +-----+
                       |
```

连接器

```
              |
           +-----+ 
           |STEP7| 
           +-----+
              | 
>TRANX>-------+ 
              |
           +-----+ 
           |STEP8| 
           +-----+
              |

| %IX2.4  %IX2.3     
+---||-----||----->TRANX>
|                    
```

ST语言

```
STEP STEP7: END_STEP

TRANSITION FROM STEP7 TO STEP8 
    := %IX2.4 & %IX2.3 ;
END_TRANSITION

STEP STEP8: END_STEP
```

IL语言

```
STEP STEP7: END_STEP

TRANSITION FROM STEP7 TO STEP 8: 
    LD %IX2.4
    AND %IX2.3
END_TRANSITION

STEP STEP8: END_STEP
```

LD语言

```
TRANSITION TRAN78 FROM STEP7 TO STEP8:
    |                        | 
    | %IX2.4  %IX2.3  TRAN78 | 
    +---||-----||------( )---+
    |                        |
END_TRANSITION
```

转换名

```
   | 
+-----+ 
|STEP7| 
+-----+
   |
   + TRAN78 
   |
+-----+ 
|STEP8| 
+-----+ 
   |
```

### 动作

每个 *步* 应包含0个或更多的 *动作* 。没有关联动作的步被视为具有`WAIT`功能，等待下一个转换条件变为`TRUE`。

**动作** 可以是：

* 布尔变量
* 一组IL指令
* 一组ST语句
* 一组LD横档
* 一组FBD网络
* SFC图

#### 声明

支持SFC元素的PC实现至少应支持一种以下的动作声明机制。

> *动作* 的作用域对于它的声明所在的程序组织单元是局部的。

LD语言

```
+----------------------------------------+ 
|               ACTION_4                 |
+----------------------------------------+ 
| |  %IX1   %MX3  S8.X  %QX17  |         |
| +---||-----||----||-----()---+         | 
| |                            |         |
| |    +------+                |         |
| +----|EN ENO|         %MX10  |         |
| | C--|  LT  |----------(S)---+         |
| | D--|      |                |         |
| |    +------+                |         |
+----------------------------------------+
```

SFC元素

```
+----------------------------------------+ 
|               OPEN_VALVE_1             |
+----------------------------------------+ 
|          | ...                         |
| +=================+                    |
| || VALVE_1_READY ||                    |
| +=================+                    |
|          |                             | 
|          + STEP8.X                     |
|          |                             |
| +-----------------+  +---+-----------+ | 
| | VALVE_1_OPENING |--| N |VALVE_1_FWD| |
| +-----------------+  +---+-----------+ |
|          | ...                         |
+----------------------------------------+
```

FBD语言

```
+----------------------------------------+ 
|               ACTION_4                 |
+----------------------------------------+
|              +---+                     | 
|        %IX1--| & |                     |
|        %MX3--|   |--%QX17              |
| S8.X---------|   |                     | 
|              +---+    FF28             |
|                      +----+            |
|                      | SR |            | 
|            +------+  | Q1 |-%MX10      | 
|         C--|  LT  |--| S1 |            |
|         D--|      |  +----+            |
|            +------+                    |
+----------------------------------------+
```

ST语言

```
ACTION ACTION_4:
    %QX17 := %IX1 & %MX3 & S8.X ; 
    FF28(S1 := (C<D));
    %MX10 := FF28.Q;
END_ACTION
```

IL语言

```
ACTION ACTION_4: 
    LD S8.X 
    AND %IX1 
    AND %MX3 
    ST %QX17 
    LD C
    LT D
    S1 FF28 
    LD FF28.Q 
    ST %MX10
END_ACTION
```

#### 与步关联

支持SFC元素的PC实现应至少支持一种以下的动作与步的关联机制。

> 每步中的动作上限是 **实现相关** 的。

图形表示

```
  |         (* 动作块 *)
+----+  +-----+----------+---+ 
| S8 |--|  L  | ACTION_1 |DN1|
+----+  |t#10s|          |   |
  |     +-----+----------+---+ 
  + DN1
  |
            
  |         (* 连续的动作块 *)
+----+  +-----+---------------------+---+ 
| S8 |--|  L  |       ACTION_1      |DN1|
+----+  |t#10s|                     |   |
  |     +-----+---------------------+---+ 
  +DN1  |  P  |       ACTION_2      |   |
  |     +-----+---------------------+---+ 
  |     |  N  |       ACTION_3      |   |
  |     +-----+---------------------+---+


            (* 动作块的d字段 *)
    +-----+----------------------+---+ 
----|  N  |      ACTION_4        |   |---
    +-----+----------------------+---+ 
    | %QX17:=%IX1&%MX3&S8.X;         |
    | FF28 (S1 := (C<D));            |
    | %MX10 := FF28.Q;               |
    +--------------------------------+
```

文本表示

```
STEP S8: 
    ACTION_1(L,t#10s,DN1) ; 
    ACTION_2(P) ; 
    ACTION_3(N) ;
END_STEP
```

#### 动作块

**动作块** 是包括一个布尔变量和一个动作限定符的图形元素，用来产生激活条件。

可选的指示符（`c`字段）可以被指定的动作赋值，来表示该动作的完成、超时、错误等。如果没有指定`c`字段，如果`b`字段指定了该动作为布尔变量，则该变量在需要的时候应被解释为`c`字段，如果`b`字段没有指定布尔变量，`c`的值应被视为`FALSE`。

多个 *动作块* 可以在图形中相连，此时有多个指示符变量，但只能有单个共同的布尔输出变量。

除了与 *步* 相关联， *动作块* 也可作为图形元素用于LD或FBD语言。

```
   +-----+--------------+-----+
---| "a" |      "b"     | "c" |--- 
   +-----+--------------+-----+
   | "d"                      |
   |                          | 
   +--------------------------+
(* a: 限定符 *)
(* b: 动作名 *)
(* c: 指示符 *)
(* d: 动作，可以采用： *)
(*    - IL 语言 *)
(*    - ST 语言 *)
(*    - LD 语言 *)
(*    - FBD 语言 *)
```

动作块在LD/FBD图中的使用

```
(* LD *)
|  S8.X  %IX7.5  +---+------+---+  OK1  | 
+--| |----| |----| N | ACT1 |DN1|--( )--+ 
|                +---+------+---+       |

(* FBD *)
         +---+     +---+------+-----+ 
  S8.X---| & |-----| N | ACT1 | DN1 |---OK1
%IX7.5---|   |     +---+------+-----+ 
         +---+
```

#### 动作限定符

每个动作块、步/动作关联都有一个相应的 *动作限定符* ，如下表

限定符  | 解释              | 限定符  | 解释
---     | ---               | ---     | ---
None    | 非存储的          | N       | 非存储的
R       | 重载的复位        | S       | 设置（存储）
L       | 限制时间          | D       | 延迟时间
P       | 脉冲              | SD      | 存储和延迟时间
DS      | 延迟和存储        | SL      | 存储和限制时间
P1      | 脉冲（上升沿）    | P0      | 脉冲（下降沿）

#### 动作控制

动作控制应在功能上等效于下列规则：

1. 每个动作应与一个`ACTION_CONTROL`函数块实例的功能等价体相关联。当动作被声明为布尔变量时，该函数块的输出`Q`即为该变量的状态；当动作被声明为语句或网络时，如果该函数块输出`A`为`TRUE`则应连续地执行，此时动作标志`Q`可以通过函数块实例来只读地访问，实例名即为当前动作名，如`ACTION1.Q`；
2. 如果对`ACTION_CONTROL`的一个布尔输入相应的限定符等效于输入名称（`N`,`R`,`S`,`L`,`D`,`P`,`P0`,`P1`,`SD`,`DS`,`SL`），则称与 *步* 或 *动作块* 有关联。如果至少一个关联是激活的，则`ACTION_CONTROL`的该布尔输入的值为`TRUE`。
3. `ACTION_CONTROL`的`T`输入的值应为一个活动关联的时间相关限定符（`L`,`D`,`SD`,`DS`,`SL`）的时间部分的值。
4. 以下的情况将被视为 **错误**
    * 一个动作有多个活动关联具有时间相关限定符。
    * 当`ACTION_CONTROL`的`SL_FF`的`Q1`输出值为`TRUE`时，`SD`输入值为`TRUE`。
    * 当`ACTION_CONTROL`的`SD_FF`的`Q1`输出值为`TRUE`时，`SL`输入值为`TRUE`。
5. `ACTION_CONTROL`本身不要求实现，只要动作控制等效于以上规则。

`ACTION_CONTROL`函数块（不带“最后扫描”逻辑）-外部接口：

```
       +----------------+
       | ACTION_CONTROL |
BOOL---|N              Q|---BOOL 
BOOL---|R               |
BOOL---|S               | 
BOOL---|L               | 
BOOL---|D               | 
BOOL---|P               |
BOOL---|P1              | 
BOOL---|P0              | 
BOOL---|SD              | 
BOOL---|DS              | 
BOOL---|SL              | 
TIME---|T               |
       +----------------+
```

### 演化规则

SFC网络的 **初始状态** 表征为 *程序* 或 *函数块* 初始化时处于激活状态的 *初始步* 。激活步在 *转换* 发生时沿着 *有向连接* 进行 **演化** 。

当前面的步都处于激活状态时， *转换* 处于激活状态。当 *转换* 处于激活状态并且转换条件为`TRUE`时转换发生。转换发生后，前面步的状态被重置，而后面的步被激活。

如果一次状态转移导致多个步的激活，那么这些步所属序列成为 *同时序列* 。同时被激活后，他们的演化将相互独立。

当步的激活已经传播至声明该步的整个程序组织单元后，对于激活步的测试和后面的转换才可以发生。

> 状态转移时间理论上被视为无限短，而实际上不可能为零，该时间应被PC实现限制。
> 同时激活步的“发散”和“收敛”构造的最大宽度是 **实现相关** 的。

示例：

```
  | 
+----+
| S5 |
+----+ 
  |
  +------+----+--...
  |      |
  +e     +NOT e & f
  |      |
+----+ +----+
| S6 | | S8 |
+----+ +----+
  |      |
```

5到6的转换发生条件：5为激活状态，且e为`TRUE`；
5到8的转换发生条件：5为激活状态，且e为`FALSE`，且f为`TRUE`；

状态转移步骤示例：

转换未激活（`X=0 or 1`）：

```
    |          |       |        | 
+------+    +-----+ +------+ +------+ 
|STEP10|    |STEP9| |STEP13| |STEP22| 
|      |    |     | |  *   | |  *   |
+------+    +-----+ +------+ +------+   
    |          |       |        |
    + X    ====+=======+========+==== 
    |                  |
+------+               +X
|STEP11|               |
|      |      ====+====+===+====
+------+          |        |
    |         +------+  +------+  
              |STEP15|  |STEP16| 
              |      |  |      |
              +------+  +------+ 
                  |        |
```

转换激活，但未发生（`X=0`）：

```
    |          |       |        | 
+------+    +-----+ +------+ +------+ 
|STEP10|    |STEP9| |STEP13| |STEP22| 
|  *   |    |  *  | |  *   | |  *   |
+------+    +-----+ +------+ +------+   
    |          |       |        |
    + X    ====+=======+========+==== 
    |                  |
+------+               +X
|STEP11|               |
|      |      ====+====+===+====
+------+          |        |
    |         +------+  +------+  
              |STEP15|  |STEP16| 
              |      |  |      |
              +------+  +------+ 
                  |        |
```

转换发生（`X=1`）：

```
    |          |       |        | 
+------+    +-----+ +------+ +------+ 
|STEP10|    |STEP9| |STEP13| |STEP22| 
|      |    |     | |      | |      |
+------+    +-----+ +------+ +------+   
    |          |       |        |
    + X    ====+=======+========+==== 
    |                  |
+------+               +X
|STEP11|               |
|  *   |      ====+====+===+====
+------+          |        |
    |         +------+  +------+  
              |STEP15|  |STEP16| 
              |   *  |  |  *   |
              +------+  +------+ 
                  |        |
```

## 配置元素

**配置** 包含 *资源* ， *任务* （在 *资源* 中定义）， *全局变量* ， *访问路径* 和实例初始化。下图为一个简单配置的图形示例：

![](/assets/img/blog/configuration-example.png)

*函数块* 和 *程序* 的纲要声明如下：

![](/assets/img/blog/configuration-example-st.png) 

### 配置，资源和访问路径

下表列举了声明配置、资源、全局变量、访问路径，以及实例化的特性。

编号 | 说明 
---  | --- 
1 | `CONFIGURATION...END_CONFIGURATION` 构造
2 |  定义在`CONFIGURATION`中的`VAR_GLOBAL...END_VAR`构造 
3 | `RESOURCE...ON...END_RESOURCE` 构造
4 | 定义在`RESOURCE`中的`VAR_GLOBAL...END_VAR`构造
5a | 周期性的`TASK`构造
5b | 非周期性的`TASK`构造
6a | 关联`PROGRAM`与`TASK`的`WITH`构造
6b | 关联函数块与`TASK`的`WITH`构造
6c | 没有`TASK`关联的`PROGRAM`声明
7 | `VAR_GLOBAL`中声明的直接表示变量
8a | 直接表示变量与`PROGRAM`输入的连接
8b | `GLOBAL`变量与`PROGRAM`输入的连接
9a | `PROGRAM`输出与直接表示变量的连接
9b | `PROGRAM`输出与`GLOBAL`变量的连接
10a | `VAR_ACCESS...END_VAR`构造
10b | 直接表示变量的访问路径
10c | `PROGRAM`输入的访问路径
10d | `RESOURCE`中`GLOBAL`变量的访问路径
10e | `CONFIGURATION`中`GLOBAL`变量的访问路径
10f | `PROGRAM`输出的访问路径
10g | `PROGRAM`内部变量的访问路径
10h | 函数块输入的访问路径
10i | 函数块输出的访问路径
11 | `VAR_CONFIG...END_VAR`构造
12a | `RESOURCE`声明中的`VAR_GLOBAL CONSTANT`
12b | `CONFIGURATION`声明中的`VAR_GLOBAL CONSTANT`
13a | `RESOURCE`声明中的`VAR_EXTERNAL`
13b | `RESOURCE`声明中的`VAR_EXTERNAL CONSTANT`

* 在`RESOURCE...ON...END_RESOURCE`中的`ON`限定符用来指定处理函数及其人机接口、传感器-执行器接口的类型。
* `VAR_GLOBAL`的作用域限于声明它的 *配置* 或 *资源* 。
* `VAR_ACCESS`用于远程访问（IEC 61131-5），可以关联的变量有：全局变量、直接表示变量、任何 *程序* 和 *函数块* 的输入、输出、内部变量。
* `VAR_CONFIG...END_CONFIG`构造用于初始化符号表示的变量和位置未确定的（`*`表示）直接表示变量。

> `VAR_ACCESS`的关联需要指出变量所处的完整层级；对于下列变量不可定义访问路径：`VAR_TEMP`,`VAR_EXTERNAL`,`VAR_IN_OUT`；访问路径可指定方向：`READ_WRITE`,`READ_ONLY`(默认)。
> `VAR_CONFIG`不可对下列类型的实例初始化：`VAR_TEMP`,`VAR_EXTERNAL`,`VAR CONSTANT`,`VAR_IN_OUT`。

下图给出了上述特性的示例：

```
CONFIGURATION CELL_1
    VAR_GLOBAL w: UINT; END_VAR 
    RESOURCE STATION_1 ON PROCESSOR_TYPE_1
        VAR_GLOBAL z1: BYTE; END_VAR 
        TASK SLOW_1(INTERVAL := t#20ms, PRIORITY := 2) ; 
        TASK FAST_1(INTERVAL := t#10ms, PRIORITY := 1) ;
        PROGRAM P1 WITH SLOW_1 :
            F(x1 := %IX1.1) ; 
        PROGRAM P2 : G(OUT1 => w,
            FB1 WITH SLOW_1, 
            FB2 WITH FAST_1) ;
    END_RESOURCE
    RESOURCE STATION_2 ON PROCESSOR_TYPE_2
        VAR_GLOBAL z2   : BOOL ;
            AT %QW5     : INT ;
        END_VAR
        TASK PER_2(INTERVAL := t#50ms, PRIORITY := 2) ;
        TASK INT_2(SINGLE := z2, PRIORITY := 1);
        PROGRAM P1 WITH PER_2 :
            F(x1:=z2,x2:=w) ; 
        PROGRAM P4 WITH INT_2 :
            H(HOUT1 => %QW5, 
                FB1 WITH PER_2);
        END_RESOURCE
    VAR_ACCESS

        ABLE    : STATION_1.%IX1.1  : BOOL READ_ONLY ;
        BAKER   : STATION_1.P1.x2   : UINT READ_WRITE ;
        CHARLIE : STATION_1.z1      : BYTE ;
        DOG     : w                 : UINT READ_ONLY ;
        ALPHA   : STATION_2.P1.y1   : BYTE READ_ONLY ;
        BETA    : STATION_2.P4.HOUT1: INT READ_ONLY ;
        GAMMA   : STATION_2.z2      : BOOL READ_WRITE ;
        S1_COUNT: STATION_1.P1.COUNT  : INT;
        THETA   : STATION_2.P4.FB2.d1 : BOOL READ_WRITE; 
        ZETA    : STATION_2.P4.FB1.c1 : BOOL READ_ONLY; 
        OMEGA   : STATION_2.P4.FB1.C3 : INT READ_WRITE;
    END_VAR
    VAR_CONFIG
        STATION_1.P1.COUNT : INT := 1; 
        STATION_2.P1.COUNT : INT := 100; 
        STATION_1.P1.TIME1 : TON := (PT := T#2.5s); 
        STATION_2.P1.TIME1 : TON := (PT := T#4.5s); 
        STATION_2.P4.FB1.C2 AT %QB25 : BYTE;
    END_VAR
END_CONFIGURATION
```

### 任务

**任务** 是可以调用一个程序组织单元集合的执行控制元素。可以是周期性地调用，也可以是当指定布尔变量上升沿发生时调用。

> 每个 *资源* 可以拥有任务的上限和任务执行间隔的精度是 **实现相关** 的。

任务对程序执行单元的控制应满足下列规则：

1. 关联的程序组织单元应在任务的`SINGLE`输入的每个上升沿被调度。
2. 当`INTERVAL`输入非零，关联的程序组织单元应被周期性调度，直到`SINGLE`非零。
3. `PRIORITY`输入建立了相关联的程序组织单元的优先级，用于抢占式和非抢占式调度。
4. 没有与`TASK`关联的`program`拥有最低的系统优先级。
5. 当 *函数块* 与 *任务* 关联后，其执行应受该任务的独有控制，而与其声明所在的程序组织单元无关。
6. 没有直接与 *任务* 关联的程序组织单元应遵循程序组织单元的语言元素的正常求值顺序。
7. 同一 *程序* 内函数块的执行应被同步，以保证并发的数据一致性。

任务的图形表示

```
         TASKNAME
       +---------+ 
       |  TASK   |
BOOL---|SINGLE   | 
TIME---|INTERVAL | 
UINT---|PRIORITY |
       +---------+

(* 周期任务 *)
           SLOW_1               FAST_1 
         +---------+          +---------+ 
         |  TASK   |          |  TASK   | 
         |SINGLE   |          |SINGLE   | 
t#20ms---|INTERVAL | t#10ms---|INTERVAL | 
     2---|PRIORITY |      1---|PRIORITY | 
         +---------+          +---------+
```

# 文本语言

## 共同元素

## IL语言

## ST语言

# 图形语言

## 共同元素

## LD语言

## FBD语言
